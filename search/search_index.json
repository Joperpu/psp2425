{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programaci\u00f3n de servicios y procesos - Curso 24/25","text":""},{"location":"#introduccion","title":"Introducci\u00f3n","text":"<p>Bienvenido a los apuntes del m\u00f3dulo profesional de Programaci\u00f3n de servicios y procesos que se imparte en el segundo curso del Ciclo formativo de Grado Superior de Desarrollo de Aplicaciones Multiplataforma.</p> <p>Tiene una duraci\u00f3n de 63 horas, distribuidas en 3 horas semanales.</p> <p>Este m\u00f3dulo profesional contiene la formaci\u00f3n necesaria para desempe\u00f1ar la funci\u00f3n de desarrollo de aplicaciones seguras en red.</p> <p>La funci\u00f3n de desarrollo de aplicaciones seguras en red incluye aspectos como:</p> <ul> <li>La utilizaci\u00f3n de las capacidades ofrecidas por el sistema operativo para la gesti\u00f3n de procesos e hilos.</li> <li>La programaci\u00f3n de aplicaciones compuestas por varios procesos e hilos.</li> <li>El desarrollo de aplicaciones con capacidades para comunicarse y ofrecer servicios a trav\u00e9s de una red.</li> <li>La utilizaci\u00f3n de mecanismos de seguridad en el desarrollo de aplicaciones.</li> </ul> <p>Las actividades profesionales asociadas a esta funci\u00f3n se aplican en el \u00e1rea de sistemas y desarrollo de software en el entorno empresarial.</p>"},{"location":"#objetivos","title":"Objetivos","text":"<p>El m\u00f3dulo busca que el alumnado alance los siguientes objetivos expresados como resultados de aprendizaje:</p> <ul> <li>Desarrolla aplicaciones compuestas por varios procesos reconociendo y aplicando principios de programaci\u00f3n paralela.</li> <li>Desarrolla aplicaciones compuestas por varios hilos de ejecuci\u00f3n analizando y aplicando librer\u00edas espec\u00edficas del lenguaje de programaci\u00f3n.</li> <li>Programa mecanismos de comunicaci\u00f3n en red empleando sockets y analizando el escenario de ejecuci\u00f3n.</li> <li>Desarrolla aplicaciones que ofrecen servicios en red, utilizando librer\u00edas de clases y aplicando criterios de eficiencia y disponibilidad.</li> <li>Protege las aplicaciones y los datos definiendo y aplicando criterios de seguridad en el acceso, almacenamiento y transmisi\u00f3n de la informaci\u00f3n.</li> </ul>"},{"location":"#sesiones","title":"Sesiones","text":"<ul> <li>Mi\u00e9rcoles de 17:00 - 19:30 horas.</li> <li>Viernes de 20:30 - 21:30 horas.</li> </ul>"},{"location":"#contenidos","title":"Contenidos","text":"<p>Los contenidos exigidos al m\u00f3dulo se van a trabajar a trav\u00e9s de 5 unidades did\u00e1cticas a lo largo del curso:</p> Trimestre Unidad Did\u00e1ctica Primer Trimestre 1. Programaci\u00f3n multiproceso2. Programaci\u00f3n multihilo3. Programaci\u00f3n de mecanismos de comunicaci\u00f3n en red con sockets Segundo Trimestre 4. Desarrollo de aplicaciones para ofrecer servicios en red5. Protecci\u00f3n y seguridad"},{"location":"#metodologia","title":"Metodolog\u00eda","text":"<p>La metodolog\u00eda de las clases se basar\u00e1 en una estructura te\u00f3rico-pr\u00e1ctica. El profesor comenzar\u00e1 explicando los fundamentos te\u00f3ricos del tema, apoy\u00e1ndose en ejemplos y ejercicios tipo para ilustrar los conceptos clave. Posteriormente, se propondr\u00e1n ejercicios y pr\u00e1cticas que los alumnos deber\u00e1n resolver, con tiempo dedicado durante la clase para que trabajen de manera aut\u00f3noma o en grupo. Durante este per\u00edodo, el profesor estar\u00e1 disponible para resolver dudas, fomentar el an\u00e1lisis y orientar a los estudiantes en la correcta aplicaci\u00f3n de los conceptos aprendidos.</p>"},{"location":"#evaluacion","title":"Evaluaci\u00f3n","text":"<p>Se realizar\u00e1 mediante la superaci\u00f3n de los resultados de aprendizaje. La calificaci\u00f3n final del m\u00f3dulo se realizar\u00e1 seg\u00fan la ponderaci\u00f3n de los RAs que se muestra a continuaci\u00f3n:</p> <p>Los instrumentos que se usar\u00e1n para evaluar ser\u00e1n los siguientes:</p> <ul> <li>Ejercicios te\u00f3ricos o pr\u00e1cticos individuales o en grupo.</li> <li>Pruebas te\u00f3ricas objetivas.</li> <li>Pruebas pr\u00e1cticas objetivas.</li> </ul>"},{"location":"#contacto","title":"Contacto","text":"<p>A trav\u00e9s del sistema de mensajer\u00eda de Moodle Centros. El correo corporativo solo para comunicaciones URGENTES.</p>"},{"location":"#evaluacion-inicial","title":"Evaluaci\u00f3n inicial","text":"<p>Enlace a la Evaluaci\u00f3n inicial.</p>"},{"location":"pr1.1/","title":"Pr\u00e1ctica 1.1 - Cadenas aleatorias","text":""},{"location":"pr1.1/#descripcion-de-la-practica","title":"Descripci\u00f3n de la pr\u00e1ctica","text":"<p>Implementa una aplicaci\u00f3n, llamada Cadenas, que genere cadenas formadas por caracteres del alfabeto. La cantidad de cadenas ser\u00e1 indicada por el usuario al ejecutar la aplicaci\u00f3n y su longitud ser\u00e1 aleatoria (m\u00e1ximo 20 caracteres). Las cadenas se deben escribir en su salida est\u00e1ndar.</p> <p>Implementa una aplicaci\u00f3n para que lance al menos 10 instancias de la aplicaci\u00f3n Cadenas. El usuario indicar\u00e1 el n\u00famero de instancias (al menos 10) y el n\u00famero de cadenas a generar cada instancia. La aplicaci\u00f3n se llamar\u00e1 Generador.</p>"},{"location":"pr1.1/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Esta pr\u00e1ctica eval\u00faa los criterios de evaluaci\u00f3n e), f), g) y h) del RA1. Para su correcci\u00f3n se tendr\u00e1 en cuenta:</p> <ol> <li>Funcionalidad de la aplicaci\u00f3n \u201cCadenas\u201d (3 puntos)<ul> <li>Genera correctamente el n\u00famero de cadenas indicado por el usuario.</li> <li>Las cadenas est\u00e1n formadas por caracteres alfab\u00e9ticos y tienen longitudes aleatorias (m\u00e1ximo 20 caracteres).</li> <li>Las cadenas se muestran en la salida est\u00e1ndar.</li> </ul> </li> <li>Funcionalidad de la aplicaci\u00f3n \u201cGenerador\u201d (4 puntos)<ul> <li>Solicita y lee correctamente el n\u00famero de instancias (al menos 10) y el n\u00famero de cadenas por instancia.</li> <li>Lanza el n\u00famero correcto de instancias de \u201cCadenas\u201d, pasando los par\u00e1metros adecuados.</li> <li>Las instancias se ejecutan correctamente.</li> <li>La comunicaci\u00f3n entre los procesos de realiza correctamente.</li> </ul> </li> <li>Calidad del c\u00f3digo y buenas pr\u00e1cticas (1 punto)<ul> <li>C\u00f3digo legible y bien estructurado, con indentaci\u00f3n adecuada y nombres de variables descriptivos.</li> <li>Uso de comentarios y documentaci\u00f3n donde sea necesario.</li> </ul> </li> <li>Manejo de errores y validaci\u00f3n de entradas (1 punto)<ul> <li>Validaci\u00f3n correcta de las entradas del usuario.</li> <li>Mensajes de error claros y \u00fatiles en caso de entradas inv\u00e1lidas.</li> </ul> </li> <li>Ejecuci\u00f3n y Salida Correcta (1 punto)<ul> <li>Las aplicaciones se ejecutan sin errores y producen la salida esperada.</li> </ul> </li> </ol>"},{"location":"pr1.1/#metodo-de-entrega","title":"M\u00e9todo de entrega","text":"<p>Comprime todo el proyecto realizado con IntelliJ IDEA en un archivo ZIP y s\u00fabelo a la plataforma Moodle Centros en el lugar dedicado a ello. El archivo ZIP deber\u00e1 tener el siguiente formato:</p> <p>Apellido1Apellido2_Nombre_PSP_UD1_P1.zip</p>"},{"location":"pr1.2/","title":"Pr\u00e1ctica 1.2 - Programaci\u00f3n multiproceso","text":""},{"location":"pr1.2/#ejercicio-1","title":"Ejercicio 1","text":"<p>En este ejercicio debes realizar la multiplicaci\u00f3n de 2 arrays de n\u00fameros enteros de dimensi\u00f3n 10. El resultado de la multiplicaci\u00f3n es un nuevo array donde el elemento de posici\u00f3n 0 es igual a la multiplicaci\u00f3n de posici\u00f3n 0 de los dos arrays, el de posici\u00f3n 1 multiplica las posiciones 1 de los dos arrays, y as\u00ed sucesivamente.</p> <p>Realiza un programa padre llamado Ejecuta_Ejercicio1 que inicialice los arrays con n\u00fameros aleatorios y env\u00ede a dos procesos hijos cuya clase se llama Ejercicio1 la mitad de cada array. Los procesos hijos deben devolver la multiplicaci\u00f3n de las partes de los arrays que les ha correspondido.</p> <p>El proceso padre debe mostrar por consola el resultado de la multiplicaci\u00f3n de los dos arrays que ha recogido de los procesos hijos.</p>"},{"location":"pr1.2/#ejercicio-2","title":"Ejercicio 2","text":"<p>Realiza un programa que lea por teclado en un proceso repetitivo datos de alumnos. Los datos de los alumnos que debe leer son el nombre (String) y la edad (int). El proceso repetitivo finaliza cuando el nombre sea *.</p> <ul> <li>Si el nombre le\u00eddo es blanco o su longitud de caracteres es 0 se debe volver a leer.</li> <li>Si la edad no est\u00e1 comprendida entre 1 y 99, se debe volver a leer.</li> <li>Igualmente, se debe volver a leer si se introduce una cadena en lugar de un n\u00famero en dicho campo.</li> <li>Se deben visualizar mensajes al pedir los datos y cuando no son correctos.</li> </ul> <p>Una vez finalizado el proceso de lectura de los datos se debe mostrar al usuario un mensaje con el n\u00famero de alumnos le\u00eddos, el nombre del alumno con m\u00e1s edad y el nombre del alumno con menos edad. Nombra al programa Ejercicio2.</p> <p>A continuaci\u00f3n, se muestra un ejemplo de la salida de ejecuci\u00f3n del programa:</p> <pre><code>1- Introduce datos de alumnos:\n\nEscribe un nombre:\nJUAN\n\nIntroduce la edad entre 1 y 99:\n10\n\nDatos introducidos: JUAN, 10\n\n2- Introduce datos de alumnos:\n\nEscribe un nombre:\nPEDRO\n\nIntroduce la edad entre 1 y 99:\n16\n\nDatos introducidos: PEDRO, 16\n\n3- Introduce datos de alumnos:\n\nEscribe un nombre:\n\nIncorrecto, escr\u00edbelo de nuevo:\n\nEscribe un nombre:\nANA\n\nIntroduce la edad entre 1 y 99:\n0\n\nIncorrecto, debe estar entre 1 y 99\n\nIntroduce la edad entre 1 y 99:\n33\n\nDatos introducidos: ANA, 33\n\n4- Introduce datos de alumnos:\n\nEscribe un nombre:\n*\n\nFin del proceso de lectura...\n\nDatos le\u00eddos: 3\n\nAlumno con m\u00e1s edad: ANA\n\nAlumno con menos edad: JUAN\n</code></pre> <p>Realiza otro programa Java para ejecutar Ejercicio2. Este programa recibe desde los argumentos de main() el nombre de los ficheros que contendr\u00e1n los datos de entrada para la ejecuci\u00f3n del programa Ejercicio2. Pueden ser varios ficheros. El programa Ejercicio2 se ejecutar\u00e1 tantas veces como ficheros hay en los argumentos del main().</p> <p>La salida de las distintas ejecuciones del programa se debe almacenar en un fichero, cuyo nombre coincidir\u00e1 con el del fichero de entrada, pero a\u00f1adiendo una letra S al principio del nombre del mismo. Tambi\u00e9n la salida de error de cada ejecuci\u00f3n se almacenar\u00e1 en otro fichero, cuyo nombre ser\u00e1 el mismo que el nombre del fichero de entrada, pero a\u00f1adiendo la letra E al principio del nombre del mismo.</p> <p>Si el programa no recibe los argumentos requeridos (1 o m\u00e1s) debe mostrar un mensaje y finalizar la ejecuci\u00f3n.</p> <p>Si alguno de los nombres de fichero indicados en los argumentos de main() no existe, se debe mostrar un mensaje indic\u00e1ndolo.</p> <p>El programa debe mostrar en pantalla el n\u00famero de veces que se ejecuta Ejercicio2 y el mensaje de fin de proceso.</p> <p>El programa debe crear tantos ficheros de salida como ficheros de entrada existan. Por ejemplo, si los ficheros de entrada se llaman Fichero1.txt, Fichero2.txt y Fichero3.txt, y existen, se deben generar los ficheros de salida SFichero1.txt, SFichero2.txt y SFichero3.txt.</p> <p>Igualmente, se deben crear tantos ficheros de salida de error como ficheros de entrada (siempre y cuando los ficheros de entrada existan). En este caso EFichero1.txt, EFichero2.txt y EFichero3.txt, los cuales se encontrar\u00e1n vac\u00edos si no se produce ning\u00fan error.</p> <p>Este programa se llamar\u00e1 Ejecuta_Ejercicio2.</p> <p>Un ejemplo del contenido del fichero con datos de alumnos podr\u00eda ser el siguiente:</p> <pre><code>FELIPE 19\nPABLO 21\nMARIA 11\nIVAN 1000\n*\n</code></pre>"},{"location":"pr1.2/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Esta pr\u00e1ctica eval\u00faa los criterios de evaluaci\u00f3n e), f), g) y h) del RA1. Para su correcci\u00f3n se tendr\u00e1 en cuenta en cada uno de los ejercicios:</p> <ol> <li>Funcionalidad de la aplicaci\u00f3n Hija (1,5 puntos)<ul> <li>Implementa adecuadamente todos los requisitos de la aplicaci\u00f3n.</li> </ul> </li> <li>Funcionalidad de la aplicaci\u00f3n Padre (2 puntos)<ul> <li>Implementa adecuadamente todos los requisitos de la aplicaci\u00f3n.</li> </ul> </li> <li>Calidad del c\u00f3digo y buenas pr\u00e1cticas (0,5 puntos)<ul> <li>C\u00f3digo legible y bien estructurado, con indentaci\u00f3n adecuada y nombres de variables descriptivos.</li> <li>Uso de comentarios y documentaci\u00f3n donde sea necesario.</li> </ul> </li> <li>Manejo de errores y validaci\u00f3n de entradas (0,5 puntos)<ul> <li>Validaci\u00f3n correcta de las entradas del usuario.</li> <li>Mensajes de error claros y \u00fatiles en caso de entradas inv\u00e1lidas.</li> </ul> </li> <li>Ejecuci\u00f3n y Salida Correcta (0,5 puntos)<ul> <li>Las aplicaciones se ejecutan sin errores y producen la salida esperada.</li> </ul> </li> </ol>"},{"location":"pr1.2/#metodo-de-entrega","title":"M\u00e9todo de entrega","text":"<p>Comprime todos los ejercicios, separados por carpetas, en un archivo ZIP y s\u00fabelo a la plataforma Moodle Centros en el lugar dedicado a ello. El archivo ZIP deber\u00e1 tener el siguiente formato:</p> <p>Apellido1Apellido2_Nombre_PSP_UD1_P2.zip</p>"},{"location":"pr2.1/","title":"Pr\u00e1ctica 2.1 - Programaci\u00f3n multihilo en Java","text":""},{"location":"pr2.1/#ejercicio-1","title":"Ejercicio 1","text":"<p>Crea una clase que extienda de Thread cuya \u00fanica funcionalidad sea visualizar el mensaje \"Hola mundo\". Crea un programa Java que visualice el mensaje anterior 5 veces creando para ello 5 hilos diferentes usando la clase creada  anteriormente. Modifica el mensaje \"Hola mundo\" en el hilo para incluir el identificador del hilo. Prueba de nuevo el programa Java creado  anteriormente.</p>"},{"location":"pr2.1/#ejercicio-2","title":"Ejercicio 2","text":"<p>Crea una clase que implemente la interfaz Runnable cuya \u00fanica funcionalidad sea visualizar el mensaje \"Hola mundo\" seguido de una cadena que se recibir\u00e1 en el constructor (es  decir al crear un objeto de este tipo se enviar\u00e1 una cadena) y seguido del identificador del hilo. Crea un programa Java que visualice el mensaje anterior 5 veces creando para ello 5 hilos  diferentes usando la clase creada anteriormente. Luego haz que antes de visualizar el mensaje el hilo espere un tiempo proporcional a su identificador; usa para ello el m\u00e9todo sleep(). \u00bfQu\u00e9 diferencias observas al ejecutar el programa usando o no el m\u00e9todo sleep()?</p>"},{"location":"pr2.1/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Esta pr\u00e1ctica eval\u00faa los criterios de evaluaci\u00f3n a), b), c), d) y h) del RA2. Para su correcci\u00f3n se tendr\u00e1 en cuenta:</p> <ol> <li>Funcionalidad del ejercicio 1 (3,5 puntos)<ul> <li>Implementa adecuadamente todos los requisitos de la aplicaci\u00f3n.</li> </ul> </li> <li>Funcionalidad del ejercicio 2 (3,5 puntos)<ul> <li>Implementa adecuadamente todos los requisitos de la aplicaci\u00f3n.</li> </ul> </li> <li>Calidad del c\u00f3digo y buenas pr\u00e1cticas (0,5 puntos)<ul> <li>C\u00f3digo legible y bien estructurado, con indentaci\u00f3n adecuada y nombres de variables descriptivos.</li> <li>Uso de comentarios y documentaci\u00f3n donde sea necesario.</li> </ul> </li> <li>Manejo de errores y validaci\u00f3n de entradas (0,5 puntos)<ul> <li>Validaci\u00f3n correcta de las entradas del usuario.</li> <li>Mensajes de error claros y \u00fatiles en caso de entradas inv\u00e1lidas.</li> </ul> </li> <li>Ejecuci\u00f3n y salida correcta (1 punto)<ul> <li>Las aplicaciones se ejecutan sin errores y producen la salida esperada.</li> </ul> </li> <li>Respuesta a las cuestiones (1 punto)<ul> <li>Las cuestiones que se plantean se contestan de manera satisfactoria.</li> </ul> </li> </ol>"},{"location":"pr2.1/#metodo-de-entrega","title":"M\u00e9todo de entrega","text":"<p>Comprime todos los ejercicios, separados por carpetas, en un archivo ZIP y s\u00fabelo a la plataforma Moodle Centros en el lugar dedicado a ello. El archivo ZIP deber\u00e1 tener el siguiente formato:</p> <p>Apellido1Apellido2_Nombre_PSP_UD2_P1.zip</p>"},{"location":"pr2.2/","title":"Pr\u00e1ctica 2.2 - Uso de monitores en Java","text":""},{"location":"pr2.2/#descripcion-de-la-tarea","title":"Descripci\u00f3n de la tarea","text":"<p>Un hilo debe generar un n\u00famero al azar entre 0 y 100, que deben intentar adivinar otros diez hilos. Si un hilo acierta el n\u00famero, debe terminar su ejecuci\u00f3n inmediatamente. Y el resto de los hilos deben tambi\u00e9n terminar su ejecuci\u00f3n en cuanto propongan un n\u00famero y se les avise de que otro hilo ya ha acertado el n\u00famero.</p> <p>Se propone utilizar una clase NumeroOculto con un m\u00e9todo int propuestaNumero(int num) que devuelva los siguientes valores:</p> <ul> <li>\u2013 1 si el juego ya ha terminado porque un hilo ha adivinado el n\u00famero.</li> <li>1 si el n\u00famero propuesto (num) es el n\u00famero oculto.</li> <li>0 en otro caso.</li> </ul> <p>No hace falta crear una clase para el hilo que genera el n\u00famero al azar. Es el hilo inicial, que ejecuta el m\u00e9todo main, y que crea el resto de los hilos.</p> <p>Si quieres, puedes usar para orientarte el siguiente diagrama de clases:</p> <p></p>"},{"location":"pr2.2/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Esta pr\u00e1ctica eval\u00faa todos los criterios de evaluaci\u00f3n del RA2. Para su correcci\u00f3n se tendr\u00e1 en cuenta:</p> <ol> <li>Funcionalidad del ejercicio (5 puntos)<ul> <li>Implementa adecuadamente todos los requisitos de la aplicaci\u00f3n.</li> </ul> </li> <li>Uso correcto de la sincronizaci\u00f3n de los hilos (3 puntos)<ul> <li>Implementa adecuadamente la sincronizaci\u00f3n de los hilos usando monitores.</li> </ul> </li> <li>Calidad del c\u00f3digo y buenas pr\u00e1cticas (0,5 puntos)<ul> <li>C\u00f3digo legible y bien estructurado, con indentaci\u00f3n adecuada y nombres de variables descriptivos.</li> <li>Uso de comentarios y documentaci\u00f3n donde sea necesario.</li> </ul> </li> <li>Manejo de errores (0,5 puntos)<ul> <li>Mensajes de error claros y \u00fatiles.</li> </ul> </li> <li>Ejecuci\u00f3n y salida correcta (1 punto)<ul> <li>Las aplicaciones se ejecutan sin errores y producen la salida esperada.</li> </ul> </li> </ol>"},{"location":"pr2.2/#metodo-de-entrega","title":"M\u00e9todo de entrega","text":"<p>Comprime el proyecto en un archivo ZIP y s\u00fabelo a la plataforma Moodle Centros en el lugar dedicado a ello. El archivo ZIP deber\u00e1 tener el siguiente formato:</p> <p>Apellido1Apellido2_Nombre_PSP_UD2_P2.zip</p>"},{"location":"pr2.3/","title":"Pr\u00e1ctica 2.3 - Sincronizaci\u00f3n de hilos","text":""},{"location":"pr2.3/#ejercicio-1","title":"Ejercicio 1","text":"<p>Crea una clase para gestionar el saldo de una Cuenta. Debe tener m\u00e9todos para obtener el saldo actual, hacer un ingreso (se incrementa al saldo), hacer un reintegro (se le resta al saldo), controlar si hay alg\u00fan error por ejemplo si se hace un reintegro y no hay saldo; o si se hace un ingreso y el saldo supera el m\u00e1ximo; mostrar mensajes con los movimientos que se realicen. La cuenta recibe en su constructor el saldo actual y el valor m\u00e1ximo que puede tener.</p> <p>Crea despu\u00e9s la clase Persona que extienda Thread y que realice en su m\u00e9todo run() 2  ingresos y 2 reintegros altern\u00e1ndolos y con alg\u00fan sleep() en medio. Para crear los movimientos de dinero generar n\u00fameros aleatorios entre 1 y 500. El constructor de la clase debe llevar el nombre de la persona.</p> <p>Crea en el m\u00e9todo main() de la clase Principal un objeto Cuenta compartido por varios objetos Persona e inicia el proceso de realizar movimientos en la cuenta.</p>"},{"location":"pr2.3/#ejercicio-2","title":"Ejercicio 2","text":"<p>Desarrolla un programa en Java que simule el control de stock en un almac\u00e9n. El almac\u00e9n recibe piezas a intervalos regulares y tambi\u00e9n despacha piezas en otros momentos. Para implementar esta simulaci\u00f3n, se utilizar\u00e1 el patr\u00f3n de dise\u00f1o productor-consumidor y se manejar\u00e1 mediante hilos para garantizar la concurrencia y la sincronizaci\u00f3n.</p> <p>El almac\u00e9n parte de 8000 piezas y tiene una capacidad m\u00e1xima de 20000 piezas. Si la cantidad de piezas en el almac\u00e9n alcanza su l\u00edmite m\u00e1ximo, el productor debe esperar hasta que haya espacio disponible para agregar m\u00e1s piezas.</p> <p>Las piezas entran al almac\u00e9n cada 8 horas en cantidades aleatorias que oscilan entre 400 y 1000 piezas. </p> <p>Del almac\u00e9n salen piezas cada 24 horas, a un ritmo de entre 2000 y 2500 piezas. Debe mostrarse el estado del stock de piezas en cada iteraci\u00f3n del programa.</p> <p>Clases a crear:</p> <ul> <li>Almacen: Esta clase representar\u00e1 el almac\u00e9n y contendr\u00e1 m\u00e9todos para agregar y quitar piezas, as\u00ed como para mostrar el estado actual del stock.</li> <li>Productor: Clase que implementar\u00e1 el hilo del productor. Su funci\u00f3n ser\u00e1 agregar piezas al almac\u00e9n.</li> <li>Consumidor: Clase que implementar\u00e1 el hilo del consumidor. Se encargar\u00e1 de quitar piezas del almac\u00e9n.</li> <li>Main: Clase principal que iniciar\u00e1 el programa, crear\u00e1 instancias de Almacen, Productor y Consumidor, y controlar\u00e1 la ejecuci\u00f3n de los hilos.</li> </ul> <p>Consideraciones:</p> <ul> <li>El almac\u00e9n debe tener una capacidad m\u00e1xima definida.</li> <li>Los hilos del productor y del consumidor deben operar de manera concurrente y sincronizada para evitar problemas de concurrencia en el almac\u00e9n.</li> <li>El programa debe mostrar de manera clara y ordenada el estado actual del stock en el almac\u00e9n en cada iteraci\u00f3n.</li> </ul>"},{"location":"pr2.3/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Esta pr\u00e1ctica eval\u00faa todos los criterios de evaluaci\u00f3n del RA2. Para su correcci\u00f3n se tendr\u00e1 en cuenta:</p> <ol> <li>Funcionalidad de los ejercicios (5 puntos)<ul> <li>Implementa adecuadamente todos los requisitos de las aplicaciones.</li> </ul> </li> <li>Uso correcto de la sincronizaci\u00f3n de los hilos (3 puntos)<ul> <li>Implementa adecuadamente la sincronizaci\u00f3n de los hilos.</li> </ul> </li> <li>Calidad del c\u00f3digo y buenas pr\u00e1cticas (0,5 puntos)<ul> <li>C\u00f3digo legible y bien estructurado, con indentaci\u00f3n adecuada y nombres de variables descriptivos.</li> <li>Uso de comentarios y documentaci\u00f3n donde sea necesario.</li> </ul> </li> <li>Manejo de errores (0,5 puntos)<ul> <li>Mensajes de error claros y \u00fatiles.</li> </ul> </li> <li>Ejecuci\u00f3n y salida correcta (1 punto)<ul> <li>Las aplicaciones se ejecutan sin errores y producen la salida esperada.</li> </ul> </li> </ol>"},{"location":"pr2.3/#metodo-de-entrega","title":"M\u00e9todo de entrega","text":"<p>Comprime el proyecto en un archivo ZIP y s\u00fabelo a la plataforma Moodle Centros en el lugar dedicado a ello. El archivo ZIP deber\u00e1 tener el siguiente formato:</p> <p>Apellido1Apellido2_Nombre_PSP_UD2_P3.zip</p>"},{"location":"pr2.4/","title":"Pr\u00e1ctica 2.4 - Sincronizaci\u00f3n de hilos II","text":""},{"location":"pr2.4/#ejercicio-1","title":"Ejercicio 1","text":"<p>En una carretera de dos carriles que discurre de Norte a Sur (y de Sur a Norte) hay un puente estrecho de un solo carril. Por ese puente solo pueden circular veh\u00edculos en un solo sentido al mismo tiempo, con la regla de que, estando los veh\u00edculos circulando en un sentido, cuando haya N o m\u00e1s veh\u00edculos (N es un par\u00e1metro del problema) esperando a cruzar en sentido contrario, se impide que entren nuevos veh\u00edculos al puente en el sentido actual de la marcha, para permitir cambiar \u00e9sta cuanto antes. En el caso de que haya N o m\u00e1s veh\u00edculos esperando a cruzar en cada uno de los dos sentidos, se debe dar prioridad a los veh\u00edculos que suben, es decir, que van de Sur a Norte. </p> <p>Se pide escribir un objeto protegido dotado de cuatro operaciones (Entrar_Norte, Salir_Norte, Entrar_Sur, Salir_Sur) que implemente el protocolo anterior.</p>"},{"location":"pr2.4/#ejercicio-2","title":"Ejercicio 2","text":"<p>Una barber\u00eda tiene una sala de espera con n sillas y una habitaci\u00f3n con un sill\u00f3n donde se atiende a los clientes. Si no hay clientes el barbero se duerme. Si un cliente entra en la barber\u00eda pero todas las sillas est\u00e1n ocupadas, entonces se va, dejando la barber\u00eda. Si el barbero esta ocupado entonces el cliente se sienta en una de las sillas disponibles. Si el barbero esta dormido el cliente lo despertar\u00e1. Escribir una aplicaci\u00f3n que coordine el barbero y sus clientes de forma adecuada utilizando sem\u00e1foros.</p>"},{"location":"pr2.4/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Esta pr\u00e1ctica eval\u00faa todos los criterios de evaluaci\u00f3n del RA2. Para su correcci\u00f3n se tendr\u00e1 en cuenta:</p> <ol> <li>Funcionalidad de los ejercicios (5 puntos)<ul> <li>Implementa adecuadamente todos los requisitos de las aplicaciones.</li> </ul> </li> <li>Uso correcto de la sincronizaci\u00f3n de los hilos (3 puntos)<ul> <li>Implementa adecuadamente la sincronizaci\u00f3n de los hilos.</li> </ul> </li> <li>Calidad del c\u00f3digo y buenas pr\u00e1cticas (0,5 puntos)<ul> <li>C\u00f3digo legible y bien estructurado, con indentaci\u00f3n adecuada y nombres de variables descriptivos.</li> <li>Uso de comentarios y documentaci\u00f3n donde sea necesario.</li> </ul> </li> <li>Manejo de errores (0,5 puntos)<ul> <li>Mensajes de error claros y \u00fatiles.</li> </ul> </li> <li>Ejecuci\u00f3n y salida correcta (1 punto)<ul> <li>Las aplicaciones se ejecutan sin errores y producen la salida esperada.</li> </ul> </li> </ol>"},{"location":"pr2.4/#metodo-de-entrega","title":"M\u00e9todo de entrega","text":"<p>Comprime el proyecto en un archivo ZIP y s\u00fabelo a la plataforma Moodle Centros en el lugar dedicado a ello. El archivo ZIP deber\u00e1 tener el siguiente formato:</p> <p>Apellido1Apellido2_Nombre_PSP_UD2_P4.zip</p>"},{"location":"pr3.1/","title":"Pr\u00e1ctica 3.1 - Implementaci\u00f3n de una sala de chat cliente/servidor en Java usando UDP","text":""},{"location":"pr3.1/#descripcion-de-la-tarea","title":"Descripci\u00f3n de la tarea","text":"<p>Desarrolla una aplicaci\u00f3n cliente/servidor en Java que permita a m\u00faltiples clientes participar en una sala de chat utilizando el protocolo UDP. La aplicaci\u00f3n debe incorporar funcionalidades adicionales que mejoren la experiencia de usuario y la robustez del sistema.</p>"},{"location":"pr3.1/#requisitos-especificos","title":"Requisitos espec\u00edficos","text":"<ol> <li>Comunicaci\u00f3n b\u00e1sica:<ul> <li>Implementar un servidor UDP que reciba mensajes de los clientes y los reenv\u00ede a todos los clientes conectados.</li> <li>Implementar un cliente UDP que permita a los usuarios enviar mensajes al servidor y recibir mensajes de otros usuarios a trav\u00e9s del servidor.</li> </ul> </li> <li>Nombres de usuario \u00fanicos:<ul> <li>Al iniciar la aplicaci\u00f3n, cada cliente debe ingresar un nombre de usuario.</li> <li>El servidor debe garantizar que no existan dos usuarios conectados con el mismo nombre.</li> <li>Si un nombre de usuario ya est\u00e1 en uso, el servidor debe notificar al cliente y solicitar un nombre diferente.</li> <li>Todos los mensajes enviados deben incluir el nombre de usuario del remitente.</li> </ul> </li> <li>Mensajes privados:<ul> <li>Permitir a los usuarios enviar mensajes privados a otros usuarios espec\u00edficos.</li> <li>Utilizar un formato especial para los mensajes privados, por ejemplo: <code>/privado &lt;usuario_destino&gt; &lt;mensaje&gt;</code></li> <li>El servidor debe reenviar el mensaje \u00fanicamente al usuario destinatario, indicando que es un mensaje privado.</li> <li>Si el usuario destinatario no existe o no est\u00e1 conectado, el servidor debe notificar al remitente.</li> </ul> </li> <li>Listado de usuarios conectados:<ul> <li>Implementar un comando que permita a los clientes solicitar la lista actual de usuarios conectados.</li> <li>Utilizar un comando espec\u00edfico, por ejemplo: <code>/usuarios</code></li> <li>El servidor debe responder al cliente que lo solicit\u00f3 con la lista actualizada de usuarios.</li> </ul> </li> <li>Desconexi\u00f3n limpia:<ul> <li>Cuando un cliente decide salir del chat, debe notificar al servidor mediante un comando, por ejemplo: <code>/salir</code></li> <li>El servidor debe eliminar al usuario de la lista de usuarios conectados.</li> <li>El servidor debe notificar a los dem\u00e1s clientes que el usuario se ha desconectado.</li> </ul> </li> <li>Manejo de comandos desconocidos:<ul> <li>Si un cliente env\u00eda un comando no reconocido (por ejemplo, un mensaje que comienza con <code>/</code> pero no es un comando v\u00e1lido), el servidor debe responder al cliente con un mensaje de error adecuado.</li> </ul> </li> <li>Historial de mensajes:<ul> <li>El servidor debe mantener un historial de los \u00faltimos 10 mensajes.</li> <li>Cuando un nuevo cliente se conecta, el servidor le env\u00eda el historial para que pueda ponerse al d\u00eda con la conversaci\u00f3n.</li> </ul> </li> <li>Interfaz de usuario:<ul> <li>Los mensajes deben ser claros y distinguir entre mensajes p\u00fablicos, mensajes privados y notificaciones del sistema.</li> <li>Ejemplo de formato para mensajes p\u00fablicos: <code>[Usuario] Mensaje</code></li> <li>Ejemplo de formato para mensajes privados: <code>[Privado de Usuario] Mensaje</code></li> <li>Ejemplo de notificaci\u00f3n del sistema: <code>Usuario se ha conectado/desconectado</code></li> </ul> </li> <li>Servidor monohilo:<ul> <li>Importante: El servidor no debe ser multihilo. Todas las operaciones deben manejarse en un solo hilo de ejecuci\u00f3n.</li> <li>A pesar de las limitaciones de no utilizar hilos adicionales, el servidor debe ser capaz de manejar m\u00faltiples clientes de manera eficiente utilizando el protocolo UDP.</li> </ul> </li> <li>Robustez y manejo de errores:<ul> <li>El servidor y los clientes deben manejar adecuadamente posibles excepciones y errores de comunicaci\u00f3n.</li> <li>La aplicaci\u00f3n no debe cerrarse inesperadamente ante entradas incorrectas o problemas de red.</li> <li>Implementar validaciones necesarias para garantizar la estabilidad del sistema.</li> </ul> </li> <li>Visualizaci\u00f3n de actividades del servidor:<ul> <li>El servidor debe mostrar en la consola, durante su ejecuci\u00f3n, las acciones que va realizando.</li> <li>Esto incluye eventos como: conexiones de nuevos usuarios, desconexiones, recepci\u00f3n y env\u00edo de mensajes, manejo de comandos y cualquier error o situaci\u00f3n relevante.</li> <li>La informaci\u00f3n mostrada debe ser clara y permitir al administrador del servidor entender el estado y actividad del sistema.</li> </ul> </li> </ol>"},{"location":"pr3.1/#instrucciones-adicionales","title":"Instrucciones Adicionales","text":"<ul> <li>Desarrollo modular:<ul> <li>Estructura tu c\u00f3digo de forma modular, creando funciones o m\u00e9todos que separen claramente las distintas funcionalidades (por ejemplo, manejo de comandos, env\u00edo y recepci\u00f3n de mensajes, etc.).</li> </ul> </li> <li>Comentarios y buenas pr\u00e1cticas:<ul> <li>Incluye comentarios en el c\u00f3digo que expliquen las partes m\u00e1s importantes y la l\u00f3gica implementada.</li> <li>Sigue las buenas pr\u00e1cticas de programaci\u00f3n en Java (nombres de variables significativos, indentaci\u00f3n, manejo adecuado de recursos, etc.).</li> </ul> </li> <li>Pruebas:<ul> <li>Realiza pruebas exhaustivas para asegurarte de que todas las funcionalidades funcionan correctamente.</li> <li>Prueba escenarios como: conexi\u00f3n de m\u00faltiples usuarios, env\u00edo de mensajes p\u00fablicos y privados, manejo de usuarios con nombres duplicados, comandos desconocidos, etc.</li> </ul> </li> <li>Documentaci\u00f3n:<ul> <li>Proporciona un breve manual de usuario que explique c\u00f3mo utilizar la aplicaci\u00f3n, incluyendo los comandos disponibles y ejemplos de uso.</li> <li>Incluye instrucciones sobre c\u00f3mo compilar y ejecutar la aplicaci\u00f3n.</li> </ul> </li> </ul>"},{"location":"pr3.1/#ayuda-para-la-aplicacion-cliente","title":"Ayuda para la aplicaci\u00f3n cliente","text":"<p>Un posible esquema del c\u00f3digo cliente podr\u00eda ser este:</p> <pre><code>INICIO DEL PROGRAMA\n\n1. Configurar la direcci\u00f3n y el puerto del servidor al que se conectar\u00e1 el cliente.\n\n2. Crear un socket UDP para comunicaci\u00f3n.\n\n3. Solicitar al usuario que ingrese su nombre de usuario.\n\n4. Enviar un mensaje al servidor para registrarse con el nombre de usuario ingresado.\n\n5. Crear un hilo separado para recibir mensajes del servidor:\n    a. Mientras el programa est\u00e9 en ejecuci\u00f3n:\n        i. Esperar a recibir mensajes del servidor.\n        ii. Al recibir un mensaje:\n            - Mostrar el mensaje al usuario.\n    b. Manejar posibles errores en la recepci\u00f3n de mensajes.\n\n6. En el hilo principal, permitir que el usuario ingrese mensajes para enviar:\n    a. Mientras el programa est\u00e9 en ejecuci\u00f3n:\n        i. Leer la entrada del usuario.\n        ii. Si el usuario ingresa un comando para salir:\n            - Notificar al servidor de la desconexi\u00f3n.\n            - Terminar el programa.\n        iii. En caso contrario:\n            - Enviar el mensaje al servidor para que sea procesado.\n\n7. Al terminar el programa:\n    a. Cerrar el socket y liberar recursos.\n    b. Esperar a que el hilo de recepci\u00f3n finalice adecuadamente.\n\nFIN DEL PROGRAMA\n</code></pre>"},{"location":"pr3.1/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Esta pr\u00e1ctica eval\u00faa los criterios de evaluaci\u00f3n a), b), c), d), e), f) y g) del RA3. Para su correcci\u00f3n se tendr\u00e1 en cuenta:</p> <ul> <li>Correctitud y completitud de las funcionalidades requeridas (70%).</li> <li>Calidad del c\u00f3digo (10%).</li> <li>Manejo adecuado de errores y robustez de la aplicaci\u00f3n (5%).</li> <li>Interfaz de usuario (5%).</li> <li>Documentaci\u00f3n y claridad en las instrucciones proporcionadas (10%).</li> </ul>"},{"location":"pr3.1/#metodo-de-entrega","title":"M\u00e9todo de entrega","text":"<p>Comprime el proyecto junto con la documentaci\u00f3n en un archivo ZIP y s\u00fabelo a la plataforma Moodle Centros en el lugar dedicado a ello. El archivo ZIP deber\u00e1 tener el siguiente formato:</p> <p>Apellido1Apellido2_Nombre_PSP_UD3_P1.zip</p>"},{"location":"pr3.2/","title":"Pr\u00e1ctica 3.2 - El juego de la ruleta","text":"<p>Dise\u00f1o e implementaci\u00f3n del juego de la ruleta permitiendo jugar de manera individual o bien en grupos. La finalidad del juego es averiguar la frase o palabra secreta que se muestra en cada partida.</p>"},{"location":"pr3.2/#descripcion-de-la-tarea","title":"Descripci\u00f3n de la tarea","text":"<p>La comunicaci\u00f3n entre los clientes del juego de la ruleta se realizar\u00e1 bajo el protocolo de transporte TCP. La pr\u00e1ctica que se propone consiste en la realizaci\u00f3n de una aplicaci\u00f3n cliente/servidor (multihilo) que implemente el juego de la ruleta mediante el cual, los usuarios del juego (los clientes) se conectan al servicio (el servidor) y pueden jugar una partida, permitiendo o bien jugar una partida de forma individual o bien competir en el juego con otros usuarios. Todas las partidas tanto individuales como colectivas versar\u00e1n sobre la categor\u00eda de refranes.</p>"},{"location":"pr3.2/#juego-individual","title":"Juego individual","text":"<p>La primera variante del juego nos permite jugar una partida al ahorcado de forma individual. Nos conectaremos al servidor y nos permitir\u00e1 iniciar una partida.</p> <p>El procedimiento que se seguir\u00e1 ser\u00e1 el siguiente:</p> <ul> <li>Un cliente se conecta al servicio y si la conexi\u00f3n ha sido correcta el sistema devuelve \u201c+0k. Usuario conectado\u201d.</li> <li>Para poder acceder a los servicios es necesario identificarse mediante el env\u00edo del usuario y clave para que el sistema lo valide. Los mensajes que deben indicarse son: \u201cUSUARIO usuario\u201d para indicar el usuario, tras el cual el servidor enviar\u00e1 \u201c+Ok. Usuario correcto\u201d o \u201c\u2013Err. Usuario incorrecto\u201d. En caso de ser correcto el siguiente mensaje que se espera recibir es \u201cPASSWORD password\u201d, donde el servidor responder\u00e1 con el mensaje de \u201c+Ok. Usuario validado\u201d o \u201c\u2013Err. Error en la validaci\u00f3n\u201d.</li> <li>Un usuario nuevo podr\u00e1 registrarse mediante el mensaje \u201cREGISTRO \u2013u usuario \u2013p password\u201d. Se llevar\u00e1 un control para evitar colisiones con los nombre de usuarios ya existentes.</li> <li> <p>Una vez conectado y validado, el cliente podr\u00e1 llevar a cabo una partida individual en el juego indicando un mensaje de \u201cPARTIDA-INDIVIDUAL\u201d. Recibido este mensaje en el servidor, \u00e9ste se encargar\u00e1 de mandarle una frase con la que iniciar el juego indicando mediante el s\u00edmbolo \u201c-\u201c las posiciones que deben ser rellenadas con consonante o vocal y el s\u00edmbolo \u201c \u201c para indicar el espacio en blanco entre las palabras que componen la frase. No se tendr\u00e1n en cuenta en la frase los signos de puntuaci\u00f3n como elemento a adivinar por el jugador. En este punto son admitidos tres tipos de mensajes que se puede enviar al servidor:</p> <ul> <li>CONSONANTE letra, donde letra indica una consonante que se piensa que puede estar en la frase.</li> <li>VOCAL letra, donde letra indica una vocal que se piensa que puede estar en la frase.</li> <li>RESOLVER frase, donde frase representar\u00e1 una cadena que contiene el refr\u00e1n que queremos resolver. El contenido de la cadena debe ser independiente de si se trata de may\u00fasculas o min\u00fasculas.</li> </ul> </li> <li> <p>Cada vez que un cliente mande un mensaje de CONSONANTE/VOCAL al servidor, \u00e9ste deber\u00e1 devolverle \u201c+Ok. Existe la consonante\u201d seguido por la frase con la informaci\u00f3n que se lleva de momento si la letra est\u00e1 contenida en la frase a resolver o \u201c+Ok. No existe la consonante\u201d seguido por la frase con la informaci\u00f3n que se lleva de momento en caso de que la letra no exista en la palabra a averiguar. En caso de error en la recepci\u00f3n del mensaje, debido a que se trate de una consonante o vocal inv\u00e1lida, se proceder\u00e1 con un mensaje \u201c-Err. Mensaje no v\u00e1lido\u201d.</p> </li> <li>Se llevar\u00e1 la cuenta del n\u00famero de intentos que ha realizado el usuario para resolver la frase, para que finalmente al terminar la partida se le asigne una puntuaci\u00f3n a cada usuario. La puntuaci\u00f3n ser\u00e1 fija y tendr\u00e1 establecido los siguientes valores, si se ha resuelto en menos de 5 intentos tendr\u00e1 una valoraci\u00f3n de 150 puntos, si lo consigue entre 5 y 8 intentos se le asignar\u00e1 100 puntos, entre 9 y 11 ser\u00e1 70 puntos, entre 12 y 15 ser\u00e1 50 puntos y todo lo que sea m\u00e1s de 15 intentos tendr\u00e1 una puntuaci\u00f3n de 0 puntos.</li> <li> <p>Simplemente se podr\u00e1 enviar un mensaje RESOLVER, en caso de acertarse o fallarse se termina la partida y el usuario simplemente podr\u00e1 optar por salir del sistema o realizar otra partida:</p> <ul> <li>Si se acierta la frase se le mandar\u00e1 al cliente un mensaje \u201c+Ok. Enhorabuena\u201d, mostr\u00e1ndole una estad\u00edstica de las frases acertadas y falladas y su puntuaci\u00f3n desde que se registr\u00f3 por primera vez.</li> <li>Si se falla la frase, se le mandar\u00e1 al cliente un mensaje \u201c+Ok. Le deseamos mejor suerte la pr\u00f3xima vez\u201d, mostr\u00e1ndole una estad\u00edstica de las frases acertadas y falladas y su puntuaci\u00f3n desde que se registr\u00f3 por primera vez.</li> </ul> </li> <li> <p>Un mensaje de un cliente en la que se env\u00ede la petici\u00f3n \u201cSALIR\u201d, har\u00e1 que el servidor le d\u00e9 de baja del sistema. Este mensaje puede ser enviado en cualquier momento, incluso en una partida empezada.</p> </li> <li>Cualquier mensaje que no use uno de los especificadores detallados, generar\u00e1 un mensaje de \u201c-Err\u201d por parte del servidor.</li> </ul> <p>Algunas de las restricciones a tener en cuenta son:</p> <ul> <li>La comunicaci\u00f3n ser\u00e1 mediante consola.</li> <li>El cliente deber\u00e1 aceptar como argumento una direcci\u00f3n IP que ser\u00e1 la direcci\u00f3n del servidor al que se conectar\u00e1.</li> <li>El protocolo deber\u00e1 permitir mandar mensajes de tama\u00f1o arbitrario. Teniendo como tama\u00f1o m\u00e1ximo env\u00edo una cadena de longitud 200 caracteres.</li> <li>El servidor aceptar\u00e1 servicios en el puerto 2050.</li> <li>El servidor debe permitir la conexi\u00f3n de varios clientes simult\u00e1neamente. Esto deber\u00e1 resolverse mediante el uso de hilos.</li> <li>El n\u00famero m\u00e1ximo de clientes conectados para jugar ser\u00e1 de 50 usuarios.</li> <li>Todos los mensajes devueltos por el servidor que se necesiten contemplar, seguir\u00e1n el criterio de ir precedidos por +Ok. Texto informativo, si la petici\u00f3n se ha podido aceptar sin problemas y \u2013Err. Texto informativo, si ha habido alg\u00fan tipo de error.</li> <li>Las frases que se van a resolver no tendr\u00e1n en cuenta los signos de puntuaci\u00f3n. En caso de que la frase cuente con alguno de ellos, aparecer\u00e1 directamente como elemento visible desde el principio en la frase que se le muestra al usuario.</li> </ul>"},{"location":"pr3.2/#juego-colectivo","title":"Juego colectivo","text":"<p>La segunda variante del juego nos permite jugar con varias personas, concretamente el juego estar\u00e1 formado por grupo de tres personas.</p> <p>El procedimiento que se seguir\u00e1 ser\u00e1 el siguiente:</p> <ul> <li>Un cliente se conecta al servicio y si la conexi\u00f3n ha sido correcta el sistema devuelve \u201c+0k. Usuario conectado\u201d.</li> <li>Para poder acceder a los servicios es necesario identificarse mediante el env\u00edo del usuario y clave para que el sistema lo valide. Los mensajes que deben indicarse son: \u201cUSUARIO usuario\u201d para indicar el usuario, tras el cual el servidor enviar\u00e1 \u201c+Ok. Usuario correcto\u201d o \u201c\u2013Err. Usuario incorrecto\u201d. En caso de ser correcto el siguiente mensaje que se espera recibir es \u201cPASSWORD password\u201d, donde el servidor responder\u00e1 con el mensaje de \u201c+Ok. Usuario validado\u201d o \u201c\u2013Err. Error en la validaci\u00f3n\u201d.</li> <li>Un usuario nuevo podr\u00e1 registrarse mediante el mensaje \u201cREGISTRO \u2013u usuario \u2013p password\u201d. Se llevar\u00e1 un control para evitar colisiones con los nombre de usuarios ya existentes.</li> <li> <p>Una vez conectado y validado, el cliente podr\u00e1 llevar a cabo una partida en el juego indicando un mensaje de \u201cPARTIDA-GRUPO\u201d. Recibido este mensaje en el servidor, \u00e9ste se encargar\u00e1 de comprobar las personas que tiene pendiente para comenzar una partida:</p> <ul> <li>Si con esta petici\u00f3n, ya se forma un grupo de tres personas, mandar\u00e1 un mensaje a cada una de ellas, para indicarle que la partida va a comenzar.</li> <li>Si todav\u00eda falta alguna persona para iniciar la partida, mandar\u00e1 un mensaje al nuevo usuario, especificando que tiene su petici\u00f3n y que est\u00e1 a la espera de la conexi\u00f3n de otros jugadores. El usuario en este caso deber\u00e1 quedarse a la espera de recibir un mensaje para jugar o tambi\u00e9n se le permitir\u00e1 salir de la aplicaci\u00f3n.</li> <li>Cuando se disponga de tres usuarios, se le deja un mensaje a los tres usuarios indicando que va a comenzar la partida \u201c+Ok. Empieza la partida\u201d y seguido se indica la frase con la que iniciar la partida. Se indicar\u00e1n todas las posiciones que representan una consonante o vocal mediante el s\u00edmbolo \u201c-\u201c y el espacio en blanco \u201c \u201c, se utilizar\u00e1 para representar la separaci\u00f3n entre las palabras de la frase. No se tendr\u00e1n en cuenta en la frase los signos de puntuaci\u00f3n como elemento a adivinar por el jugador. El orden de los usuarios en el juego ser\u00e1 el mismo orden en el que se ha realizado la conexi\u00f3n (aunque puede implementarse otro criterio si lo veis m\u00e1s conveniente).</li> <li>Cada usuario podr\u00e1 ir mandando mensajes de CONSONANTE/VOCAL letra, mientras la frase contenga la letra que va especificando. Esta informaci\u00f3n se va mostrando a cada uno de los usuarios, al igual que los mensajes que env\u00eda el usuario que est\u00e1 jugando en cada momento. Cuando falle, se pasar\u00e1 a otro usuario, as\u00ed hasta que un usuario escoja la opci\u00f3n de RESOLVER la frase. </li> </ul> <p>En este punto son admitidos tres tipos de mensajes que se puede enviar al servidor:</p> <ul> <li>CONSONANTE letra, donde letra indica una consonante que se piense que puede estar en la frase. La puntuaci\u00f3n que se obtiene, ser\u00eda 50 puntos por cada vez que la consonante aparezca en la frase a resolver. Si la frase desconocida no contiene ninguna consonante de la que has elegido, se pasar\u00e1 el turno al siguiente jugador.</li> <li>VOCAL letra, para poder mandar este mensaje necesitas tener al menos 50 puntos, que se restar\u00e1n por cada vocal que solicites, con independencia del n\u00famero de veces que aparezca.</li> <li>RESOLVER frase, donde frase representar\u00e1 una cadena que contiene el refr\u00e1n que queremos resolver.</li> </ul> </li> <li> <p>Se debe tener cuidado con que el servidor cuando lleguen peticiones de usuarios cuando no sea su turno de jugar. En caso de que env\u00eden un mensaje cuando no es su turno, deber\u00e1 responder que todav\u00eda no es turno y deben esperar. La especificaci\u00f3n del mensaje que se enviar\u00eda ser\u00eda: \u201c-Err. Debe esperar su turno\u201d.</p> </li> <li>En caso de que un usuario env\u00ede la petici\u00f3n RESOLVER y \u00e9sta no sea la frase correcta, la partida termina, el usuario que ha fallado queda autom\u00e1ticamente con una puntuaci\u00f3n de cero y ganar\u00eda el usuario que tuviese hasta ese momento una mayor puntuaci\u00f3n. Se enviar\u00e1 un mensaje a cada uno de los jugadores, para indicar puntuaciones y ganador.</li> <li>Para salir del servicio se usar\u00e1 el mensaje \u201cSALIR\u201d, de este modo el servidor lo eliminar\u00e1 de clientes conectados y el juego continuar\u00e1 entre los restantes participantes. Este hecho se le debe de comunicar al resto de usuarios. Cuando quede un \u00fanico jugador podr\u00e1 terminar el panel o salir del sistema.</li> <li>Cualquier mensaje que no use uno de los especificadores detallados, generar\u00e1 un mensaje de \u201c-Err\u201d por parte del servidor.</li> </ul> <p>Algunas restricciones a tener en cuenta en esta nueva versi\u00f3n que se debe implementar es:</p> <ul> <li>La comunicaci\u00f3n ser\u00e1 mediante consola.</li> <li>El cliente deber\u00e1 aceptar como argumento una direcci\u00f3n IP que ser\u00e1 la direcci\u00f3n del servidor al que se conectar\u00e1.</li> <li>El protocolo deber\u00e1 permitir mandar mensajes de tama\u00f1o arbitrario. Teniendo como tama\u00f1o m\u00e1ximo env\u00edo una cadena de longitud 200 caracteres.</li> <li>El servidor aceptar\u00e1 servicios en el puerto 2050.</li> <li>El servidor debe permitir la conexi\u00f3n de varios clientes simult\u00e1neamente. Esto deber\u00e1 resolverse mediante el uso de hilos.</li> <li>El n\u00famero m\u00e1ximo de clientes conectados ser\u00e1 de 50 usuarios.</li> <li>Todos los mensajes devueltos por el servidor que se necesiten contemplar, seguir\u00e1n el criterio de ir precedidos por +Ok. Texto informativo, si la petici\u00f3n se ha podido aceptar sin problemas y \u2013Err. Texto informativo, si ha habido alg\u00fan tipo de error.</li> <li>Las frases que se van a resolver no tendr\u00e1n en cuenta los signos de puntuaci\u00f3n. En caso de que la frase cuente con alguno de ellos, aparecer\u00e1 directamente como elemento visible desde el principio en la frase que se le muestra al usuario.</li> </ul>"},{"location":"pr3.2/#resumen-paquetes","title":"Resumen paquetes","text":"<p>Considerando la pr\u00e1ctica completa, vamos a resumir los tipos de mensajes con el siguiente formato cada uno:</p> <ul> <li>USUARIO usuario: mensaje para introducir el usuario que desea.</li> <li>PASSWORD contrase\u00f1a: mensaje para introducir la contrase\u00f1a asociada al usuario.</li> <li>REGISTER \u2013u usuario \u2013p password: mensaje mediante el cual el usuario solicita registrarse para acceder al juego de la ruleta que escucha en el puerto TCP 2050.</li> <li>CONSONANTE letra, donde letra indica una consonante que se piensa que puede estar en la frase.</li> <li>VOCAL letra, para poder mandar este mensaje necesitas tener al menos 50 puntos, que se restar\u00e1n por cada vocal que solicites, con independencia del n\u00famero de veces que aparezca.</li> <li>RESOLVER frase, donde frase representar\u00e1 una cadena que contiene el refr\u00e1n que queremos resolver.</li> <li>SALIR: mensaje para solicitar salir del juego.</li> <li>Cualquier otra tipo de mensaje que se env\u00ede al servidor, no ser\u00e1 reconocida por el protocolo como un mensaje v\u00e1lido y generar\u00e1 su correspondiente \u201c-Err.\u201d por parte del servidor.</li> </ul>"},{"location":"pr3.2/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Esta pr\u00e1ctica eval\u00faa todos los criterios de evaluaci\u00f3n del RA3. Para su correcci\u00f3n se tendr\u00e1 en cuenta:</p> <ol> <li>Implementaci\u00f3n del protocolo y mensajes (20%)<ul> <li>Correcta recepci\u00f3n y env\u00edo de mensajes seg\u00fan lo descrito en la pr\u00e1ctica:</li> <li>USUARIO, PASSWORD, REGISTRO, CONSONANTE, VOCAL, RESOLVER, SALIR, etc.</li> <li>Respuestas adecuadas: +Ok. / \u2013Err. con los textos de confirmaci\u00f3n o error correspondientes.</li> <li>Manejo de mensajes no v\u00e1lidos (respuestas de tipo \u201c-Err. Mensaje no v\u00e1lido\u201d).</li> <li>Manejo adecuado de tama\u00f1os m\u00e1ximos de mensaje (hasta 200 caracteres).</li> </ul> </li> <li>Funcionalidad del juego individual (20%)<ul> <li>L\u00f3gica correcta para iniciar y finalizar partidas individuales.</li> <li>Control de los intentos y asignaci\u00f3n de puntuaciones (conforme a las reglas: menos de 5 intentos = 150 puntos, entre 5 y 8 = 100, etc.).</li> <li>Posibilidad de RESOLVER la frase en cualquier momento y env\u00edo de mensajes adecuados (+Ok. Enhorabuena o +Ok. Le deseamos mejor suerte\u2026).</li> <li>Mantenimiento y actualizaci\u00f3n de la estad\u00edstica de aciertos, fallos y puntuaci\u00f3n total por usuario.</li> </ul> </li> <li>Funcionalidad del juego colectivo (25%)<ul> <li>Creaci\u00f3n y manejo de grupos de tres jugadores (PARTIDA-GRUPO).</li> <li>Control de turnos de cada jugador (permitir jugar s\u00f3lo al usuario correspondiente, en caso contrario: \u201c-Err. Debe esperar su turno\u201d).</li> <li>Gesti\u00f3n de puntos:<ul> <li>+50 puntos por cada aparici\u00f3n de la consonante.</li> <li>\u201350 puntos al pedir una vocal (se necesita al menos 50 puntos para solicitarla).</li> </ul> </li> <li>Finalizaci\u00f3n correcta de la partida colectiva:<ul> <li>Ganador designado en caso de que alguien falle al RESOLVER.</li> <li>Comunicaci\u00f3n de puntuaciones finales y notificaci\u00f3n al resto de jugadores.</li> </ul> </li> <li>Manejo de la salida de un jugador (mensaje SALIR) y continuidad del juego con el resto, cuando sea posible.</li> </ul> </li> <li>Manejo de concurrencia y varios clientes (15%)<ul> <li>Uso adecuado de hilos para gestionar m\u00faltiples conexiones simult\u00e1neas.</li> <li>Control del n\u00famero m\u00e1ximo de 50 clientes conectados.</li> <li>Evitar bloqueos o comportamientos indeterminados al manejar varios clientes en paralelo.</li> </ul> </li> <li>Estructura y calidad del c\u00f3digo (10%)<ul> <li>Claridad y organizaci\u00f3n del c\u00f3digo fuente (modularizaci\u00f3n, funciones, clases, etc.).</li> <li>Legibilidad: uso de nombres de variables adecuados, comentarios, e indentaci\u00f3n coherente.</li> <li>Manejo adecuado de excepciones o errores a nivel de implementaci\u00f3n (control de flujos, cierres de sockets, etc.).</li> </ul> </li> <li>Documentaci\u00f3n y gu\u00eda de uso (10%)<ul> <li>Instrucciones claras de compilaci\u00f3n y ejecuci\u00f3n (cliente y servidor).</li> <li>Explicaci\u00f3n de c\u00f3mo se gestiona cada comando y su flujo dentro del juego (diagrama o descripci\u00f3n).</li> <li>Descripci\u00f3n de las funciones m\u00e1s relevantes en el c\u00f3digo.</li> <li>Inclusi\u00f3n de un breve manual de usuario con ejemplos de interacci\u00f3n (entrada/salida) para cada modo de juego.</li> </ul> </li> </ol>"},{"location":"pr3.2/#metodo-de-entrega","title":"M\u00e9todo de entrega","text":"<p>Comprime el proyecto junto con la documentaci\u00f3n en un archivo ZIP y s\u00fabelo a la plataforma Moodle Centros en el lugar dedicado a ello. El archivo ZIP deber\u00e1 tener el siguiente formato:</p> <p>Apellido1Apellido2_Nombre_PSP_UD3_P2.zip</p>"},{"location":"pr4.1/","title":"Pr\u00e1ctica 4.1 - Cliente de FTP y correo electr\u00f3nico","text":"<p>Antes de comenzar</p> <p>Para el uso de Jakarta Mail y Apache Commons Net necesitamos importar dichas API o librer\u00edas a nuestro proyecto. Este proceso se simplifica si usamos alguna herramienta para la construcci\u00f3n de proyectos, como puede ser Maven o Gradle.</p> <p>En el caso de Maven, a\u00f1adiendo el archivo pom.xml con las dependencias correspondientes a la ra\u00edz del proyecto.</p>"},{"location":"pr4.1/#ejercicio-1-cliente-de-ftp","title":"Ejercicio 1 - Cliente de FTP","text":"<p>Para comenzar debes crear un servidor FTP en tu equipo. Para ello puedes usar el siguiente tutorial. Adem\u00e1s, deber\u00e1s crear 3 usuarios con una carpeta para cada uno de ellos. Dentro de dichas carpetas deber\u00e1 existir un archivo LOG.txt, cuya primera l\u00ednea es \"Conexiones del usuario.\"</p> <p>A continuaci\u00f3n se muestran los nombres de usuario, contrase\u00f1as, carpetas y archivos a crear. Cada usuario tendr\u00e1 control total sobre su carpeta y ninguno sobre las carpetas de los dem\u00e1s usuarios.</p> Nombre de usuario Contrase\u00f1a Carpeta y archivo usuario1 usu1 usuario1/LOG.txt usuario2 usu2 usuario2/LOG.txt usuario3 usu3 usuario3/LOG.txt <p>Crea una aplicaci\u00f3n en Java que, usando Apache Commons Net, pida por consola un nombre de usuario y contrase\u00f1a en un proceso repetitivo que finalizar\u00e1 cuando el nombre de usuario sea *. Una vez introducido el nombre de usuario y la contrase\u00f1a se deber\u00e1 conectar al servidor FTP que se acaba de crear.</p> <p>Cada vez que se realice esta conexi\u00f3n se deber\u00e1 acceder al archivo LOG del usuario en cuesti\u00f3n y registrar la informaci\u00f3n sobre la fecha y hora en la que se realiza. Por ejemplo.</p> <pre><code>Conexiones del usuario.\nHora de conexi\u00f3n: Fry Jan 24 11:00:00 CET 2025\n</code></pre> <p>Para mostrar la hora de conexi\u00f3n se puede utilizar la siguiente expresi\u00f3n:</p> <pre><code>java.util.Date hora = new java.util.Date(System.currentTimeMillis());\n</code></pre> <p>Cada vez que el usuario se conecte hay que a\u00f1adir una nueva l\u00ednea con la informaci\u00f3n correspondiente. Por ejemplo, si el usuario ha realizado 3 conexiones, el contenido del fichero LOG.txt ser\u00eda el siguiente:</p> <pre><code>Conexiones del usuario.\nHora de conexi\u00f3n: Fry Jan 24 11:00:00 CET 2025\nHora de conexi\u00f3n: Fry Jan 24 11:15:58 CET 2025\nHora de conexi\u00f3n: Fry Jan 24 11:17:23 CET 2025\n</code></pre>"},{"location":"pr4.1/#ejercicio-2-cliente-de-correo-electronico","title":"Ejercicio 2 - Cliente de correo electr\u00f3nico","text":"<p>Crea un cliente SMTP por consola en Java usando Jakarta Mail que permita enviar correos electr\u00f3nicos. El programa solicitar\u00e1 al usuario los siguientes datos: direcci\u00f3n del servidor SMTP, puerto, usuario y contrase\u00f1a.</p> <p>Una vez introducidos deber\u00e1 solicitar la direcci\u00f3n del remitente, del destinatario, el asunto y el cuerpo del mensaje. Adem\u00e1s se deber\u00e1 poder introducir, si el usuario desea, la ruta de un fichero para su env\u00edo.</p> <p>El programa deber\u00e1 mostrar que el env\u00edo ha sido satisfactorio (\"Correo enviado con \u00e9xito.\") o en caso de error (\"No se pudo enviar el correo.\").</p> <p>A continuaci\u00f3n, deber\u00e1s crear un cliente IMAP por consola que permita leer los correos no le\u00eddos de una cuenta de correo electr\u00f3nico. El usuario deber\u00e1 facilitar la direcci\u00f3n del servidor IMAP, el puerto, el usuario y la contrase\u00f1a.</p> <p>La aplicaci\u00f3n mostrar\u00e1 para cada correo sin leer toda la informaci\u00f3n relativa a \u00e9l: remitente, fecha y hora, asunto y cuerpo del mensaje.</p> <p>Se recomienda para este ejercicio el uso de alguna cuenta de correo de Google (tanto para el env\u00edo como para la lectura de mensajes no le\u00eddos), por ejemplo, la corporativa del centro. Para ello es necesario utilizar las contrase\u00f1as para aplicaciones externas que tiene el correo de Google.</p>"},{"location":"pr4.1/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Esta pr\u00e1ctica eval\u00faa todos los criterios de evaluaci\u00f3n del RA4. Para su correcci\u00f3n se tendr\u00e1 en cuenta:</p> <ol> <li>Conexi\u00f3n y autenticaci\u00f3n (FTP y SMTP/IMAP) \u2013 20 %<ul> <li>Correcta configuraci\u00f3n y uso de credenciales para establecer conexi\u00f3n (servidor FTP, SMTP, IMAP).</li> <li>Mecanismos de reconexi\u00f3n o manejo de errores b\u00e1sicos si la conexi\u00f3n falla.</li> </ul> </li> <li>Manejo de ficheros y persistencia (LOG en FTP) \u2013 10 %<ul> <li>Descarga/lectura y subida/escritura de ficheros en el servidor FTP.</li> <li>Registro de la informaci\u00f3n en el archivo LOG.txt, respetando el formato indicado.</li> </ul> </li> <li>Registro de fecha y hora en las acciones realizadas \u2013 10 %<ul> <li>Uso correcto de objetos de fecha/hora (por ejemplo Date, LocalDateTime, etc.).</li> <li>Formato y contenido del registro del LOG (una nueva l\u00ednea por conexi\u00f3n con la fecha y hora).</li> </ul> </li> <li>Env\u00edo de correos con SMTP \u2013 15 %<ul> <li>Solicitud de todos los campos por consola (servidor SMTP, puerto, usuario, contrase\u00f1a, remitente, destinatario, asunto y cuerpo).</li> <li>Posibilidad de a\u00f1adir adjuntos en el correo si el usuario lo desea.</li> <li>Confirmaci\u00f3n clara de env\u00edo exitoso o mensaje de error.</li> </ul> </li> <li>Lectura de correos no le\u00eddos con IMAP \u2013 15 %<ul> <li>Solicitud de credenciales IMAP (servidor, puerto, usuario, contrase\u00f1a).</li> <li>Lectura y muestra de la informaci\u00f3n del correo (remitente, fecha, hora, asunto y cuerpo) \u00fanicamente para los correos no le\u00eddos.</li> <li>Control b\u00e1sico de posibles errores (problemas de conexi\u00f3n o credenciales).</li> </ul> </li> <li>Control de errores y validaci\u00f3n de datos \u2013 10 %<ul> <li>Manejo de excepciones (por ejemplo, manejo de IOException, MessagingException, etc.).</li> <li>Validaci\u00f3n de datos de entrada (campos vac\u00edos, valores de puertos inv\u00e1lidos, etc.).</li> </ul> </li> <li>Uso correcto de las librer\u00edas (Apache Commons Net y Jakarta Mail) \u2013 10 %<ul> <li>Inclusi\u00f3n de dependencias correctas (pom.xml, uso de Maven o Gradle si se desea).</li> <li>Implementaci\u00f3n eficaz de los m\u00e9todos de las librer\u00edas y clases correspondientes.</li> </ul> </li> <li>Estructura, claridad y documentaci\u00f3n del c\u00f3digo \u2013 10 %<ul> <li>Organizaci\u00f3n del c\u00f3digo (clases y m\u00e9todos con responsabilidades claras).</li> <li>Comentarios o documentaci\u00f3n m\u00ednima que facilite el mantenimiento y la comprensi\u00f3n.</li> <li>Orden y legibilidad del c\u00f3digo fuente.</li> </ul> </li> </ol>"},{"location":"pr4.1/#metodo-de-entrega","title":"M\u00e9todo de entrega","text":"<p>Comprime el proyecto junto con la documentaci\u00f3n en un archivo ZIP y s\u00fabelo a la plataforma Moodle Centros en el lugar dedicado a ello. El archivo ZIP deber\u00e1 tener el siguiente formato:</p> <p>Apellido1Apellido2_Nombre_PSP_UD4_P1.zip</p>"},{"location":"pr5.1/","title":"Pr\u00e1ctica 5.1 - T\u00e9cnicas de programaci\u00f3n seguras","text":""},{"location":"pr5.1/#desarrollo-de-la-practica","title":"Desarrollo de la pr\u00e1ctica","text":"<ol> <li> <p>Obt\u00e9n el hash de los contenidos de un fichero, el fichero se debe elegir del disco duro con la clase JFileChooser. El resumen se debe mostrar en hexadecimal. Utiliza los algoritmos SHA-256 y MD5 y comprueba los res\u00famenes generados.</p> </li> <li> <p>Programa una aplicaci\u00f3n Java que reciba como par\u00e1metros de entrada un fichero y una contrase\u00f1a, cifre el contenido utilizando AES, almacene el resultado con un nombre de fichero distinto y borre el fichero original. Programar tambi\u00e9n la aplicaci\u00f3n que realice la transformaci\u00f3n inversa.</p> </li> <li> <p>Crea un programa que genere una firma de un fichero. La firma consistir\u00e1 en el resultado de cifrar con la clave privada un hash SHA-2 de 256 bits. La firma se guardar\u00e1 en un fichero con el mismo nombre que el fichero original, a\u00f1adiendo .firma al final. Crea otro programa que verifique esta firma. Debe descifrar la firma con la clave p\u00fablica para obtener el hash, y compararla con el hash calculado sobre el fichero.</p> </li> <li> <p>Recupera un ejemplo de c\u00f3digo de la unidad 3 sobre Sockets con TCP y modifica los programas cliente y servidor para que utilicen sockets seguros.</p> </li> </ol>"},{"location":"pr5.1/#criterios-de-evaluacion","title":"Criterios de evaluaci\u00f3n","text":"<p>Esta pr\u00e1ctica eval\u00faa todos los criterios de evaluaci\u00f3n del RA5. Para su correcci\u00f3n se tendr\u00e1 en cuenta la siguiente ponderaci\u00f3n:</p> <ul> <li>Ejercicio 1: 20%.</li> <li>Ejercicio 2: 25%.</li> <li>Ejercicio 3: 35%.</li> <li>Ejercicio 4: 20%.</li> </ul>"},{"location":"pr5.1/#metodo-de-entrega","title":"M\u00e9todo de entrega","text":"<p>Comprime el proyecto junto con la documentaci\u00f3n en un archivo ZIP y s\u00fabelo a la plataforma Moodle Centros en el lugar dedicado a ello. El archivo ZIP deber\u00e1 tener el siguiente formato:</p> <p>Apellido1Apellido2_Nombre_PSP_UD5_P1.zip</p>"},{"location":"ud1/","title":"Unidad 1 - Programaci\u00f3n multiproceso","text":""},{"location":"ud1/#ide","title":"IDE","text":"<p>En el m\u00f3dulo de Programaci\u00f3n de servicios y procesos usaremos como entorno de desarrollo IntelliJ IDEA. Es un IDE desarrollado por JetBrains, dise\u00f1ado principalmente para el desarrollo en Java. Es conocido por sus potentes herramientas de asistencia al desarrollador, incluyendo an\u00e1lisis de c\u00f3digo, refactorizaci\u00f3n inteligente, autocompletado de c\u00f3digo y navegaci\u00f3n avanzada.</p> <p>Podemos descargarlo en su p\u00e1gina web, y gracias a la cuenta corporativa de @g.educaand.es tenemos licencia educativa por un a\u00f1o renovable.</p>"},{"location":"ud1/#ejercicios-de-repaso-de-programacion-en-java","title":"Ejercicios de repaso de programaci\u00f3n en Java","text":""},{"location":"ud1/#calculadora-basica","title":"Calculadora b\u00e1sica","text":"<p>Crea una aplicaci\u00f3n de consola que act\u00fae como una calculadora b\u00e1sica. El usuario puede seleccionar la operaci\u00f3n a realizar (suma, resta, multiplicaci\u00f3n y divisi\u00f3n) e ingresar dos n\u00fameros. El programa debe mostrar el resultado de la operaci\u00f3n. Como complicaci\u00f3n, la multiplicaci\u00f3n y la divisi\u00f3n no pueden realizarse con su operador aritm\u00e9tico propio.</p>"},{"location":"ud1/#gestion-de-estudiantes","title":"Gesti\u00f3n de estudiantes","text":"<p>Dise\u00f1a una aplicaci\u00f3n que permita gestionar una lista de estudiares. Cada estudiante tiene nombre, edad y calificaciones en varias asignaturas. El programa debe permitir agregar, eliminar y listar estudiantes, as\u00ed como calcular el promedio de calificaciones. De cada asignatura guardamos su nombre y calificaci\u00f3n. Utiliza clases y colecciones para resolver este ejercicio.</p>"},{"location":"ud1/#juego-del-ahorcado","title":"Juego del ahorcado","text":"<p>Implementa el cl\u00e1sico juego del ahorcado. El programa selecciona una palabra al azar de una lista predefinida y el usuario intenta adivinarla letra por letra.</p>"},{"location":"ud1/#verificador-de-palindromos","title":"Verificador de pal\u00edndromos","text":"<p>Desarrolla una aplicaci\u00f3n de consola que permita al usuario ingresar una palabra o frase y determine si es un pal\u00edndromo. Un pal\u00edndromo es una palabra o frase que se lee igual de izquierda a derecha que de derecha a izquierda, ignorando espacios, signos de puntuaci\u00f3n y diferencias entre may\u00fasculas y min\u00fasculas.</p>"},{"location":"ud1/#programas-procesos-y-servicios","title":"Programas, procesos y servicios","text":""},{"location":"ud1/#programa","title":"Programa","text":"<p>Un programa contiene un conjunto de instrucciones que se pueden ejecutar directamente en una m\u00e1quina. Se trata de un objeto est\u00e1tico, normalmente almacenado en un fichero binario en un medio de almacenamiento secundario.</p>"},{"location":"ud1/#proceso","title":"Proceso","text":"<p>Por su parte, un proceso corresponde a una instancia de un programa en ejecuci\u00f3n. Se trata de una entidad din\u00e1mica. La ejecuci\u00f3n de un programa comienza con la creaci\u00f3n y ejecuci\u00f3n de un proceso y utiliza los siguientes recursos del sistema:</p> <ul> <li>Memoria.</li> <li>Procesador o CPU.</li> <li>Dispositivos de E/S.</li> </ul> <p>Igualmente, cada proceso lleva asociado:</p> <ul> <li>Registros.</li> <li>Contador de programa.</li> <li> <p>Bloque de control de proceso.</p> </li> <li> <p>En Linux podemos usar el comando ps para obtener informaci\u00f3n sobre los procesos.</p> <ul> <li>Para mostrar m\u00e1s informaci\u00f3n podemos usar ps -f o ps -Af.</li> </ul> </li> </ul> <p></p> <ul> <li>En Windows podemos usar el comando tasklist o el administrador de tareas.</li> </ul> <p></p> <p>El n\u00famero de procesos que pueden convivir simult\u00e1neamente en un sistema es alto, por lo que supera ampliamente el n\u00famero de n\u00facleos de la CPU. El sistema operativo es el encargado de gestionar que los recursos a los que acceden cada procesos se repartan de forma ordenada, justa y eficiente.</p>"},{"location":"ud1/#servicio","title":"Servicio","text":"<p>Los servicios son un tipo particular de procesos que proporcionan determinados servicios (de ah\u00ed su nombre) a otros procesos. Se ejecutan en segundo plano (en background) y no son directamente usados por los usuarios. Adem\u00e1s se ejecutan continuamente y normalmente son iniciados por el propio sistema operativo en el arranque de este. Los servicios pueden proporcionar servicios a otros procesos en el mismo ordenador y tambi\u00e9n a otros procesos en otros ordenadores.</p> <p>Todos los sistemas operativos modernos diferencian claramente entre procesos y servicios. En la presente unidad trataremos los primeros. Igualmente, cada sistema operativo tiene su propia aplicaci\u00f3n de gesti\u00f3n de procesos.</p>"},{"location":"ud1/#planificacion-de-procesos","title":"Planificaci\u00f3n de procesos","text":"<p>Todos los sistemas actuales, salvo aquellos m\u00e1s sencillos (como algunos microcontroladores), son capaces de realizar multitarea o multiproceso.</p> <p>El planificador de procesos es el elemento del sistema operativo que se encarga de repartir los recursos del sistema entre los procesos que lo demandan. Los objetivos del planificador son los siguientes:</p> <ul> <li>Maximizar el rendimiento del sistema.</li> <li>Maximizar la equidad en el reparto de los recursos.</li> <li>Minimizar los tiempos de espera.</li> <li>Minimizar los tiempos de respuesta.</li> </ul> <p>Existen varios niveles de planificaci\u00f3n:</p> <ul> <li>Planificador a largo plazo o de trabajos: decide qu\u00e9 procesos son admitidos para su ejecuci\u00f3n.</li> <li>Planificador a corto plazo o de procesador: reparte el tiempo de procesador entre todos los procesos.</li> <li>Planificador a medio plazo: gestiona el paso de procesos de la memoria principal a la secundaria (suspensi\u00f3n) y viceversa (reanudaci\u00f3n).</li> </ul> <p>Seg\u00fan el n\u00famero de procesadores de un sistema podemos clasificarlos como:</p> <ul> <li>Sistemas monoprocesadores: la ejecuci\u00f3n concurrente de varios procesos en un sistema monoprocesador se conoce con el nombre de multiprogramaci\u00f3n.</li> <li>Sistemas multiprocesadores: disponen de m\u00e1s de un procesador. A su vez, pueden ser de dos tipos:<ul> <li>Sistema fuertemente acoplado: la memoria y los dispositivos de entrada/salida son compartidos entre todos los procesadores.</li> <li>Sistema d\u00e9bilmente acoplado: cada procesador posee su propia memoria y dispositivos de entrada/salida.</li> </ul> </li> </ul>"},{"location":"ud1/#multitarea","title":"Multitarea","text":"<p>La multitarea (o multitasking) consiste en la ejecuci\u00f3n simult\u00e1nea de m\u00e1s de un proceso en un procesador a lo largo del tiempo. Para que los procesos no tengan que esperar a que finalicen todos los dem\u00e1s, los sistemas aprovechan los recursos al m\u00e1ximo para crear la ilusi\u00f3n de que varios procesos se ejecutan de forma simult\u00e1nea.</p> <p></p>"},{"location":"ud1/#ejecucion-de-procesos-en-un-sistema-multiprocesador","title":"Ejecuci\u00f3n de procesos en un sistema multiprocesador","text":""},{"location":"ud1/#ejecucion-de-procesos-con-multitarea-con-operaciones-de-es","title":"Ejecuci\u00f3n de procesos con multitarea, con operaciones de E/S","text":""},{"location":"ud1/#hilos-y-procesos","title":"Hilos y procesos","text":"<p>Los hilos o hebras (threads en ingl\u00e9s) son las unidades m\u00e1s peque\u00f1as de procesamiento que pueden ejecutar tareas de manera concurrente dentro de un proceso. Un proceso en ejecuci\u00f3n tiene inicialmente un hilo, pero se pueden crear m\u00e1s de manera sencilla y r\u00e1pida. La ejecuci\u00f3n de un proceso finaliza cuando termina la ejecuci\u00f3n de todos sus hilos.</p> Procesos Hilos Constan de uno o m\u00e1s hilos Un hilo siempre existe dentro de un proceso Son independientes unos de otros Comparten los recursos del proceso de forma directa Son gestionados por el SO Son gestionados por el proceso Se comunican a trav\u00e9s del SO La comunicaci\u00f3n controla el proceso"},{"location":"ud1/#programacion-concurrente","title":"Programaci\u00f3n concurrente","text":"<p>Se denominan procesos concurrentes a los que se ejecutan simult\u00e1neamente durante un intervalo de tiempo, ya sea de forma real (en sistemas multiprocesadores) o simulada (en sistemas monoprocesadores o en un mismo procesador de un sistema multiprocesador).</p> <p>Por su parte, hablamos de programaci\u00f3n concurrente cuando se ejecutan varios procesos concurrentes en un sistema, y tambi\u00e9n para hacer referencia a las t\u00e9cnicas que permiten desarrollar programas que utilizan varios procesos concurrentes que funcionan de forma conjunta y coordinada, para realizar una tarea.</p>"},{"location":"ud1/#ventajas","title":"Ventajas","text":"<ul> <li>Permite incrementar el rendimiento del sistema, porque los procesadores pasan a ejecutar otros procesos cuando el proceso que ejecutan est\u00e1 desocupado o a la espera de que termine una operaci\u00f3n de E/S.</li> <li>Hace posible un menor tiempo de respuesta, ya que el tiempo de procesador se distribuye entre todos los procesos en ejecuci\u00f3n.</li> </ul>"},{"location":"ud1/#inconvenientes","title":"Inconvenientes","text":"<ul> <li>Dificulta la implementaci\u00f3n de mecanismos adecuados de sincronizaci\u00f3n y comunicaci\u00f3n entre procesos.</li> <li>Es posible que la sobrecarga que suponen anule la mejora en el rendimiento que proporciona la concurrencia.</li> <li>En sistemas distribuidos, la red podr\u00eda convertirse en un cuello de botella si no tiene la suficiente capacidad para el tr\u00e1fico que genera el intercambio de mensajes entre procesos.</li> </ul>"},{"location":"ud1/#programacion-paralela-y-distribuida","title":"Programaci\u00f3n paralela y distribuida","text":"<p>La programaci\u00f3n paralela consiste en la ejecuci\u00f3n de varios procesos concurrentes en un sistema multiprocesador. Estos procesos se pueden ejecutar con paralelismo real.</p> <p>La programaci\u00f3n distribuida consiste en la ejecuci\u00f3n de varios procesos concurrentes en un sistema distribuido. Se usa tambi\u00e9n este t\u00e9rmino para hacer referencia al desarrollo de programas que utilizan varios procesos concurrentes que pueden ejecutarse en distintos procesadores de un sistema distribuido, y a las t\u00e9cnicas que lo hacen posible.</p> <p>En un sistema distribuido no hay memoria compartida ni red de conexi\u00f3n espec\u00edfica entre los distintos ordenadores. La comunicaci\u00f3n entre procesos se realiza mediante mensajes a trav\u00e9s de la red de comunicaciones que conecta los distintos ordenadores, para lo que se suele utilizar los protocolos de red UDP o TCP.</p>"},{"location":"ud1/#estados-de-un-proceso","title":"Estados de un proceso","text":"<p>Como hemos comentado al principio, los procesos son programas en ejecuci\u00f3n, que requieren recursos como el tiempo de la CPU, memoria y acceso a dispositivos de entrada/salida. </p> <p>Cada proceso puede estar en uno o varios estados durante su ciclo de vida. Estos estados definen qu\u00e9 est\u00e1 haciendo el proceso en un momento dado y permiten al sistema operativo gestionar m\u00faltiples procesos de manera eficiente.</p> <p>Los estados b\u00e1sicos en los que puede estar un proceso son los siguientes:</p> <ul> <li>Nuevo (new): Un proceso reci\u00e9n creado se encuentra en este estado. Se han asignado los recursos iniciales, pero a\u00fan no ha comenzado a ejecutarse. El proceso est\u00e1 esperando ser admitido en la cola de procesos listos.</li> <li>Listo (ready): El proceso ha sido cargado en la memoria principal y est\u00e1 preparado para ser ejecutado. Se en cuentra en una cola de procesos listos a la espera de que el planificador del sistema operativo (scheduler) le asigne tiempo de CPU. En este estado, el proceso no est\u00e1 ejecut\u00e1ndose, pero podr\u00eda hacerlo tan pronto como el sistema operativo se lo permita.</li> <li>En ejecuci\u00f3n (running): En este estado, el proceso est\u00e1 siendo ejecutado en la CPU. Solo un proceso puede estar en este estado por n\u00facleo de CPU por unidad de tiempo, aunque en sistemas con m\u00faltiples n\u00facleos es posible que varios procesos est\u00e9n en ejecuci\u00f3n simult\u00e1neamente en diferentes n\u00facleos.</li> <li>Bloqueado (blocked) o Espera (waiting): El proceso se encuentra en este estado cuando est\u00e1 esperando que ocurra un evento espec\u00edfico, como la finalizaci\u00f3n de una operaci\u00f3n de entrada/salida o la disponibilidad de un recurso. Mientras el proceso est\u00e1 bloqueado, no puede continuar con su ejecuci\u00f3n y debe esperar a que el evento suceda. Una vez que se cumple la condici\u00f3n de espera, el proceso pasa al estado de Listo.</li> <li>Terminado (terminated) o Finalizado (exit): Cuando un proceso ha completado su ejecuci\u00f3n o ha sido terminado por el sistema (ya sea de forma normal o por alg\u00fan error), entra en este estado. Todos los recursos asociados con el proceso son liberados por el sistema operativo, y su estado final queda registrado para prop\u00f3sitos de control y depuraci\u00f3n.</li> </ul> <p></p>"},{"location":"ud1/#comunicacion-entre-procesos","title":"Comunicaci\u00f3n entre procesos","text":"<p>Los procesos poseen dos maneras de comunicarse con otros procesos:</p> <ul> <li>Intercambio de mensajes: Es la forma habitual cuando los procesos se encuentran en m\u00e1quinas distintas. El intercambio de informaci\u00f3n se realiza a trav\u00e9s de un protocolo establecido previamente.</li> <li>Recursos (memoria) compartidos: Solo se puede usar cuando los dos procesos se encuentran en la misma m\u00e1quina y permite la sincronizaci\u00f3n de los procesos en funci\u00f3n del valor o estado de un recurso compartido.</li> </ul> <p>La comunicaci\u00f3n entre procesos se denomina IPC (Inter-Process Communication) y existen diversas alternativas para llevarla a cabo:</p> <ul> <li>Utilizaci\u00f3n de sockets.</li> <li>Utilizaci\u00f3n de flujos de entrada y salida.</li> <li>RPC (Remote Process Call). Llamada a procedimiento remoto.</li> <li>Mediante el uso de sistemas de persistencia.</li> <li>Mediante el uso de servicios proporcionados a trav\u00e9s de Internet.</li> </ul>"},{"location":"ud1/#sincronizacion-entre-procesos","title":"Sincronizaci\u00f3n entre procesos","text":"<p>El planificador del sistema operativo es el encargado de decidir en qu\u00e9 momento tiene acceso a los recursos un proceso, pero a nivel general, la decisi\u00f3n de crear y lanzar un proceso es humana, y es expresada a trav\u00e9s de un algoritmo.</p> <p>Para gestionar el flujo de trabajo entre procesos se necesita disponer de los siguientes mecanismos:</p> <ul> <li>Ejecuci\u00f3n: Un mecanismo para ejecutar procesos desde un proceso.</li> <li>Espera: Un mecanismo para bloquear la ejecuci\u00f3n de un proceso a la espera de que otro proceso termine.</li> <li>Generaci\u00f3n de c\u00f3digo de terminaci\u00f3n: Un mecanismo de comunicaci\u00f3n que permita indicar a un proceso c\u00f3mo ha terminado la ejecuci\u00f3n mediante un c\u00f3digo.</li> <li>Obtenci\u00f3n de c\u00f3digo de terminaci\u00f3n: Un mecanismo que permita a un proceso obtener el c\u00f3digo de terminaci\u00f3n de otro proceso.</li> </ul>"},{"location":"ud1/#programacion-de-aplicaciones-multiproceso-en-java","title":"Programaci\u00f3n de aplicaciones multiproceso en Java","text":"<p>En Java, la creaci\u00f3n de un proceso puede realizarse de dos maneras diferentes:</p> <ul> <li>Utilizando la clase java.lang.Runtime.</li> <li>Utilizando la clase java.lang.ProcessBuilder.</li> </ul> <p>La clase java.lang.Runtime se usa principalmente para interactuar con el JRE de Java. Esta clase proporciona m\u00e9todos para lanzar procesos, llamar al recolector de basura, saber la cantidad de memoria disponible y libre, etc.</p> <p>Toda aplicaci\u00f3n Java tiene una \u00fanica instancia de la clase Runtime, que permite que la propia aplicaci\u00f3n interact\u00fae con su entorno de ejecuci\u00f3n a trav\u00e9s del m\u00e9todo est\u00e1tico getRuntime().</p> <p>Este m\u00e9todo proporciona un canal de comunicaci\u00f3n entre la aplicaci\u00f3n y su entorno, posibilidanto la interacci\u00f3n del sistema operativo a trav\u00e9s del m\u00e9todo exec.</p> <p>https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Runtime.html</p> <p>En el paquete java.lang tenemos dos clases para la gesti\u00f3n de procesos:</p> <ul> <li>java.lang.ProcessBuilder:<ul> <li>https://docs.oracle.com/en%2Fjava%2Fjavase%2F21%2Fdocs%2Fapi%2F%2F/java.base/java/lang/ProcessBuilder.html</li> </ul> </li> <li>java.lang.Process<ul> <li>https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Process.html</li> </ul> </li> </ul> <p>Las instancias de ProcessBuilder gestionan los atributos de los procesos, mientras que las instancias de Process controla la ejecuci\u00f3n de esos mismos procesos cuando se ejecutan.</p> <p>La clase Process es abstracta y, por lo tanto, no se pueden crear objetos de ella, sino de subclases suyas, que. de hecho, implementan procesos nativos, es decir, procesos de plataformas espec\u00edficas que se ejecutan en un sistema operativo particular para un tipo de procesador particular.</p> <p>La clase Process tiene m\u00e9todos para lanzar un proceso, obtener informaci\u00f3n acerca de su estado y controlar su ejecuci\u00f3n.</p>"},{"location":"ud1/#metodos-de-la-clase-javalangprocess","title":"M\u00e9todos de la clase java.lang.Process","text":"M\u00e9todos Descripci\u00f3n destroy() Destruye el proceso sobre el que se ejecuta exitValue() Devuelve el valor de retorno del proceso cuando este finaliza. Sirve para controlar el estado de la ejecuci\u00f3n getErrorStream() Proporciona un InputStream conectado a la salida de error del proceso. getInputStream() Proporciona un InputStream conectado a la salida normal del proceso. getOutputStream() Proporciona un OutputStream conectado a la entrada normal del proceso. isAlive() Determina si el proceso est\u00e1 o no en ejecuci\u00f3n. waitFor() Detiene la ejecuci\u00f3n del programa que lanza el proceso a la espera de que este \u00faltimo termine. <p>Con ProcessBuilder se puede configurar previamente el entorno de ejecuci\u00f3n de los procesos que crea y, en particular, redirigir su entrada y salida.</p> <p>El constructor de ProcessBuilder admite par\u00e1metros que ser\u00e1n entregados al proceso que se crea:</p> <pre><code>ProcessBuilder(List&lt;String&gt;command)\nProcessBuilder(String... command)\n</code></pre> <p>La ejecuci\u00f3n del proceso se realiza a partir de la invocaci\u00f3n al m\u00e9todo start():</p> <pre><code>// Ejemplo en Windows\nProcessBuilder pb = new ProcessBuilder(\"cmd\", \"/C\", \"dir\");\n// Ejemplo en Linux\nProcessBuilder pb = new ProcessBuilder(\"/bin/bash\", \"-c\", \"ls\");\n// Ejemplo en MacOS\nProcessBuilder pb = new ProcessBuilder(\"sh\", \"-c\", \"ls\");\n\nProcess p = pb.start();\n</code></pre>"},{"location":"ud1/#metodos-de-la-clase-javalangprocessbuilder","title":"M\u00e9todos de la clase java.lang.ProcessBuilder","text":"M\u00e9todos Descripci\u00f3n start() Inicia un nuevo proceso usando los atributos especificados. command() Permite obtener o asignar el programa y los argumentos de la instancia de ProcessBuilder. directory() Permite obtener o asignar el directorio de trabajo del proceso. environment() Proporciona informaci\u00f3n sobre el entorno de ejecuci\u00f3n del proceso. redirectError() Permite determinar el destino de la salida de errores. redirectInput() Permite determinar el origen de la entrada est\u00e1ndar. redirectOutput() Permite determinar el destino de la salida est\u00e1ndar."},{"location":"ud1/#gestion-de-la-es-de-un-proceso","title":"Gesti\u00f3n de la E/S de un proceso","text":"<p>Un subproceso no tiene terminal o consola en el que poder mostrar su informaci\u00f3n. Los procesos lanzados con el m\u00e9todo start() redireccionan los streams de E/S est\u00e1ndar (stdin, stdout, stderr) al proceso padre. Si se necesita se puede acceder a ellos a trav\u00e9s de los streams obtenidos con los m\u00e9todos definidos en la clase Process como getInputStream(), getOutputStream() y getErrorStream(). Esta es la forma de enviar y recibir informaci\u00f3n desde los subprocesos.</p> <p></p>"},{"location":"ud1/#getinputstream","title":"getInputStream()","text":"<p>Este m\u00e9todo se utiliza para leer el stream de salida del proceso, es decir, para leer lo que el comando ejecutado (proceso hijo) ha enviado a la consola.</p> <p><pre><code>Process p = pbuilder.start();\nBufferedReader processOutput = new BufferedReader(\n    new InputStreamReader(p.getInputStream()));\n\nString linea;\nwhile((linea = processOutput.readLine()) != null)\n{\n    System.out.println(\"&gt; \" + linea);\n}\n\nprocessOutput.close();\n</code></pre> Este c\u00f3digo ejecuta un proceso externo y lee su salida est\u00e1ndar l\u00ednea a l\u00ednea, mostr\u00e1ndola en la termina.</p> <p>Primero iniciamos un nuevo proceso usando pbuilder.start(). El m\u00e9doto start() ejecuta el proceso configurado en pbuilder y devuelve un objeto Process que representa el proceso en ejecuci\u00f3n.</p> <p>A continuaci\u00f3n creamos un InputStreamReader que toma el flujo de entrada del proceso (p.getInputStream()), que en realidad corresponde a la salida est\u00e1ndar (stdout) del proceso. Este InputStreamReader se envuelve de un BufferedReader para facilitar la lectura eficiente de texto, especialmente l\u00ednea a l\u00ednea.</p> <p>Finalmente, el bucle while utiliza processOutput.readLine() para leer cada l\u00ednea de la salida del proceso. Este m\u00e9todo devuelve null cuando no hay m\u00e1s l\u00edneas por leer. Dentro del bucle cada l\u00ednea le\u00edda se imprime en consola, precedida por \"&gt; \". Por \u00faltimo, despu\u00e9s de leer todas las l\u00edneas se cierra el BufferedReader para liberar los recursos asociados.</p>"},{"location":"ud1/#geterrorstream","title":"getErrorStream()","text":"<p>Podemos obtener la salida de error (stderr) que genera el proceso hijo para procesarla desde el padre.</p> <ul> <li>Si la salida de error ha sido previamente redirigida usando el m\u00e9todo ProcessBuilder.redirectErrorStream(true) la salida de error y la salida est\u00e1ndar llegar\u00e1n juntas con getInputStream() y no es necesario hacer un tratamiento adicional.</li> <li>Si por el contrario queremos hacer un tratamiento diferenciado de los dos tipos de salida, podemos usar un esquema similar al usado anteriormente, con la salvedad de que ahora en lugar de llamar a getInputStream() lo hacemos con getErrorStream().</li> </ul>"},{"location":"ud1/#getoutputstream","title":"getOutputStream()","text":"<p>Este m\u00e9todo se usa para enviar informaci\u00f3n desde el proceso padre al proceso hijo. De la misma forma que con las entradas que llegan desde el proceso hijo, podemos enviar la informaci\u00f3n usando directamente el OutputStream del proceso, pero lo haremos con un Decorator.</p> <p>En este caso, el wrapper de mayor nivel para usar un OutputStream es la clase PrintWriter que nos ofrece m\u00e9todos similares a los de System.out.printxxxxx para gestionar el flujo de comunicaci\u00f3n con el proceso hijo.</p> <pre><code>PrintWriter toProcess = new PrintWriter(\n    new BufferedWriter(\n        new OutputStreamWriter(\n            p.getOutputStream(), \"UTF-8\")), true);\n\ntoProcess.println(\"Enviar al hijo\");\n</code></pre>"},{"location":"ud1/#ejercicio-resuelto-de-comunicacion-entre-procesos","title":"Ejercicio resuelto de comunicaci\u00f3n entre procesos","text":"<p>Implementa una aplicaci\u00f3n, llamada Frecuencia, que dado un texto recibido a trav\u00e9s de su entrada est\u00e1ndar obtenga la frecuencia absoluta de cada una de las vocales, es decir, la cantidad de veces que aparece cada vocal. En el caso de que una de las vocales no aparezca la frecuencia ser\u00e1 0. Por ejemplo: para la palabra \u201cestupendo\u201d el resultado debe ser 0 2 0 1 1.</p> <p>Implementa una aplicaci\u00f3n que introduzca por teclado una cadena y ejecute el programa anterior para visualizar la salida del n\u00famero de vocales de dicha cadena. La aplicaci\u00f3n se llamar\u00e1 Lanzador.</p>"},{"location":"ud1/#frecuenciajava","title":"Frecuencia.java","text":"<pre><code>import java.util.Scanner;\n\npublic class Frecuencia {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        scanner.close();\n\n        int countA = 0;\n        int countE = 0;\n        int countI = 0;\n        int countO = 0;\n        int countU = 0;\n\n        input = input.toLowerCase();\n\n        for (char c : input.toCharArray()) {\n            switch (c) {\n                case 'a':\n                    countA++;\n                    break;\n                case 'e':\n                    countE++;\n                    break;\n                case 'i':\n                    countI++;\n                    break;\n                case 'o':\n                    countO++;\n                    break;\n                case 'u':\n                    countU++;\n                    break;\n                default:\n                    // No es una vocal\n            }\n        }\n\n        System.out.println(countA + \" \" + countE + \" \" + countI + \" \" + countO + \" \" + countU);\n    }\n}\n</code></pre>"},{"location":"ud1/#lanzadorjava","title":"Lanzador.java","text":"<pre><code>import java.io.*;\n\npublic class Lanzador {\n    public static void main(String[] args) {\n        try {\n            // Leer cadena desde el teclado\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.print(\"Introduce una cadena: \");\n            String inputString = reader.readLine();\n\n            // Obtener el classpath actual\n            String classpath = System.getProperty(\"java.class.path\");\n\n            // Crear el proceso para ejecutar Frecuencia\n            ProcessBuilder pb = new ProcessBuilder (\"java\", \"-cp\", classpath, \"Frecuencia\");\n            Process process = pb.start();\n\n            // Enviar la cadena al proceso Frecuencia\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));\n            writer.write(inputString);\n            writer.newLine(); // Importante para indicar el fin de la entrada\n            writer.flush();\n            writer.close();\n\n            // Leer la salida del proceso Frecuencia\n            BufferedReader processOutputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line = processOutputReader.readLine();\n            System.out.println(\"Frecuencia de vocales: \" + line);\n\n\n            process.waitFor(); // Esperar a que el proceso termine\n            processOutputReader.close();\n\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>"},{"location":"ud1/#redireccion-de-la-es","title":"Redirecci\u00f3n de la E/S","text":"<p>En un sistema real probablemente necesitemos guardar los resultados de un proceso en un archivo de log o de errores para su posterior an\u00e1lisis.</p> <p>Para redigirir la E/S lo haremos mientras preparamos el proceso para ser ejecutado, de forma que cuando se lancen sus stream de E/S salida se modifiquen. Por eso, en esta ocasi\u00f3n, los m\u00e9todos que nos permiten redireccionar la E/S de los procesos son m\u00e9todos de la clase ProcessBuilder.</p> <p>Los m\u00e9todos a utilizar ser\u00edan redirectOutput(File), redirectInput(File) y redirectError(File). Para hacer las redirecciones tambi\u00e9n podemos utilizar la clase ProcessBuilder.Redirect como par\u00e1metro para los m\u00e9todos anteriores, utilizando uno de los siguientes valores.</p> Valor Significado Redirect.DISCARD La informaci\u00f3n se descarta. Redirect.to(File) La informaci\u00f3n se guardar\u00e1 en el fichero indicado. Si existe, se vac\u00eda. Redirect.from(File) La informaci\u00f3n se leer\u00e1 del fichero indicado. Redirect.appendTo(File) La informaci\u00f3n se a\u00f1adir\u00e1 en el fichero indicado. Si existe, no se vac\u00eda."},{"location":"ud1/#ejercicio-resuelto-de-redireccion-de-la-salida-de-un-proceso-a-un-fichero-de-texto","title":"Ejercicio resuelto de redirecci\u00f3n de la salida de un proceso a un fichero de texto","text":"<p>Crea una aplicaci\u00f3n Java que cree dos procesos. El primero de ellos deber\u00e1 listar el contenido del directorio en el que se encuentra, mientras que el segundo deber\u00e1 mostrar la informaci\u00f3n del sistema. Almacena en dos ficheros distintos la salida de cada uno de los procesos. Finalmente sincronizarlos.</p>"},{"location":"ud1/#multiprocessappjava","title":"MultiProcessApp.java","text":"<pre><code>import java.io.*;\n\npublic class MultiProcessApp {\n\n    public static void main(String[] args) {\n        try {\n            // Crear el primer proceso que lista el contenido del directorio actual (equivalente a 'dir' en Windows)\n            ProcessBuilder processBuilder1 = new ProcessBuilder(\"sh\", \"-c\", \"ls\");\n            processBuilder1.redirectOutput(new File(\"output_ls.txt\"));  // Redirigir la salida a un archivo\n            Process process1 = processBuilder1.start();\n\n            // Crear el segundo proceso que muestra la informaci\u00f3n del sistema (equivalente a 'systeminfo' en Windows)\n            ProcessBuilder processBuilder2 = new ProcessBuilder(\"sh\", \"-c\", \"uname -a\");\n            processBuilder2.redirectOutput(new File(\"output_uname.txt\"));  // Redirigir la salida a un archivo\n            Process process2 = processBuilder2.start();\n\n            // Sincronizar ambos procesos\n            int exitCode1 = process1.waitFor();\n            int exitCode2 = process2.waitFor();\n\n            System.out.println(\"Proceso 1 terminado con c\u00f3digo: \" + exitCode1);\n            System.out.println(\"Proceso 2 terminado con c\u00f3digo: \" + exitCode2);\n\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>"},{"location":"ud2/","title":"Unidad 2 - Programaci\u00f3n multihilo","text":""},{"location":"ud2/#el-concepto-de-hilo-en-programacion","title":"El concepto de hilo en programaci\u00f3n","text":"<p>En programaci\u00f3n, un hilo (o thread en ingl\u00e9s) es la unidad m\u00e1s peque\u00f1a de procesamiento que puede ser gestionada de manera independiente por un sistema operativo. Los hilos permiten que un programa realice m\u00faltiples tareas de forma concurrente dentro del mismo proceso.</p>"},{"location":"ud2/#caracteristicas-principales-de-los-hilos","title":"Caracter\u00edsticas principales de los hilos","text":"<ul> <li>Compartici\u00f3n de recursos:<ul> <li>Todos los hilos de un mismo proceso comparten el mismo espacio de direcciones de memoria, lo que facilita la comunicaci\u00f3n y el intercambio de datos entre ellos.</li> <li>Comparten recursos como archivos abiertos, variables globales y otros recursos del proceso padre.</li> </ul> </li> <li>Ejecuci\u00f3n concurrente:<ul> <li>Los hilos permiten que diferentes partes de un programa se ejecuten al mismo tiempo, aprovechando mejor los recursos del sistema, especialmente en sistemas con m\u00faltiples n\u00facleos de procesamiento.</li> <li>Esto puede mejorar el rendimiento y la capacidad de respuesta de las aplicaciones, especialmente en operaciones que son independientes entre s\u00ed.</li> </ul> </li> <li>Ligereza:<ul> <li>Los hilos son m\u00e1s ligeros en t\u00e9rminos de recursos que los procesos completos, ya que comparten el mismo espacio de memoria y otros recursos.</li> <li>Crear y gestionar hilos suele ser m\u00e1s r\u00e1pido y consume menos memoria que manejar m\u00faltiples procesos.</li> </ul> </li> <li>Sincronizaci\u00f3n:<ul> <li>Dado que los hilos comparten el mismo espacio de memoria, es fundamental gestionar adecuadamente el acceso a los recursos compartidos para evitar condiciones de carrera, bloqueos y otros problemas de concurrencia.</li> <li>Se utilizan mecanismos como mutexes, sem\u00e1foros y monitores para sincronizar el acceso a recursos compartidos.</li> </ul> </li> </ul>"},{"location":"ud2/#ejemplos-de-uso-de-hilos","title":"Ejemplos de uso de hilos","text":"<ul> <li>Interfaces de usuario: Mantener la interfaz receptiva mientras se realizan operaciones de fondo, como descargas o c\u00e1lculos intensivos.</li> <li>Servidores web: Manejar m\u00faltiples solicitudes de clientes simult\u00e1neamente, asignando un hilo a cada conexi\u00f3n.</li> <li>Aplicaciones de tiempo real: Procesar datos en tiempo real, como en aplicaciones de audio o video, donde es crucial manejar m\u00faltiples flujos de datos de manera simult\u00e1nea.</li> </ul>"},{"location":"ud2/#diferencia-entre-procesos-e-hilos","title":"Diferencia entre procesos e hilos","text":"<ul> <li>Proceso: Es una instancia de un programa en ejecuci\u00f3n, con su propio espacio de direcciones de memoria y recursos independientes.</li> <li>Hilo: Es una unidad de ejecuci\u00f3n dentro de un proceso que comparte el mismo espacio de memoria y recursos con otros hilos del mismo proceso.</li> </ul>"},{"location":"ud2/#ventajas-de-usar-hilos","title":"Ventajas de usar hilos","text":"<ul> <li>Mejor utilizaci\u00f3n de recursos: Aprovechan mejor los sistemas con m\u00faltiples n\u00facleos de procesamiento.</li> <li>Mejor rendimiento: Pueden reducir el tiempo de ejecuci\u00f3n total al realizar tareas en paralelo.</li> <li>Mayor responsividad: Permiten que las aplicaciones mantengan una interfaz de usuario fluida mientras realizan tareas de fondo.</li> </ul>"},{"location":"ud2/#desafios-al-usar-hilos","title":"Desaf\u00edos al usar hilos","text":"<ul> <li>Complejidad de programaci\u00f3n: La programaci\u00f3n concurrente puede ser m\u00e1s complicada y propensa a errores.</li> <li>Problemas de sincronizaci\u00f3n: Necesidad de gestionar adecuadamente el acceso a recursos compartidos para evitar conflictos.</li> <li>Depuraci\u00f3n dif\u00edcil: Los errores relacionados con la concurrencia pueden ser dif\u00edciles de reproducir y solucionar.</li> </ul>"},{"location":"ud2/#el-problema-de-la-seccion-critica","title":"El problema de la secci\u00f3n cr\u00edtica","text":"<p>El problema de la secci\u00f3n cr\u00edtica es un concepto fundamental en la programaci\u00f3n concurrente y multihilo. Se refiere a la dificultad de gestionar el acceso a recursos compartidos por m\u00faltiples hilos de ejecuci\u00f3n de manera segura y eficiente.</p>"},{"location":"ud2/#definicion-del-problema-de-la-seccion-critica","title":"Definici\u00f3n del problema de la secci\u00f3n cr\u00edtica","text":"<p>Una secci\u00f3n cr\u00edtica es una parte del c\u00f3digo de un programa donde se accede o se modifica un recurso compartido, como una variable global, una estructura de datos, un archivo o cualquier otro recurso que pueda ser utilizado por m\u00faltiples hilos simult\u00e1neamente. El problema surge cuando varios hilos intentan entrar en su secci\u00f3n cr\u00edtica al mismo tiempo, lo que puede llevar a condiciones de carrera, inconsistencias de datos y comportamientos impredecibles.</p>"},{"location":"ud2/#relacion-con-los-hilos","title":"Relaci\u00f3n con los hilos","text":"<p>En un entorno multihilo, m\u00faltiples hilos pueden ejecutarse de manera concurrente dentro del mismo proceso y, por lo tanto, pueden acceder a los mismos recursos compartidos. Sin una adecuada sincronizaci\u00f3n, si dos o m\u00e1s hilos acceden y modifican un recurso compartido simult\u00e1neamente, pueden producirse resultados incorrectos. Este escenario es precisamente el n\u00facleo del problema de la secci\u00f3n cr\u00edtica.</p>"},{"location":"ud2/#ejemplo-de-condicion-de-carrera","title":"Ejemplo de condici\u00f3n de carrera","text":"<p>Consideremos dos hilos que intentan incrementar una variable compartida contador:</p> <pre><code>// Supongamos que contador est\u00e1 inicializado en 0\ncontador = contador + 1;\n</code></pre> <p>Si ambos hilos leen el valor de contador al mismo tiempo (digamos, 0), ambos incrementan a 1 y lo escriben de vuelta. En lugar de que contador sea 2, permanece en 1, lo que demuestra una condici\u00f3n de carrera.</p>"},{"location":"ud2/#soluciones-al-problema-de-la-seccion-critica","title":"Soluciones al problema de la secci\u00f3n cr\u00edtica","text":"<p>Para resolver el problema de la secci\u00f3n cr\u00edtica, es necesario garantizar que solo un hilo pueda acceder a la secci\u00f3n cr\u00edtica en un momento dado. Existen varios mecanismos y t\u00e9cnicas para lograr esta exclusi\u00f3n mutua:</p> <ol> <li> <p>Locks (bloqueos) o Mutexs (exclusi\u00f3n mutua):</p> <ul> <li>Mutex: Es un objeto de sincronizaci\u00f3n que permite que solo un hilo acceda a la secci\u00f3n cr\u00edtica. Un hilo adquiere el mutex antes de entrar en la secci\u00f3n cr\u00edtica y lo libera al salir.</li> <li>Ejemplo en pseudoc\u00f3digo:</li> </ul> <pre><code>mutex.lock()\n// Secci\u00f3n cr\u00edtica\ncontador = contador + 1\nmutex.unlock()\n</code></pre> </li> <li> <p>Sem\u00e1foros:</p> <ul> <li>Un sem\u00e1foro es una variable que controla el acceso a uno o m\u00e1s recursos. Un sem\u00e1foro binario funciona de manera similar a un mutex, mientras que uno de conteo puede permitir que m\u00faltiples hilos accedan simult\u00e1neamente hasta un l\u00edmite establecido.</li> <li>Ejemplo en pseudoc\u00f3digo:</li> </ul> <pre><code>semaphore.wait()\n// Secci\u00f3n cr\u00edtica\ncontador = contador + 1\nsemaphore.signal()\n</code></pre> </li> <li> <p>Monitores:</p> <ul> <li>Es una abstracci\u00f3n de alto nivel que combina mutexes y variables de condici\u00f3n para gestionar el acceso a recursos compartidos de manera m\u00e1s estructurada.</li> <li>Muchos lenguajes de programaci\u00f3n modernos, como Java, proporcionan soporte integrado para monitores.</li> </ul> </li> <li> <p>Variables at\u00f3micas:</p> <ul> <li>Operaciones at\u00f3micas permiten realizar ciertas operaciones de manera indivisible, evitando as\u00ed las condiciones de carrera sin necesidad de bloqueos expl\u00edcitos.</li> <li>Ejemplo en Java:</li> </ul> <pre><code>import java.util.concurrent.atomic.AtomicInteger;   \npublic class EjemploAtomico {\n    public static void main(String[] args) {\n        // Inicializaci\u00f3n de la variable at\u00f3mica con valor 0\n        AtomicInteger contador = new AtomicInteger(0);\n\n        // Incrementar el contador de forma at\u00f3mica\n        contador.getAndIncrement(); // Alternativamente, puedes usar contador.incrementAndGet()\n\n        // Imprimir el valor actual del contador\n        System.out.println(\"Valor del contador: \" + contador.get());\n    }\n}\n</code></pre> </li> <li> <p>Secciones cr\u00edticas y bloques synchronized:</p> <ul> <li>Algunos lenguajes proporcionan construcciones espec\u00edficas para definir regiones cr\u00edticas. Por ejemplo, en Java, la palabra clave synchronized puede usarse para sincronizar m\u00e9todos o bloques de c\u00f3digo.</li> </ul> </li> </ol> <p>Adem\u00e1s, hay que tener en cuenta una serie de consideraciones:</p> <ul> <li>Evitar deadlocks (bloqueos mutuos): Al implementar mecanismos de sincronizaci\u00f3n, es crucial dise\u00f1ar el sistema de manera que no se produzcan bloqueos donde dos o m\u00e1s hilos esperan indefinidamente por recursos que nunca ser\u00e1n liberados.</li> <li>Maximizar la concurrencia: Aunque la exclusi\u00f3n mutua es necesaria para proteger recursos compartidos, un uso excesivo de bloqueos puede reducir la concurrencia y afectar el rendimiento. Es importante equilibrar la seguridad y la eficiencia.</li> <li>Condiciones de carrera y visibilidad: Adem\u00e1s de la exclusi\u00f3n mutua, es esencial asegurar que los cambios realizados por un hilo sean visibles para otros hilos, lo cual se logra mediante la sincronizaci\u00f3n adecuada y el uso de variables vol\u00e1tiles o de memoria compartida correctamente gestionada.</li> </ul>"},{"location":"ud2/#programacion-de-hilos-en-java","title":"Programaci\u00f3n de hilos en Java","text":"<p>La ejecuci\u00f3n de un proceso comienza con un \u00fanico hilo, pero se pueden crear m\u00e1s sobre la marcha. Los distintos hilos de un mismo proceso comparten:</p> <ul> <li>El espacio de memoria asignado al proceso.</li> <li>La informaci\u00f3n de acceso a ficheros. Estos se utilizan no solo para almacenar datos, sino tambi\u00e9n para controlar dispositivos de E/S.</li> </ul> <p>En cambio, cada hilo tiene sus propios valores para:</p> <ul> <li>Los registros del procesador.</li> <li>El estado de su pila (stack). En la pila se guarda informaci\u00f3n acerca de las llamadas en curso de ejecuci\u00f3n a m\u00e9todos de diversos objetos. Para cada llamada se guardan, entre otras cosas, los datos locales (en variables internas del m\u00e9todo).</li> </ul> <p></p>"},{"location":"ud2/#creacion-de-hilos-en-java","title":"Creaci\u00f3n de hilos en Java","text":""},{"location":"ud2/#interfaz-runnable","title":"Interfaz Runnable","text":"<p>Cuando un programa en Java se lanza (se convierte en un proceso) empieza a ejecutarse por su m\u00e9todo main() que lo ejecuta el thread principal, un hilo especial creado por la JVM para ejecutar la aplicaci\u00f3n.</p> <p>Desde un proceso se pueden crear e iniciar tantos threads como necesites. Estos hilos ejecutar\u00e1n partes del c\u00f3digo de la aplicaci\u00f3n en paralelo con el hilo principal.</p> <p>Los hilos en Java son un objeto como cualquier otro. Un hilo es una instancia de la clase java.lang.Thread, o instancias de clases que heredan de esta. Los hilos tienen la capacidad de ejecutar c\u00f3digo.</p> <p>La forma m\u00e1s usada para indicar a un hilo que c\u00f3digo queremos que ejecute es creando una clase que implemente la interfaz java.lang.Runnable.</p> <p>https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html</p>"},{"location":"ud2/#clase-java-que-implementa-la-interfaz-runnable","title":"Clase Java que implementa la interfaz Runnable","text":"<pre><code>public class MyRunnable implements Runnable{\n    public void run(){\n        System.out.println(\"MyRunnable running\");\n    }\n}\n</code></pre>"},{"location":"ud2/#implementacion-con-clase-anonima-de-la-interfaz-runnable","title":"Implementaci\u00f3n con clase an\u00f3nima de la interfaz Runnable","text":"<pre><code>Runnable myRunnable = new Runnable(){\n    public void run(){\n        System.out.println(\"Runnable running\");\n    }\n}\n</code></pre>"},{"location":"ud2/#implementacion-de-runnable-a-traves-de-una-expresion-lambda","title":"Implementaci\u00f3n de Runnable a trav\u00e9s de una expresi\u00f3n Lambda","text":"<pre><code>Runnable runnable = ()-&gt;{System.out.println(\"Lambda Runnable running\");};\n</code></pre>"},{"location":"ud2/#la-clase-thread","title":"La clase Thread","text":"<p>La segunda forma que tenemos que indicar a un thread el c\u00f3digo a ejecutar es creando una subclase de java.lang.Thread y sobrescribiendo el m\u00e9todo run(). La clase Thread implementa de forma impl\u00edcita la interfaz Runnable. Al igual que con Runnable, el m\u00e9todo run() contiene el c\u00f3digo que ejecutar\u00e1 un thread cuando se llame al m\u00e9todo start().</p> <p><pre><code>public class MyThread extends Thread{\n    public void run(){\n        System.out.println(\"MyThread running\");\n    }\n}\n\nMyThread myThread = new MyThread();\nmyThread.start();\n</code></pre> https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html</p> <p>Para hacer que un Thread ejecute el c\u00f3digo del m\u00e9todo run de una clase (instancia de clase, clase an\u00f3nima, expresi\u00f3n lambda) que implemente la interfaz Runnable, tenemos que pasar esa instancia como par\u00e1metro en el constructor de la clase Thread.</p> <pre><code>Runnable runnable = new MyRunnable();\n\nThread thread = new Thread(runnable);\nthread.start();\n</code></pre> <p>Cuando se inicia el thread, llamando a su m\u00e9todo start(), se crea un nuevo thread que ejecuta el c\u00f3digo del m\u00e9todo run de la instancia MyRunnable.</p>"},{"location":"ud2/#ejemplo-de-uso-de-runnable-y-thread","title":"Ejemplo de uso de Runnable y Thread","text":"<pre><code>/**\n * ESTA CLASE IMPRIME POR CONSOLA UN N\u00daMERO PRIMO MAYOR QUE EL N\u00daMERO\n * QUE SE LE HA PROPORCIONADO A TRAV\u00c9S DEL CONSTRUCTOR\n */\npackage runnable;\n\npublic class PrimoRunnable implements Runnable {\n\n    private long minimo;\n\n    public PrimoRunnable(long minimo) {\n        this.minimo = minimo;\n    }\n\n    @Override\n    public void run() {\n        long n = minimo;\n        while(!testPrimalidad(n)) {\n            System.out.printf(\"%d no es primo %n\", n);\n            ++n;\n        }\n\n        System.out.printf(\"El n\u00famero primo es %d %n\", n);\n    }\n\n    /*\n     * M\u00e9todo que nos permite verificar si un n\u00famero es\n     * primo revisando si tiene divisores hasta n/2\n     * OJO es f\u00e1cil de implementar, pero ineficiente para \n     * n\u00fameros grandes\n     */\n    public static boolean testPrimalidad(long n) {\n\n        boolean continuar = true;\n        boolean esPrimo = true;\n        long divisor = 2;\n        do {\n            if (n % divisor == 0) {\n                continuar = false;\n                esPrimo = false;\n            } else\n                ++divisor;          \n\n        } while (continuar &amp;&amp; divisor &lt;= (n/2));\n\n        return esPrimo;\n    }\n\n}\n</code></pre> <pre><code>package runnable;\n\npublic class EjemploRunnable {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n\n        //Creaci\u00f3n y lanzamiento de PrimoRunnable\n        //a trav\u00e9s de un thread.\n        Thread t = new Thread(new PrimoRunnable(25));\n        t.start();\n\n\n        //Otra forma de hacerlo, a trav\u00e9s de una \n        //instancia an\u00f3nima\n        new Thread(new PrimoRunnable(32)).start();\n\n    }\n\n}\n</code></pre>"},{"location":"ud2/#ejemplo-de-implementacion-de-runnable-de-forma-anonima","title":"Ejemplo de implementaci\u00f3n de Runnable de forma an\u00f3nima","text":"<pre><code>package runnable;\n\npublic class EjemploRunnableAnonimo {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n\n        //Este trozo de c\u00f3digo puede ser muy com\u00fan si\n        //el proceso de lanzamiento del hilo est\u00e1 dentro\n        //de un manejador de eventos, como el click de un\n        //bot\u00f3n.\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                System.out.println(\"Hello from Runnable+Thread!!\");\n\n            }\n\n        }).start();\n\n        //Este c\u00f3digo es como el anterior, pero aprovecha la potencia\n        //de las expresiones lambda.\n        new Thread(() -&gt; System.out.print(\"Hello from Lambda Runnable+Thread\")).start();\n\n    }\n\n}\n</code></pre>"},{"location":"ud2/#estados-de-un-hilo","title":"Estados de un hilo","text":"<p>Durante el ciclo de vida de los hilos estos pasan por distintos estados. En Java est\u00e1n recogidos dentro de la enumeraci\u00f3n State, contenida dentro de la clase java.lang.Thread.</p> <p>El estado de un hilo se obtiene mediante el m\u00e9todo getState() de la clase Thread.</p> Estado Valor en Thread.State Descripci\u00f3n Nuevo NEW El hilo est\u00e1 creado, pero a\u00fan no se ha arrancado Ejecutable RUNNABLE El hilo est\u00e1 arrancado y podr\u00eda estar en ejecuci\u00f3n o pendiente de ejecuci\u00f3n Bloqueado BLOCKED Bloqueado por un monitor Esperando WAITING El hilo est\u00e1 esperando a que otro hilo realice una acci\u00f3n determinada Esperando un tiempo TIME_WAITING El hilo est\u00e1 esperando a que otro hilo realice una acci\u00f3n determinada en un periodo de tiempo concreto Finalizado TERMINATED El hilo ha terminado su ejecuci\u00f3n"},{"location":"ud2/#pausar-hilos","title":"Pausar hilos","text":"<p>Un thread puede pausar su propia ejecuci\u00f3n llamando al m\u00e9todo est\u00e1tico Thread.sleep(). El m\u00e9todo sleep() recibe como par\u00e1metro el n\u00famero de milisegundos que quiere estar pausado antes de volver a ponerse como listo para ejecuci\u00f3n.</p> <pre><code>try{\n    Thread.sleep(3000L);\n}catch(InterruptedException e){\n    e.printStackTrace();\n}\n</code></pre> <p>En Java podemos generar n\u00fameros aleatorios en el rango de los enteros, long, float y double.</p> <ul> <li>Usando la clase Random.</li> <li>Usando la clase Math.random.</li> <li>Usando ThreadLocalRandom.</li> </ul>"},{"location":"ud2/#ejemplo-de-lanzamiento-de-hilos","title":"Ejemplo de lanzamiento de hilos","text":"<pre><code>package runnable;\n\nclass Hilo implements Runnable {\n\n  private final String nombre;\n\n  Hilo(String nombre) {\n    this.nombre = nombre;\n  }\n\n  @Override\n  public void run() {\n    System.out.printf(\"Hola, soy el hilo: %s.\\n\", this.nombre);\n    System.out.printf(\"Hilo %s terminado.\\n\", this.nombre);\n  }\n\n}\n\npublic class LanzaHilos {\n\n  public static void main(String[] args) throws InterruptedException {\n\n    Thread h1 = new Thread(new Hilo(\"H1\"));\n    Thread h2 = new Thread(new Hilo(\"H2\"));\n    h1.start();\n    h2.start();\n    h1.join();\n    h2.join();\n    System.out.println(\"Hilo principal terminado.\");\n\n  }\n\n}\n</code></pre>"},{"location":"ud2/#ejemplo-de-uso-de-sleep","title":"Ejemplo de uso de sleep()","text":"<pre><code>package lanzahilosyesperaqueterminen;\n\nimport java.util.Random;\n\n/* \nEl siguiente programa lanza dos hilos. Cada uno de ellos hace pausas de duraci\u00f3n aleatoria \nde ente 10 y 500 ms, utilizando el m\u00e9todo sleep de la clase Thread. El hilo principal utiliza \nel m\u00e9todo join para esperar a que terminen los dos hilos lanzados, por lo que siempre terminar\u00e1 \nel \u00faltimo. Los dos m\u00e9todos anteriores pausan la ejecuci\u00f3n del hilo, y durante ese periodo de tiempo \nse podr\u00eda interrumpir. Si esto sucede, se lanzar\u00eda una InterruptedException, que se captura para \nmostrar un mensaje\n*/\n\n\nclass Hilo implements Runnable {\n\n  private final String nombre;\n\n  Hilo(String nombre) {\n    this.nombre = nombre;\n  }\n\n  @Override\n  public void run() {\n    System.out.printf(\"Hola, soy el hilo: %s.\\n\", this.nombre);\n    for (int i = 0; i &lt; 5; i++) {\n      Random r = new Random();\n      int pausa = 10 + r.nextInt(500 - 10);\n      System.out.printf(\"Hilo: %s hace pausa de %d ms.\\n\", this.nombre, pausa);\n      try {\n        Thread.sleep(pausa);\n      } catch (InterruptedException e) {\n        System.out.printf(\"Hilo %s interrumpido.\\n\", this.nombre);\n      }\n    }\n    System.out.printf(\"Hilo %s terminado.\\n\", this.nombre);\n  }\n\n}\n\npublic class LanzaHilosYEsperaQueTerminen {\n\n  public static void main(String[] args) {\n\n    Thread h1 = new Thread(new Hilo(\"H1\"));\n    Thread h2 = new Thread(new Hilo(\"H2\"));\n    h1.start();\n    h2.start();\n    try {\n      h1.join();\n      h2.join();\n    } catch (InterruptedException ex) {\n      System.out.println(\"Hilo principal interrumpido.\");\n    }\n    System.out.println(\"Hilo principal terminado.\");\n  }\n}\n</code></pre>"},{"location":"ud2/#gestion-de-la-prioridad-de-los-hilos","title":"Gesti\u00f3n de la prioridad de los hilos","text":"<p>Los hilos heredan la prioridad del padre en Java, pero este valor puede ser cambiado con el m\u00e9todo setPriority(). Con getPriority() podemos saber la prioridad de un hilo.</p> <p>El valor de la prioridad var\u00eda entre 1 y 10. Cuanto m\u00e1s alto es el valor, mayor es la prioridad. La clase Thread define las siguientes constantes MIN_PRIORITY (valor 1), MAX_PRIORITY (valor 10) y NORM_PRIORITY (valor 5).</p> <p>El planificador elige el hilo en funci\u00f3n de su prioridad. Si dos hilos tienen la misma prioridad realiza un round robin, es decir, va alternando los hilos de forma c\u00edclica.</p> <p>El hilo de mayor prioridad seguir\u00e1 funcionando hasta que ceda el control:</p> <ul> <li>Cede el control llamando al m\u00e9todo yield().</li> <li>Deja de ser ejecutable (por muerte o por bloqueo).</li> <li>Aparece un hilo de mayor prioridad, por ejemplo, si se encontraba en estado dormido por una operaci\u00f3n de E/S o bien es desbloqueado por otro con los m\u00e9todos notifyAll()/notify().</li> </ul>"},{"location":"ud2/#ejemplo-de-asignacion-de-prioridad-a-hilos","title":"Ejemplo de asignaci\u00f3n de prioridad a hilos","text":"<pre><code>package thread;\n\nclass HiloPrioridad extends Thread {\n    private int c = 0;\n    private boolean stopHilo = false;\n    public long getContador () {\n        return c;\n    }\n    public void pararHilo() {\n        stopHilo = true;\n    }\n    @Override\n    public void run() {\n        while (!stopHilo) c++;\n    }\n}\n\npublic class EjemploHiloPrioridad {\n    public static void main(String args[]) {\n        HiloPrioridad h1 = new HiloPrioridad();\n        HiloPrioridad h2 = new HiloPrioridad();\n        HiloPrioridad h3 = new HiloPrioridad();\n\n        h1.setPriority(Thread.NORM_PRIORITY);\n        h2.setPriority(Thread.MAX_PRIORITY);\n        h3.setPriority(Thread.MIN_PRIORITY);\n\n        h1.start();\n        h2.start();\n        h3.start();\n\n        try {\n            Thread.sleep(1);\n        } catch (InterruptedException e) {}\n\n        h1.pararHilo();\n        h2.pararHilo();\n        h3.pararHilo();\n\n        System.out.println(\"h2 (Prio. M\u00e1x:    \"+h2.getContador()+\")\");\n        System.out.println(\"h1 (Prio. Normal: \"+h1.getContador()+\")\");\n        System.out.println(\"h3 (Prio. M\u00ednima: \"+h3.getContador()+\")\");\n    }\n}\n</code></pre>"},{"location":"ud2/#ejemplo-de-creacion-de-grupos-de-hilos-y-asignacion-de-prioridades","title":"Ejemplo de creaci\u00f3n de grupos de hilos y asignaci\u00f3n de prioridades","text":"<pre><code>package thread;\n\npublic class ThreadMethodsExample extends Thread {\n\n    ThreadMethodsExample (ThreadGroup group, String name) {\n        super(group, name);\n    }\n\n    @Override\n    public void run() {\n        String threadName = Thread.currentThread().getName();\n        System.out.println(\"[\"+threadName+\"] \" + \"Inside the thread\");\n        System.out.println(\"[\"+threadName+\"] \" + \"Priority: \" \n          + Thread.currentThread().getPriority());\n        Thread.yield();\n        System.out.println(\"[\"+threadName+\"] \" + \"Id: \" \n          + Thread.currentThread().threadId());\n        System.out.println(\"[\"+threadName+\"] \" + \"ThreadGroup: \" \n          + Thread.currentThread().getThreadGroup().getName());\n        System.out.println(\"[\"+threadName+\"] \" + \"ThreadGroup count: \" \n          + Thread.currentThread().getThreadGroup().activeCount());\n    } \n\n    public static void main(String[] args) {\n        // main thread \n        Thread.currentThread().setName(\"Main\");\n        System.out.println(Thread.currentThread().getName());\n        System.out.println(Thread.currentThread().toString());\n\n        ThreadGroup even = new ThreadGroup(\"Even threads\");\n        ThreadGroup odd = new ThreadGroup(\"Odd threads\");\n\n        Thread localThread = null;\n        for (int i=0; i&lt;10; i++) {\n            localThread = new ThreadMethodsExample((i%2==0)?even:odd, \"Thread\"+i);\n            localThread.setPriority(i+1);\n            localThread.start();\n        }\n\n        try {\n            localThread.join(); // --&gt; Will wait until last thread ends \n                                // like a waitFor() for processes\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n            System.err.println(\"The main thread was interrupted while waiting for \" \n              + localThread.toString() + \"to finish\");\n        }\n        System.out.println(\"Main thread ending\");\n    }    \n}\n</code></pre>"},{"location":"ud2/#sincronizacion-de-hilos","title":"Sincronizaci\u00f3n de hilos","text":"<p>Un programa puede lanzar m\u00faltiples hilos que colaboren entre s\u00ed para la realizaci\u00f3n de una tarea. La forma que tienen de hacerlo consiste en compartir un objeto.</p> <p>La comunicaci\u00f3n entre hilos se produce principalmente mediante el acceso compartido a objetos y sus propiedades. Este mecanismo de comunicaci\u00f3n es muy eficiente pero presenta dos tipos de errores:</p> <ul> <li>Interferencia entre hilos.</li> <li>Errores de consistencia de la informaci\u00f3n en memoria.</li> </ul> <p>La herramienta de programaci\u00f3n que utilizamos para prevenir este tipo de errores es la sincronizaci\u00f3n. La mayor parte del tiempo los hilos no tienen en cuenta al resto de hilos que se ejecutan en el programa ni les importa lo que estos hagan, pero si necesitan algo de otro hilo aparece el uso de la sincronizaci\u00f3n.</p>"},{"location":"ud2/#ejemplo-de-no-sincronizacion-de-hilos","title":"Ejemplo de no sincronizaci\u00f3n de hilos","text":""},{"location":"ud2/#sumadorjava","title":"Sumador.java","text":"<pre><code>package hilosnosincronizados;\n\npublic class Sumador extends Thread {\n\n    private Contador c;\n\n    public Sumador(String name, Contador c) {\n        // To set the thread name we can access the Thread class constructor\n        super(name);\n        this.c = c;\n    }\n\n    @Override\n    public void run() {\n        // Ejecutar 300 veces con espera entre 50ms y 150ms\n        for (int i = 0; i &lt; 300; i++) {\n            try {\n                c.incrementa();\n                System.out.println(Thread.currentThread().getName() + \" \" + c.valor());\n                Thread.sleep((long) (Math.random() * 100 + 50));\n            } catch (InterruptedException ex) {\n                // Nothing\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ud2/#restadorjava","title":"Restador.java","text":"<pre><code>package hilosnosincronizados;\n\npublic class Restador implements Runnable {\n\n    private Contador c;\n    private String name;\n\n    public Restador(String name, Contador c) {\n        // Restador doesn't extend Thread, so it cannot call the Thread constructor\n        // super(name);\n        this.name = name;\n        this.c = c;\n    }\n\n    @Override\n    public void run() {\n        Thread.currentThread().setName(this.name);\n        // Ejecutar 300 veces con espera entre 50ms y 150ms\n        for (int i = 0; i &lt; 300; i++) {\n            try {\n                c.decrementa();\n                System.out.println(Thread.currentThread().getName() + \" \" + c.valor());\n                Thread.sleep((long) (Math.random() * 100 + 50));\n            } catch (InterruptedException ex) {\n                // Nothing\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ud2/#contadorjava","title":"Contador.java","text":"<pre><code>package hilosnosincronizados;\n\npublic class Contador {\n\n    private int c = 0;\n\n    public Contador(int c) {\n        this.c = c;\n    }\n\n    public void incrementa() {\n        c++;\n    }\n\n    public void decrementa() {\n        c--;\n    }\n\n    public int valor() {\n        return c;\n    }\n}\n</code></pre>"},{"location":"ud2/#memoriacompartidajava","title":"MemoriaCompartida.java","text":"<pre><code>package hilosnosincronizados;\n\npublic class MemoriaCompartida {\n\n    public static void main(String[] args) throws InterruptedException {\n        // Inicializar el objeto Contador\n        Contador c = new Contador(100);\n\n        // Crear y lanzar 2 hilos (Sumador + Restador)\n        Sumador s1 = new Sumador(\"Sumador1\", c);\n        Restador r1 = new Restador(\"Restador1\", c);\n        Thread h1 = new Thread(r1);\n\n        s1.start();\n        h1.start();\n\n        // El hilo principal espera a que los hilos s1 y r1 terminen\n        s1.join();\n        h1.join();\n\n        System.out.println(\"El valor final de c es \" + c.valor());\n\n    }\n}\n</code></pre>"},{"location":"ud2/#monitores-y-bloqueos","title":"Monitores y bloqueos","text":"<p>La sincronizaci\u00f3n en Java se realiza usando monitores. Es una propiedad que proporciona la clase Object. Este mecanismo permite a un \u00fanico hilo a la vez ejecutar la secci\u00f3n de c\u00f3digo protegida por el monitor.</p> <p>Un monitor no es m\u00e1s que un bloqueo sobre un objeto. Cada objeto tiene un \u00fanico bloqueo (candado) interno asociado. El bloqueo de un objeto solamente puede ser adquirido por un hilo en cada momento.</p> <p>La sincronizaci\u00f3n implica muchos conceptos. El m\u00e1s utilizado es la exclusi\u00f3n mutua (solo un hilo puede disponer de un monitor a la vez). Por tanto, la sincronizaci\u00f3n utilizando monitores consiste en que cuando un hilo accede a una secci\u00f3n protegida por un monitor ning\u00fan otro hilo puede acceder a esa o a cualquier otra secci\u00f3n protegida por ese mismo monitor, hasta que el hilo salga de la secci\u00f3n protegida.</p> <p>Pero la sincronizaci\u00f3n tambi\u00e9n asegura que las escrituras en memoria realizadas por un hilo dentro de un bloque protegido por un monitor son accesibles al resto de hilos que accedan a los bloques protegidos por ese mismo monitor.</p>"},{"location":"ud2/#secciones-criticas","title":"Secciones cr\u00edticas","text":"<p>En Java la palabra reservada synchronized sirve para hacer que un bloque de c\u00f3digo o un m\u00e9todo sea protegido por el cerrojo del objeto. </p> <p>Para ejecutar un bloque o un m\u00e9todo sincronizado, los hilos deben conseguir previamente el bloqueo (candado) del objeto, debiendo esperar a que quede libre (el hilo que lo tiene lo libere) si el monitor ya ha sido adquirido por otro hilo.</p> <p>Esto ocurre solo si se est\u00e1 intentando acceder al monitor del mismo objeto que otro hilo ya tenga en propiedad.</p> <p>La palabra reservada synchronized puede aplicarse en distintos tipo de bloques de c\u00f3digo y, en cada caso, se utilizar\u00e1 un objeto de bloqueo distinto.</p> <ul> <li>M\u00e9todos no est\u00e1ticos: Se a\u00f1ade el synchronized a la declaraci\u00f3n del m\u00e9todo.</li> <li>M\u00e9todos est\u00e1ticos: El bloqueo intr\u00ednseco se realiza sobre la clase a la que pertenece el m\u00e9todo. Dos hilos distintos no pueden estar a la vez ejecutando cada uno un m\u00e9todo est\u00e1tico sincronizado de la misma clase.</li> <li>Bloques de c\u00f3digo cualquiera: Despu\u00e9s de la palabra clave synchronized, y entre par\u00e9ntesis, se indica el objeto sobre el que se realiza el bloqueo.</li> </ul> <p>El siguiente c\u00f3digo define dos bloques protegidos por la instancia a la que pertenecen. En t\u00e9rminos de sincronizaci\u00f3n, ambos bloques son totalmente equivalentes.</p> <pre><code>public class MyClass{\n    public synchronized void log1(String msg1, String msg2){\n        log.writeln(msg1);\n        log.writeln(msg2);\n    }\n\n    public void log2(String msg1, String msg2){\n        synchronized(this){\n            log.writeln(msg1);\n            log.writeln(mgs2);\n        }\n    }\n}\n</code></pre> <p>Solo un hilo podr\u00eda ejecutar uno de los dos bloques anteriores al mismo tiempo. Si otro hilo intentase ejecutar el mismo bloque, o el otro, se quedar\u00eda bloqueado en la cola de espera del monitor hasta que el monitor quede libre.</p>"},{"location":"ud2/#variables-volatile","title":"Variables volatile","text":"<p>En un entorno de computaci\u00f3n de m\u00faltiples n\u00facleos, los procesadores disponen de t\u00e9cnicas de optimizaci\u00f3n y algunas de ellas se basan en el uso de memoria cach\u00e9. Estas t\u00e9cnicas habitualmente son ventajosas, pero en la programaci\u00f3n concurrente pueden ser una fuente de errores.</p> <p>Cuando varios hilos comparten la misma variable, si esta se almacena en las cach\u00e9s de los n\u00facleos, puede ser que los hilos vean copias distintas de la misma variable, lo que puede provocar inconsistencia de memoria.</p> <p>Para evitar que una variable se almacene en la cach\u00e9 del procesador y que todos los hilos accedan a la misma copia en Java utiliza la palabra reservada volatile. Declarando una variable. Declarando una variable como volatile solo existir\u00e1 una copia en el procesador.</p> <p><pre><code>private volatile static long contador:\n</code></pre> Las variables volatile ser\u00edan apropiadas para sistemas en los que un \u00fanico hilo modifica el valor de la variable y el resto solamente lo consultan.</p>"},{"location":"ud2/#comparticion-de-recursos-con-bloqueo-dependiente-de-su-estado","title":"Compartici\u00f3n de recursos con bloqueo dependiente de su estado","text":"<p>Existe otro tipo de problemas en los que, dependiendo del estado de los recursos, cada uno de los hilos podr\u00e1 realizar determinadas acciones o no. Y, en este \u00faltimo caso, podr\u00e1 quedar a la espera de que se produzca un cambio de estado, de lo que ser\u00e1 notificado por otros hilos.</p> <p>Para ello ser\u00e1 necesario un mecanismo de espera para que, en el caso de que el estado de los recursos compartidos no permita que se realice una operaci\u00f3n, la ejecuci\u00f3n del hilo quede en suspenso a la espera de que esa condici\u00f3n se cumpla. Y debe ser un mecanismos de espera no activa. Es decir, no se debe consumir tiempo del procesador ni recursos del sistema para comprobar si es posible continuar con la ejecuci\u00f3n, mientras no se reciba una notificaci\u00f3n de que el estado ha cambiado y podr\u00eda permitir que el hilo contin\u00fae su ejecuci\u00f3n.</p> <p>Para este tipo de problemas se utilizan varios m\u00e9todos que se pueden ejecutar solo en un bloque de c\u00f3digo synchronized, y sobre el objeto de bloqueo para el bloque de c\u00f3digo.</p> <p>Son los siguientes:</p> <ul> <li>wait(): Interrumpe la ejecuci\u00f3n del hilo actual. La ejecuci\u00f3n del hilo queda bloqueada mientras otro hilo no ejecute el m\u00e9todo notify() o notifyAll() sobre el objeto.</li> <li>notify(): Desbloquea uno de los hilos que est\u00e1n esperando sobre el objeto tras hacer ejecutado el m\u00e9todo wait(), de manera que pueda continuar su ejecuci\u00f3n. Este m\u00e9todo, por tanto, proporciona un mecanismo de notificaci\u00f3n para terminar con la espera no activa de los hilos que est\u00e1n a la espera en un objeto de bloqueo.</li> <li>notifyAll(): Desbloquea todos los hilos que est\u00e1n esperando sobre el objeto de bloqueo tras haber ejecutado el m\u00e9todo wait(), de manera que puedan continuar su ejecuci\u00f3n.</li> </ul> <p>Cuando se llama al m\u00e9todo wait() el hilo estar\u00e1 dentro de un bloque sincronizado, por lo tanto tendr\u00e1 el bloqueo de monitor. En ese momento el hilo libera el bloqueo de ese monitor y se queda una cola (perteneciente al objeto) de hilos en espera de ser notificados, diferente a la de los hilos que est\u00e1n esperando por el bloque.</p> <p>Cuando se desbloquea un hilo porque otro ha llamado a notify()/notifyAll(), el hilo vuelve al punto donde hizo el wait(), por lo tanto sigue dentro de un bloque sincronizado. Para poder continuar con la ejecuci\u00f3n tendr\u00e1 que pasar a la cola de hilos esperando por el bloqueo y esperar a ser seleccionado para seguir ejecut\u00e1ndose.</p> <p></p>"},{"location":"ud2/#ejemplo-de-uso-de-monitores","title":"Ejemplo de uso de monitores","text":"<pre><code>package monitores;\n\nclass Contador {\n    // monitor contador\n\n    private int actual;\n\n    public Contador(int inicial) {\n        actual = inicial;\n    }\n\n    public synchronized void inc() {\n        actual++;\n    }\n\n    public synchronized void dec() {\n        actual--;\n    }\n\n    public synchronized int valor() {\n        return actual;\n    }\n}\n\nclass Usuario extends Thread {\n    // clase hilo usuario\n\n    private Contador cnt;\n\n    public Usuario(String nombre, Contador cnt) {\n        super(nombre);\n        this.cnt = cnt;\n    }\n\n    public void run() {\n        for (int i = 0; i &lt; 1000; i++) {\n            cnt.inc();\n            System.out.println(\"Hola, soy \" + this.getName() + \", mi contador vale \" + cnt.valor());\n        }\n    }\n}\n\nclass EjemploContador {\n    // principal\n\n    final static int nHilos = 20;\n\n    public static void main(String[] args) {\n        // metodo principal      \n        final Contador cont1 = new Contador(0);\n        Usuario hilo[] = new Usuario[nHilos];\n        for (int i = 0; i &lt; nHilos; i++) {\n            //crea hilos\n            hilo[i] = new Usuario(\"El hilo-\" + i, cont1);\n            // lanza hilos      \n            hilo[i].start();\n        }\n    }\n}\n</code></pre>"},{"location":"ud2/#solucion-al-ejemplo-de-sincronizacion-de-hilos","title":"Soluci\u00f3n al ejemplo de sincronizaci\u00f3n de hilos","text":""},{"location":"ud2/#contadorjava_1","title":"Contador.java","text":"<p><pre><code>package hilosnosincronizados;\n\npublic class Contador {\n\n    private int c = 0;\n\n    public Contador(int c) {\n        this.c = c;\n    }\n\n    public synchronized void incrementa() {\n        c++;\n    }\n\n    public synchronized void decrementa() {\n        c--;\n    }\n\n    public synchronized int valor() {\n        return c;\n    }\n}\n</code></pre> Otra soluci\u00f3n, garantizando que se alternen suma y resta:</p> <pre><code>package hilossincronizados;\n\npublic class Contador {\n\n    private int c = 0;\n    boolean ahoraSumador = true;\n\n    public Contador(int c) {\n        this.c = c;\n        ahoraSumador = true;\n    }\n\n    public synchronized void incrementa() {\n        while (!ahoraSumador) {\n            try {\n                wait();\n            } catch (InterruptedException ex) {\n            }\n        }\n\n        // El hilo hace su tarea\n        c++;\n        System.out.println(Thread.currentThread().getName() + \" \" +  valor());\n\n        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\n        ahoraSumador = false;\n        notifyAll();\n\n    }\n\n    public synchronized void decrementa() {\n        while (ahoraSumador) {\n            try {\n                wait();\n            } catch (InterruptedException ex) { }\n        }\n\n        // El hilo hace su tarea\n        c--;\n        System.out.println(Thread.currentThread().getName() + \" \" +  valor());\n\n        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\n        ahoraSumador = true;\n        notifyAll();\n    }\n\n    public synchronized int valor() {\n        return c;\n    }\n}\n</code></pre>"},{"location":"ud2/#el-modelo-productor-consumidor","title":"El modelo productor-consumidor","text":"<p>Un problema t\u00edpico de sincronizaci\u00f3n es el que representa el modelo Productor-Consumidor. Se produce cuando uno o m\u00e1s hilos producen datos a procesar y otros hilos los consumen. </p> <p>El programa describe dos procesos, productor y consumidor, ambos comparten un b\u00fafer de tama\u00f1o finito. La tarea del productor es generar un producto, almacenarlo y comenzar nuevamente; mientras que el consumidor toma (simult\u00e1neamente) productos uno a uno. El problema consiste en que el productor no a\u00f1ada m\u00e1s productos que la capacidad del buffer y que el consumidor no intente tomar un producto si el buffer est\u00e1 vac\u00edo.</p> <p>La idea para la soluci\u00f3n es la siguiente, ambos procesos (productor y consumidor) se ejecutan simult\u00e1neamente y se \u201cdespiertan\u201d o \u201cduermen\u201d seg\u00fan el estado del buffer. Concretamente, el productor agrega productos mientras quede espacio y en el momento en que se llene el buffer se pone a \u201cdormir\u201d. Cuando el consumidor toma un producto notifica al productor que puede comenzar a trabajar nuevamente. En caso contrario, si el buffer se vac\u00eda, el consumidor se pone a dormir y en el momento en que el productor agrega un producto crea una se\u00f1al para despertarlo. Una inadecuada implementaci\u00f3n del problema puede terminar en un deadlock, donde ambos procesos queden en espera de ser despertados.</p> <p>https://es.wikipedia.org/wiki/Problema_productor-consumidor</p>"},{"location":"ud2/#aproximacion-erronea","title":"Aproximaci\u00f3n err\u00f3nea","text":"<p>Para resolver el problema cualquier programador podr\u00eda llegar a la soluci\u00f3n que se muestra a continuaci\u00f3n. En la misma se utilizan dos bibliotecas, sleep y wakeup. La variable global itemCount contiene el n\u00famero de elementos en el buffer.</p> <p><pre><code>int itemCount = 0;\n\nprocedure producer() {\n    while (true) {\n        item = produceItem();\n\n        if (itemCount == BUFFER_SIZE) {\n            sleep();\n        }\n\n        putItemIntoBuffer(item);\n        itemCount = itemCount + 1;\n\n        if (itemCount == 1) {\n            wakeup(consumer);\n        }\n    }\n}\n\nprocedure consumer() {\n    while (true) {\n\n        if (itemCount == 0) {\n            sleep();\n        }\n\n        item = removeItemFromBuffer();\n        itemCount = itemCount - 1;\n\n        if (itemCount == BUFFER_SIZE - 1) {\n            wakeup(producer);\n        }\n\n        consumeItem(item);\n    }\n}\n</code></pre> El problema con esta aproximaci\u00f3n es que puede caer en un deadlock, considere el siguiente escenario:</p> <ol> <li>El consumidor acaba de consultar la variable itemCount, nota que es cero y pasa a ejecutar el bloque if.</li> <li>Justo antes de llamar a la funci\u00f3n sleep() el consumidor es interrumpido y el productor comienza a trabajar.</li> <li>El productor crea un objeto, lo agrega al buffer y aumenta itemCount.</li> <li>Como el buffer estaba vac\u00edo antes de la \u00faltima adici\u00f3n el productor intenta despertar al consumidor.</li> <li>Desafortunadamente el consumidor no estaba durmiendo todav\u00eda luego la llamada para despertarlo se pierde. Una vez que el consumidor comienza a trabajar nuevamente pasa a dormir y nunca m\u00e1s ser\u00e1 despertado. Esto pasa porque el productor solo lo despierta si el valor de itemCount es 1.</li> <li>El productor seguir\u00e1 trabajando hasta que el buffer se llene, cuando esto ocurra se pondr\u00e1 a dormir tambi\u00e9n.</li> </ol> <p>Como ambos procesos dormir\u00e1n por siempre, hemos ca\u00eddo en un deadlock. La esencia del problema es que se perdi\u00f3 una llamada enviada para despertar a un proceso que todav\u00eda no estaba dormido. Si no se perdiera, todo funcionar\u00eda.</p>"},{"location":"ud2/#solucion-usando-monitores","title":"Soluci\u00f3n usando monitores","text":"<p>Este problema se base en tres clases, aunque dependiendo del problema, podemos encontrarnos que no tenemos productor o consumidor.</p>"},{"location":"ud2/#clase-principal","title":"Clase principal","text":"<p>En esta clase se declara el objeto o propiedad que van a compartir el productor y el consumidor. Este objeto es a trav\u00e9s del que se realiza la comunicaci\u00f3n, sincronizaci\u00f3n e intercambio de informaci\u00f3n entre los hilos.</p> <p>Se puede representar como un objeto, una colecci\u00f3n o cualquier estructura de datos que pueda compartir hilos.</p>"},{"location":"ud2/#clase-productor-y-consumidor","title":"Clase productor y consumidor","text":"<p>Estas dos clases son las que van a tener, dentro del m\u00e9todo run, la l\u00f3gica de la aplicaci\u00f3n, accediendo al objeto compartido, modificando las propiedades compartido, modificando las propiedades compartidas entre los diferentes hilos (productores y/o consumidores) y actualizando el estado del objeto compartido para que module su funcionalidad.</p>"},{"location":"ud2/#clase-compartida","title":"Clase compartida","text":"<p>Aqu\u00ed vamos a crear los m\u00e9todos a los que acceden productores y consumidores y, adem\u00e1s, vamos realizar la sincronizaci\u00f3n entre hilos para que no se produzcan condiciones de carrera.</p>"},{"location":"ud2/#ejemplo-en-java-productor-consumidor","title":"Ejemplo en Java productor-consumidor","text":"<pre><code>package productorconsumidor;\n\nclass Contenedor&lt;T&gt; {\n\n    private T dato;\n\n    synchronized public T get() {\n        T result = this.dato;\n        this.dato = null;\n        return result;\n    }\n\n    synchronized public void put(T valor) {\n        this.dato = valor;\n    }\n\n    synchronized boolean datoDisponible() {\n        return (this.dato != null);\n    }\n}\n\nclass HiloProductor implements Runnable {\n\n    final Contenedor&lt;Integer&gt; cont;\n    String miNombre;\n\n    HiloProductor(Contenedor&lt;Integer&gt; cont, String miNombre) {\n        this.cont = cont;\n        this.miNombre = miNombre;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 1;; i++) {\n            synchronized (this.cont) {\n                while (this.cont.datoDisponible()) {\n                    try {\n                        this.cont.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n                System.out.printf(\"Hilo %s produce valor %s.\\n\", this.miNombre, i);\n                this.cont.put(i);\n                this.cont.notify();\n            }\n        }\n    }\n\n}\n\nclass HiloConsumidor implements Runnable {\n\n    final Contenedor&lt;Integer&gt; cont;\n    String miNombre;\n\n    HiloConsumidor(Contenedor&lt;Integer&gt; cont, String miNombre) {\n        this.cont = cont;\n        this.miNombre = miNombre;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (this.cont) {\n                while (!this.cont.datoDisponible()) {\n                    try {\n                        this.cont.wait();\n                    } catch (InterruptedException ex) {\n                    }\n                }\n                Integer dato = this.cont.get();\n                this.cont.notify();\n                System.out.printf(\"Hilo %s consume valor %d.\\n\", this.miNombre, dato);\n            }\n        }\n    }\n\n}\n\npublic class ProductorConsumidor {\n\n    public static void main(String[] args) {\n        Contenedor&lt;Integer&gt; almacen = new Contenedor&lt;Integer&gt;();\n        Thread hprod = new Thread(new HiloProductor(almacen, \"P\"));\n        Thread hcons = new Thread(new HiloConsumidor(almacen, \"C\"));\n        hprod.start();\n        hcons.start();\n    }\n\n}\n</code></pre>"},{"location":"ud2/#semaforos","title":"Sem\u00e1foros","text":"<p>Un sem\u00e1foro es un mecanismo para permitir, o restringir, el acceso a recursos compartidos en un entorno multiprocesamiento, con varios hilos ejecut\u00e1ndose de forma concurrente.</p> <p>Los sem\u00e1foros se emplean para permitir el acceso a diferentes partes de programas (llamadas secciones cr\u00edticas) donde se manipulan variables o recursos que deben ser accedidos de forma especial. Seg\u00fan el valor con que son inicializados se permiten a m\u00e1s o menos procesos utilizar el recurso de forma simult\u00e1nea.</p> <p>El funcionamiento de los sem\u00e1foros se basa en el uso de dos m\u00e9todos, as\u00ed como en valor inicial permits con el que se crea el sem\u00e1foro:</p> <ul> <li>release(): Ejecutando por un hilo para liberar el sem\u00e1foro cuando el hilo ha terminado de ejecutar la secci\u00f3n cr\u00edtica.</li> <li>acquire(): Ejecutando por un hilo para acceder al sem\u00e1foro.</li> <li>permits: Se inicializa a la cantidad de recursos existentes o hilos que queramos que puedan acceder simult\u00e1neamente.</li> </ul> <p>https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Semaphore.html</p>"},{"location":"ud2/#ejemplo-de-uso-de-semaforos","title":"Ejemplo de uso de sem\u00e1foros","text":""},{"location":"ud2/#hilojava","title":"Hilo.java","text":"<pre><code>package semaforos;\n\nimport java.util.concurrent.Semaphore;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class Hilo extends Thread {\n\n    private Semaphore sem;\n\n    public Hilo(Semaphore sem) {\n        this.sem = sem;\n    }\n\n    public void run() {\n        int espera = 0;\n\n        while (true) {\n            try {\n                sem.acquire();\n\n                System.out.println(\"Sem\u00e1foro adquirido por \" + this.getName());\n                espera = (int) (Math.random() * 2000 + 500);\n                System.out.println(this.getName() + \" procesando acci\u00f3n de espera \" + espera);\n                System.out.println(\"Sem\u00e1foro liberado por \" + this.getName());\n                sleep(espera);\n                sem.release();\n\n                espera = (int) (Math.random() * 500);\n                sleep(espera);\n            } catch (InterruptedException ex) {\n                Logger.getLogger(Hilo.class.getName()).log(Level.SEVERE, null, ex);\n            }\n\n        }\n    }\n\n}\n</code></pre>"},{"location":"ud2/#appjava","title":"App.java","text":"<pre><code>package semaforos;\n\nimport java.util.concurrent.Semaphore;\n\npublic class App {\n    public static void main( String[] args ) throws InterruptedException {\n        Semaphore sema = new Semaphore(2);\n\n        Hilo h1 = new Hilo(sema);\n        Hilo h2 = new Hilo(sema);\n        Hilo h3 = new Hilo(sema);\n\n        h1.start();\n        h2.start();\n        h3.start();\n\n        h3.join();\n        System.out.println(\"h3 terminado\" );\n        h1.join();\n        System.out.println(\"h1 terminado\" );\n        h2.join();\n        System.out.println(\"h2 terminado\" );\n\n    }\n}\n</code></pre>"},{"location":"ud2/#interrupcion-de-hilos","title":"Interrupci\u00f3n de hilos","text":"<ul> <li>Se puede interrumpir la ejecuci\u00f3n de un hilo (Thread) con el m\u00e9todo interrupt().</li> <li>Si el hilo se encuentra bloqueado en una llamada a sleep() de la clase Thread o a wait() de la clase Object, se produce una excepci\u00f3n de tipo InterruptedException.</li> <li>Pero todos los hilos deber\u00edan permitir su interrupci\u00f3n, aunque no usen nunca ninguno de los m\u00e9todos anteriores y, por tanto, no se pueda producir en ellos una excepci\u00f3n de tipo InterruptedException.</li> <li>Un hilo puede detectar que ha sido interrumpido (o mejor dicho, que se ha solicitado su interrupci\u00f3n) con el m\u00e9todo isInterrupted() de la clase Thread.</li> </ul>"},{"location":"ud2/#mecanismos-de-alto-nivel-para-concurrencia","title":"Mecanismos de alto nivel para concurrencia","text":"<p>Java, en su paquete java.util.concurrent proporciona varias clases thread-safe que nos permiten acceder a los elementos de colecciones y tipos de datos sin preocuparnos de la concurrencia.</p> <ul> <li>Colas concurrente: La interfaz BlockingQueue define una cola FIFO que bloquea procesos que intentan extraer un elemento cuando la cola est\u00e1 vac\u00eda, a la espera de que haya alg\u00fan elemento disponible en ella.</li> <li>Colecciones concurrentes: El uso de colecciones simult\u00e1neas es una forma recomendada de crear estructuras de datos compatibles con procesos. Dichas colecciones incluyen ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArraylist y CopyOnWriteArraySet.</li> <li>Variables at\u00f3micas: El paquete java.util.concurrent.atomic incluye clases que proporcionan operaciones at\u00f3micas sobre datos no estructurados, como n\u00fameros enteros o decimales con punto flotante.</li> </ul>"},{"location":"ud2/#executors-callables-y-future","title":"Executors, Callables y Future","text":"<ul> <li>Executors: Nos va a permitir definir un pool de threads (un conjunto de hilos) que se encargar\u00e1 de ejecutar las tareas, pero con un l\u00edmite en cuanto al n\u00famero de hilos creados y gestionando el la JVM la cola de hilos que ser\u00e1n ejecutados en ese pool.</li> <li>Callable: Viene a poner soluci\u00f3n a uno de los problemas que tenemos con la interfaz Runnable, la posibilidad de devolver un valor desde este m\u00e9todo. Si se necesita que un proceso devuelva datos al finalizar, se debe crear una clase que implemente la interfaz Callable y defina un m\u00e9todo call() que desempe\u00f1e la misma funci\u00f3n que run() en Runnable.</li> <li>Future: es una interfaz que implementa el objeto que devuelve el resultado de la ejecuci\u00f3n de un Callable. Se puede seguir ejecutando una aplicaci\u00f3n hasta que necesite obtener el resultado del hilo Callable, momento en el que se invoca el m\u00e9todo get() en la instancia Future. Si el resultado ya est\u00e1 disponible se recoge y en caso contrario se bloquear\u00e1 en la llamada hasta que su m\u00e9todo call() devuelva el resultado.</li> </ul>"},{"location":"ud2/#el-problema-de-la-cena-de-los-filosofos","title":"El problema de la cena de los fil\u00f3sofos","text":"<p>Cinco fil\u00f3sofos se sientan alrededor de una mesa y pasan su vida cenando y pensando. Cada fil\u00f3sofo tiene un plato de espaguetis y un tenedor a la izquierda de su plato. Para comer los espaguetis son necesarios dos tenedores y cada fil\u00f3sofo s\u00f3lo puede tomar los que est\u00e1n a su izquierda y derecha. Si cualquier fil\u00f3sofo toma un tenedor y el otro est\u00e1 ocupado, se quedar\u00e1 esperando, con el tenedor en la mano, hasta que pueda tomar el otro tenedor, para luego empezar a comer.</p> <p>Si dos fil\u00f3sofos adyacentes intentan tomar el mismo tenedor a una vez, se produce una condici\u00f3n de carrera: ambos compiten por tomar el mismo tenedor, y uno de ellos se queda sin comer.</p> <p>Si todos los fil\u00f3sofos toman el tenedor que est\u00e1 a su derecha al mismo tiempo, entonces todos se quedar\u00e1n esperando eternamente, porque alguien debe liberar el tenedor que les falta. Nadie lo har\u00e1 porque todos se encuentran en la misma situaci\u00f3n (esperando que alguno deje sus tenedores). Entonces los fil\u00f3sofos se morir\u00e1n de hambre. Este bloqueo mutuo se denomina interbloqueo o deadlock.</p> <p>El problema consiste en encontrar un algoritmo que permita que los fil\u00f3sofos nunca se mueran de hambre. A continuaci\u00f3n se muestra una posible soluci\u00f3n en Java.</p>"},{"location":"ud2/#solucion","title":"Soluci\u00f3n","text":"<pre><code>package filosofosComensales;\n\npublic class Tenedor {\n\n    private boolean tomado = false;\n\n    public synchronized void tomar() {\n        while (tomado) {\n            try {\n                wait();\n            } catch (InterruptedException ex) {\n                System.err.println(\"Error al tomar el tenedor\");\n            }\n        }\n        tomado = true;\n    }\n\n    public synchronized void dejar() {\n        tomado = false;\n        // Cambia notify por notifyAll y mira que pasa\n        // Ahora rompe el interbloqueo, codigo del main del if...\n        notify();\n        //notifyAll();\n    }\n\n}\n</code></pre> <pre><code>package filosofosComensales;\n\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\n\npublic class Filosofo extends Thread {\n\n    private Tenedor izquierdo;\n    private Tenedor derecho;\n    private final int id;\n    private final int factorPeso;\n    private Random rand = new Random(47);\n\n    private void pausa() throws InterruptedException {\n        if (factorPeso == 0) {\n            return;\n        }\n        TimeUnit.MILLISECONDS.sleep(rand.nextInt(factorPeso * 250));\n    }\n\n    public Filosofo(Tenedor izquierdo, Tenedor derecho, int id, int peso) {\n        this.izquierdo = izquierdo;\n        this.derecho = derecho;\n        this.id = id;\n        factorPeso = peso;\n    }\n\n    public void run() {\n        try {\n            while (!Thread.interrupted()) {\n                System.out.println(this + \" \" + \"pensando\");\n                pausa();\n                System.out.println(this + \" \" + \"cogiendo tenedor derecho\");\n                derecho.tomar();\n                System.out.println(this + \" \" + \"cogiendo tenedor izquierdo\");\n                izquierdo.tomar();\n                System.out.println(this + \" \" + \"comiendo\");\n                pausa();\n                derecho.dejar();\n                izquierdo.dejar();\n            }\n        } catch (InterruptedException e) {\n            System.out.println(this + \" \" + \"saliendo por una interrupci\u00f3n\");\n        }\n    }\n\n    public String toString() {\n        return \"Fil\u00f3sofo \" + (id+1);\n    }\n\n}\n</code></pre> <pre><code>package filosofosComensales;\n\npublic class App\n{\n    public static void main( String[] args )\n    {\n        int peso = 5;\n        int numero = 5;\n        Tenedor[] tenedores = new Tenedor[numero];\n        Filosofo[] filosofos = new Filosofo[numero];\n        for (int i = 0; i &lt; numero; i++) {\n            tenedores[i] = new Tenedor();\n        }\n        for (int i = 0; i &lt; numero; i++) {\n            // Solo funciona con notify, no con notifyAll\n            filosofos[i] = new Filosofo(tenedores[i], tenedores[(i+1)%numero],i,peso);\n            filosofos[i].start();\n\n            // Para romper el interbloqueo circular si usamos notifyAll\n            /*\n             if (i &lt; (numero - 1)) {\n                filosofos[i] = new Filosofo(tenedores[i], tenedores[i+1],i,peso);\n                filosofos[i].start();\n            }else{\n               filosofos[i] = new Filosofo(tenedores[0], tenedores[i],i,peso);\n               filosofos[i].start();\n            }\n            */\n\n        }\n    }\n}\n</code></pre> <p>En la implementaci\u00f3n actual, todos los fil\u00f3sofos intentan tomar primero el tenedor derecho y luego el izquierdo. Esto puede causar un interbloqueo si cada fil\u00f3sofo toma su tenedor derecho y queda esperando indefinidamente por el tenedor izquierdo, que est\u00e1 en uso por su vecino. Rompiendo la simetr\u00eda a la hora de coger los tenedores nos supondr\u00eda eliminar la posibilidad de interbloqueo.</p>"},{"location":"ud2/#otra-solucion","title":"Otra soluci\u00f3n","text":"<pre><code>package filosofosComensalesV2;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class Mesa {\n\n    private boolean[] tenedores;\n\n    public Mesa(int numTenedores){\n        this.tenedores = new boolean[numTenedores];\n    }\n\n    public int tenedorIzquierda(int i){\n        return i;\n    }\n\n    public int tenedorDerecha(int i){\n        if(i == 0){\n            return this.tenedores.length - 1;\n        }else{\n            return i - 1;\n        }\n    }\n\n    public synchronized void cogerTenedores(int comensal){\n\n        while(tenedores[tenedorIzquierda(comensal)] || tenedores[tenedorDerecha(comensal)]){\n            try {\n                wait();\n            } catch (InterruptedException ex) {\n                Logger.getLogger(Mesa.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n\n        tenedores[tenedorIzquierda(comensal)] = true;\n        tenedores[tenedorDerecha(comensal)] = true;\n    }\n\n    public synchronized void dejarTenedores(int comensal){\n        tenedores[tenedorIzquierda(comensal)] = false;\n        tenedores[tenedorDerecha(comensal)] = false;\n        notifyAll();\n    }\n\n}\n</code></pre> <pre><code>package filosofosComensalesV2;\n\npublic class Filosofo extends Thread {\n\n    private Mesa mesa;\n    private int comensal;\n    private int indiceComensal;\n\n    public Filosofo(Mesa m, int comensal){\n        this.mesa = m;\n        this.comensal = comensal;\n        this.indiceComensal = comensal - 1;\n    }\n\n    public void run(){\n\n        while(true){\n            this.pensando();\n            this.mesa.cogerTenedores(this.indiceComensal);\n            this.comiendo();\n            System.out.println(\"Filosofo \" + comensal +  \" deja de comer, tenedores libres \" + (this.mesa.tenedorIzquierda(this.indiceComensal) + 1) + \", \" + (this.mesa.tenedorDerecha(this.indiceComensal) + 1) );\n            this.mesa.dejarTenedores(this.indiceComensal);\n        }\n\n    }\n\n    public void pensando(){\n\n        System.out.println(\"Filosofo \" + comensal + \" esta pensando\");\n        try {\n            sleep((long) (Math.random() * 4000));\n        } catch (InterruptedException ex) { }\n\n    }\n\n    public void comiendo(){\n        System.out.println(\"Filosofo \" + comensal + \" esta comiendo\");\n        try {\n            sleep((long) (Math.random() * 4000));\n        } catch (InterruptedException ex) { }\n    }\n\n}\n</code></pre> <pre><code>package filosofosComensalesV2;\n\npublic class App {\n\n    public static void main(String[] args) {\n        Mesa m = new Mesa(5);\n        for (int i = 1; i &lt;= 5; i++) {\n            Filosofo f = new Filosofo(m, i);\n            f.start();\n        }\n    }\n}\n</code></pre>"},{"location":"ud2/#el-problema-de-los-lectores-escritores","title":"El problema de los lectores-escritores","text":"<p>Este problema aborda c\u00f3mo m\u00faltiples hilos pueden acceder concurrentemente a un recurso compartido, donde algunos hilos pueden leer el recurso y otros pueden escribir en \u00e9l, garantizando la sincronizaci\u00f3n adecuada para evitar condiciones de carrera o inconsistencias de datos.</p> <p>A continuaci\u00f3n se muestra una posible soluci\u00f3n.</p> <pre><code>package lectoresEscritores;\n\npublic class RecursoLectorEscritor {\n\n    private int lectores = 0;\n    private int escritores = 0;\n    private int peticionesEscritura = 0;\n\n    private int dato=0; // Dato a leer y escribir\n\n\n    public synchronized void leer(int lector) {\n        // Si hay alguien escribiendo o peticiones pendientes por escribir\n        while(escritores &gt; 0 || peticionesEscritura &gt; 0){\n            try {\n                wait();\n            } catch (InterruptedException ex) {\n                System.err.println(\"Leer: Error en get -&gt; \" + ex.getMessage());\n            }\n        }\n        lectores++;\n        System.out.println(\"Lector \" + lector + \" empieza a leer.\");\n        int DELAY = 5000;\n        try{\n            Thread.sleep((int) (Math.random() * DELAY));\n        }\n        catch (InterruptedException e) {\n            System.err.println(\"Error en la espera del lector\");\n        }\n        System.out.println(\"Lector \" + lector + \" ha leido el dato: \" + this.dato);\n        System.out.println(\"Lector \" + lector + \" termina de leer.\");\n        lectores--;\n        notifyAll();\n    }\n\n    public synchronized void escribir(int escritor) {\n        // Generamos na petici\u00f3n de escritura\n        peticionesEscritura++;\n        // Mientras haya un lector o una petici\u00f3n pendiente\n        while(lectores &gt; 0 || escritores &gt; 0){\n            try {\n                wait(); // Esperamos\n            } catch (InterruptedException ex) {\n                System.err.println(\"Escribir: Error en get -&gt; \" + ex.getMessage());\n            }\n        }\n        peticionesEscritura--;\n        escritores++;\n        System.out.println(\"Escritor \" + escritor + \" comienza a escribir.\");\n\n        int DELAY = 5000;\n        try{\n            Thread.sleep((int) (Math.random() * DELAY));\n        }catch (InterruptedException e) {\n            System.err.println(\"Error en la espera del escritor\");\n        }\n        this.dato++;\n        System.out.println(\"Escritor \" + escritor + \" ha escrito en el dato: \" + this.dato);\n        System.out.println(\"Escritor \" + escritor + \" termina de escribir.\");\n        escritores--;\n        // Despertamos a todos\n        notifyAll();\n    }\n\n}\n</code></pre> <pre><code>package lectoresEscritores;\n\nimport java.util.Random;\n\npublic class Lector extends Thread{\n    int veces;\n    int lector;\n    RecursoLectorEscritor RW;\n    private final Random generator = new Random();\n\n    public Lector(int lector, int veces, RecursoLectorEscritor RW) {\n        this.veces = veces;\n        this.lector= lector;\n        this.RW = RW;\n    }\n    @Override\n    public void run() {\n        for (int i = 0; i&lt;veces; i++) {\n            try {\n                Thread.sleep(generator.nextInt(500));\n            }catch (InterruptedException e) {\n                System.err.println(\"Error en lector\");\n            }\n            RW.leer(lector);\n        }\n    }\n\n}\n</code></pre> <pre><code>package lectoresEscritores;\n\nimport java.util.Random;\n\npublic class Escritor extends Thread {\n    int veces;\n    int escritor;\n    RecursoLectorEscritor RW;\n    private final Random generator = new Random();\n\n    public Escritor(int escritor, int veces, RecursoLectorEscritor RW) {\n        this.escritor=escritor;\n        this.veces = veces;\n        this.RW = RW;\n    }\n    @Override\n    public void run() {\n        for (int i = 0; i&lt;veces; i++) {\n            try {\n                Thread.sleep(generator.nextInt(500));\n            } catch (InterruptedException e) {\n                System.err.println(\"Error en escritor\");\n            }\n            RW.escribir(escritor);\n        }\n    }\n}\n</code></pre> <pre><code>package lectoresEscritores;\n\npublic class App {\n    public static void main( String[] args )\n    {\n        RecursoLectorEscritor RW = new RecursoLectorEscritor();\n        int veces = 7;\n        Lector l1= new Lector(1,veces, RW);\n        l1.start();\n        Lector l2= new Lector(2,veces, RW);\n        l2.start();\n        Escritor e1= new Escritor(1,veces, RW);\n        e1.start();\n        Escritor e2= new Escritor(2,veces, RW);\n        e2.start();\n    }\n\n}\n</code></pre>"},{"location":"ud2/#ejercicio-para-clase-el-problema-de-los-misioneros-y-los-canibales","title":"Ejercicio para clase: el problema de los misioneros y los can\u00edbales","text":"<p>Un r\u00edo es compartido por misioneros y can\u00edbales, solo se utiliza un bote de tres espacios para cruzar el r\u00edo. Con el fin de garantizar la integridad de los misioneros, no se pueden colocar dos can\u00edbales y un misionero juntos en el mismo viaje, las dem\u00e1s combinaciones son v\u00e1lidas. Cada personaje est\u00e1 representado por un hilo, Can\u00edbal y Misionero. Se sugiere la creaci\u00f3n de dos m\u00e9todos LlegaM() y LlegaC() que llaman los hilos respectivamente, ambos se encargan de realizar la sincronizaci\u00f3n. Puede existir otro m\u00e9todo denominado Cruzar() que se llama cuando el bote est\u00e1 listo para cruzar.</p>"},{"location":"ud3/","title":"Unidad 3 - Programaci\u00f3n de mecanismos de comunicaci\u00f3n en red con sockets","text":""},{"location":"ud3/#modelos-de-comunicaciones-entre-procesos","title":"Modelos de comunicaciones entre procesos","text":"<p>En esta unidad did\u00e1ctica se van a desarrollar aplicaciones concurrentes apropiadas para sistemas distribuidos. En ellos, los procesos se ejecutan en distintos procesadores de sistemas independientes, y se comunican a trav\u00e9s de una red mediante protocolos est\u00e1ndares de comunicaciones.</p> <p>Podemos encontrar dos modelos de sistemas distribuidos:</p> <ul> <li>Cliente servidor.</li> <li>Entre iguales (P2P).</li> </ul> <p></p>"},{"location":"ud3/#modelo-tcpip","title":"Modelo TCP/IP","text":"<p>El modelo TCP/IP es una arquitectura de red compleja que integra m\u00faltiples protocolos organizados en capas. Sin lugar a dudas, es la arquitectura m\u00e1s utilizada a nivel mundial, ya que constituye la base de Internet y es ampliamente empleada en diversas versiones de sistemas operativos.</p> <p>La arquitectura TCP/IP se desarroll\u00f3 dise\u00f1ando inicialmente los protocolos y luego estructur\u00e1ndolos en capas dentro de la arquitectura. Por esta raz\u00f3n, TCP/IP es frecuentemente referida como una pila de protocolos.</p> <p>La arquitectura TCP/IP es la m\u00e1s utilizada hoy en d\u00eda. Se utiliza tanto en redes de \u00e1rea extensa como en redes de \u00e1rea local. Fue creada a principios de los a\u00f1os 70 por el Departamento de Defensa de los Estados Unidos. El objetivo era crear una arquitectura de red con las siguientes caracter\u00edsticas:</p> <ul> <li>Permitir interconectar redes distintas aunque utilicen distinta tecnolog\u00eda.</li> <li>Ser tolerante a fallos. Mantener las comunicaciones a pesar de que se destruya parte de la red.</li> <li>Suministrar los servicios de comunicaci\u00f3n m\u00e1s utilizados en redes de ordenadores. Finalmente, este proyecto deriv\u00f3 en lo que hoy conocemos como Internet.</li> </ul> <p>Los niveles o capas de este modelo son los siguientes:</p> <ol> <li> <p>Capa de acceso a la red: El modelo TCP/IP no proporciona detalles espec\u00edficos sobre esta capa; simplemente establece que debe existir un protocolo que conecte el dispositivo a la red. Esto se debe a que TCP/IP fue dise\u00f1ado para funcionar sobre diversas redes, por lo que esta capa depende de la tecnolog\u00eda utilizada y no est\u00e1 predefinida. Es importante considerar que una red puede estar interconectada mediante diferentes tipos de cables o de forma inal\u00e1mbrica. En este nivel se definen los protocolos asociados a los dispositivos de bajo nivel para cada una de estas tecnolog\u00edas.</p> </li> <li> <p>Capa de Internet o red: Esta es la capa m\u00e1s esencial de la arquitectura. Su funci\u00f3n es permitir que los dispositivos env\u00eden paquetes de informaci\u00f3n a la red y que estos viajen de forma independiente hasta su destino. Durante el recorrido, los paquetes pueden atravesar diferentes redes y pueden llegar desordenados. Esta capa no se encarga de reordenar los mensajes en el destino. El protocolo m\u00e1s importante en este nivel es el IP (Internet Protocol), aunque tambi\u00e9n existen otros protocolos.</p> </li> <li> <p>Capa de transporte: Su misi\u00f3n es establecer una comunicaci\u00f3n confiable entre el origen y el destino, similar a la capa de transporte en el modelo OSI. Dado que las capas inferiores no gestionan el control de errores ni el ordenamiento de los mensajes, esta capa asume esas responsabilidades. En este nivel se han definido varios protocolos, destacando TCP (Transmission Control Protocol) y UDP (User Datagram Protocol).</p> </li> <li> <p>Capa de aplicaci\u00f3n: Al igual que en el modelo OSI, esta capa incluye todos los protocolos de alto nivel que utilizan las aplicaciones para comunicarse. Aqu\u00ed se encuentran protocolos como FTP para la transferencia de archivos, HTTP que utilizan los navegadores para acceder a p\u00e1ginas web, y los protocolos para la gesti\u00f3n del correo electr\u00f3nico, entre otros.</p> </li> </ol> <p></p> <p></p>"},{"location":"ud3/#direcciones-puertos-y-sockets","title":"Direcciones, puertos y sockets","text":""},{"location":"ud3/#direcciones-ip","title":"Direcciones IP","text":"<p>Cada host o equipo que est\u00e1 en una red TCP/IP tiene asignada na direcci\u00f3n IP \u00fanica consistente en un n\u00famero de red y un n\u00famero de host. El n\u00famero de red sirve para identificar la red en la que se encuentran los hosts. El n\u00famero de host sirve para identificar a un host dentro de una red.</p> <ul> <li>Las direcciones Ipv4 son direcciones de 32-bits. La direcci\u00f3n IP se agrupa en cuatro octetos o bytes (grupos de 8 bits) y se representan usando el valor en notaci\u00f3n decimal de cada uno de los bytes, separados por puntos. El valor m\u00ednimo para cada octeto es 0 y el valor m\u00e1ximo es 255. Por ejemplo: 192.168.0.100</li> <li>Las direcciones IPv6 est\u00e1 formadas por 64-bits para la direcci\u00f3n de red o prefijo de red, y otros 64 bits para el n\u00famero de host. Las direcciones IPv6 se escriben como 8 grupos de 4 d\u00edgitos hexadecimales separados por el car\u00e1cter ':'. Un grupo que s\u00f3lo tiene ceros puede ser omitido. Los ceros iniciales tambi\u00e9n se pueden omitir. Por ejemplo: 2001:0db8::1428:57ab</li> </ul>"},{"location":"ud3/#puertos","title":"Puertos","text":"<p>Cuando una aplicaci\u00f3n que se est\u00e1 ejecutando en un equipo quiere comunicarse con otra aplicaci\u00f3n de otro equipo, se identifica a s\u00ed misma con un n\u00famero de 16 bits, que denominamos puerto. Ese identificador es usado por los protocolos de la capa de transporte (TCP or UDP) para entregar los mensajes a la aplicaci\u00f3n correcta dentro del equipo. Los puertos van de 0 a 65535, y se agrupan en tres rangos.</p> Grupo de puertos Rango de puertos Descripci\u00f3n Puertos bien conocidos o puertos del sistema 0 - 1023 Los usan los protocolos est\u00e1ndar y los servicios del SO Puertos registrados 1024 - 49151 Reservados por empresas y organizaciones para sus propios servicios Puertos ef\u00edmeros 49152 - 65535 De libre disposici\u00f3n y uso para aplicaciones cliente y servidor"},{"location":"ud3/#sockets","title":"Sockets","text":"<p>Un socket es un punto final de conexi\u00f3n en una comunicaci\u00f3n entre procesos y est\u00e1 formado por una combinaci\u00f3n \u00fanica de direcci\u00f3n IP, puerto y protocolo de transporte (normalmente TCP).</p> <p>Cuando una aplicaci\u00f3n cliente quiere comunicarse con un servidor, el SO crea el socket que usar\u00e1 el cliente para recibir la informaci\u00f3n del servidor. La combinaci\u00f3n \u00fanica de Protocolo + puerto + IP permite que este extremo de la comunicaci\u00f3n sea accesible desde el servidor, de manera inequ\u00edvoca y asegura que los datos los recibe el proceso que los solicit\u00f3.</p> <p>El servidor tiene su propio socket para comunicarse con el cliente, y una conexi\u00f3n establecida entre el cliente y el servidor usando los dos extremos (los dos sockets cliente &lt;--&gt; servidor). Las aplicaciones intercambian informaci\u00f3n escribiendo o leyendo en los sockets que han creado.</p> <p>La conexi\u00f3n usada por un cliente est\u00e1 formada por dos sockets, uno en el lado del cliente y otro en el lado del servidor. Por lo tanto, la conexi\u00f3n puede identificarse con una tupla formada por cuatro n\u00famero: la direcci\u00f3n IP de origen, la direcci\u00f3n IP de destino, el puerto de origen y el puerto de destino.</p>"},{"location":"ud3/#tcp-y-udp","title":"TCP y UDP","text":"<p>El Protocolo de Control de Transmisi\u00f3n (Transmission Control Protocol o TCP) es un protocolo de la capa de transporte, por lo que su trabajo consiste en permitir la transmisi\u00f3n de paquetes de datos. TCP garantiza que los paquetes se entregan al destinatario de forma ordenada, completa y correcta. Se utiliza para la transferencia de informaci\u00f3n cuando es necesario garantizar la integridad de esta, como, por ejemplo, en la web o en la transferencia de archivos con FTP. Este protocolo est\u00e1 basado en conexiones, por lo que cuando se establece una comunicaci\u00f3n entre dos nodos de la red se crea un cana estable a trav\u00e9s del cual se env\u00eda la informaci\u00f3n.</p> <p>El Protocolo de Datagramas de Usuario (User Datagram Protocol o UDP) es, al igual que TCP, un protocolo de la capa de transporte que posibilita la transmisi\u00f3n de paquetes de datos. Al contrario que TCP, UDP no est\u00e1 basado en conexiones. Esto significa que cada paquete se env\u00eda sin que exista un canal de comunicaci\u00f3n abierto con el receptor, por lo que cada paquete podr\u00e1 alcanzar su destino por un camino distinto.</p> <p>Por esta raz\u00f3n, entre otras, los paquetes de datos UDP (conocidos como datagramas) pueden no llegar a su destino en el mismo orden en el que se enviaron o incluso pueden \u201cperderse\u201d y no alcanzarlo. Este comportamiento sin garant\u00edas puede resultar llamativo, pero tiene sus ventajas. Al no tener que garantizar la entrega ni el orden, la comunicaci\u00f3n es mucho m\u00e1s r\u00e1pida que cuando se usa el protocolo TCP, a cambio de aceptar la p\u00e9rdida de algunos paquetes de informaci\u00f3n. Esta caracter\u00edstica hace que UDP sea el protocolo m\u00e1s adecuado para algunas aplicaciones en las que la rapidez prevalece sobre la fiabilidad, como las transmisiones de voz o de v\u00eddeo en tiempo real.</p>"},{"location":"ud3/#clases-java-para-comunicaciones-de-red","title":"Clases Java para comunicaciones de red","text":"<p>El paquete java.net proporciona clases que permiten llevar a cabo comunicaciones entre procesos utilizando los protocolos est\u00e1ndares de la familia de TCP/IP. Puede dividirse en dos secciones.</p> <ul> <li>Clases de bajo nivel, que permiten representar las principales entidades de los niveles de enlace, red y transporte.</li> <li>Clases de alto nivel, relacionadas con protocolos de nivel de aplicaci\u00f3n, que se ver\u00e1n en la siguiente unidad de trabajo.</li> </ul> <p></p>"},{"location":"ud3/#clases-java-para-interfaces-de-red","title":"Clases Java para interfaces de red","text":"<p>Las interfaces de red presentes en el sistema se pueden mostrar con los comandos ifconfig en Linux o ipconfig en Windows.</p> <p>La clase NetworkInterface tiene m\u00e9todos est\u00e1ticos que permiten obtener una enumeraci\u00f3n de todas las interfaces de red existentes en el sistema. Una NetworkInterface puede tener m\u00e1s de una configuraci\u00f3n IP asociada, y normalmente al menos una para IPv4 y otra para IPv6. Con distintos m\u00e9todos de la clase, se pueden obtener para cada una objetos de tipo InterfaceAddress e InetAddress.</p> <p>La clase InterfaceAddress proporciona informaci\u00f3n adicional a InetAddress como, por ejemplo, la longitud de la m\u00e1scara de red y, para una direcci\u00f3n IPv4, la direcci\u00f3n de broadcast de la red a la que pertenece.</p>"},{"location":"ud3/#ejemplo-de-networkinterface","title":"Ejemplo de NetworkInterface","text":"<pre><code>package direccionamiento;\n\nimport java.net.InetAddress;\nimport java.net.InterfaceAddress;\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Enumeration;\n\npublic class NetworkInterfaceExample {\n\n    public static void main(String[] args) throws SocketException,\n            UnknownHostException {\n\n        // getNetworkInterfaces() returns a list of all interfaces\n        // present in the system.\n        ArrayList&lt;NetworkInterface&gt; interfaces = Collections.list(\n                NetworkInterface.getNetworkInterfaces());\n\n        System.out.println(\"Information about present Network Interfaces...\\n\");\n        for (NetworkInterface iface : interfaces) {\n            // isUp() method used for checking whether the interface in process\n            // is up and running or not.\n            if (iface.isUp()) {\n                // getName() method\n                System.out.println(\"Interface Name: \" + iface.getName());\n\n                // getDisplayName() method\n                System.out.println(\"Interface display name: \" + iface.getDisplayName());\n\n                // getHardwareAddress() method\n                System.out.println(\"Hardware Address: \"\n                        + Arrays.toString(iface.getHardwareAddress()));\n\n                // getParent() method\n                System.out.println(\"Parent: \" + iface.getParent());\n\n                // getIndex() method\n                System.out.println(\"Index: \" + iface.getIndex());\n                // Interface addresses of the network interface\n                System.out.println(\"\\tInterface addresses: \");\n\n                // getInterfaceAddresses() method\n                for (InterfaceAddress addr : iface.getInterfaceAddresses()) {\n                    System.out.println(\"\\t\\t\" + addr.getAddress().toString());\n                }\n                // Interface addresses of the network interface\n                System.out.println(\"\\tInetAddresses associated with this interface: \");\n\n                // getInetAddresses() method returns list of all\n                // addresses currently bound to this interface\n                Enumeration&lt;InetAddress&gt; en = iface.getInetAddresses();\n                while (en.hasMoreElements()) {\n                    System.out.println(\"\\t\\t\" + en.nextElement().toString());\n                }\n\n                // getMTU() method\n                System.out.println(\"\\tMTU: \" + iface.getMTU());\n\n                // getSubInterfaces() method\n                System.out.println(\"\\tSubinterfaces: \"\n                        + Collections.list(iface.getSubInterfaces()));\n\n                // isLoopback() method\n                System.out.println(\"\\tis loopback: \" + iface.isLoopback());\n\n                // isVirtual() method\n                System.out.println(\"\\tis virtual: \" + iface.isVirtual());\n\n                // isPointToPoint() method\n                System.out.println(\"\\tis point to point: \" + iface.isPointToPoint());\n\n                // supportsMulticast() method\n                System.out.println(\"Supports Multicast: \" + iface.supportsMulticast());\n\n            }\n        }\n\n        // getByIndex() method returns network interface\n        // with the specified index\n        NetworkInterface nif = NetworkInterface.getByIndex(1);\n\n        // toString() method is used to display textual\n        // information about this network interface\n        System.out.println(\"Network interface 1: \" + nif.toString());\n\n        // getByName() method returns network interface\n        // with the specified name\n        NetworkInterface nif2 = NetworkInterface.getByName(\"eth0\");\n        InetAddress ip = InetAddress.getByName(\"localhost\");\n\n        // getbyInetAddress() method\n        NetworkInterface nif3 = NetworkInterface.getByInetAddress(ip);\n        System.out.println(\"\\nlocalhost associated with: \" + nif3);\n    }\n}\n</code></pre> <p>https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/NetworkInterface.html</p>"},{"location":"ud3/#clases-java-para-direcciones-ip-y-resolucion-de-nombres","title":"Clases Java para direcciones IP y resoluci\u00f3n de nombres","text":"<p>La clase InterfaceAddress representa la configuraci\u00f3n IP de una interfaz. Esto incluye la direcci\u00f3n IP y par\u00e1metros adicionales, a saber:</p> <ul> <li>Longitud de la m\u00e1scara de red, es decir, n\u00famero de bits que en la direcci\u00f3n IP especifican la red.</li> <li>Si se trata de una direcci\u00f3n IPv4, direcci\u00f3n de broadcast para la red a la que pertenece la interfaz.</li> </ul> <p>https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InterfaceAddress.html</p>"},{"location":"ud3/#ejemplo-interfaceaddress","title":"Ejemplo InterfaceAddress","text":"<pre><code>package direccionamiento;\n\nimport java.net.InterfaceAddress;\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.util.List;\n\npublic class InterfaceaddressExample\n{\n    public static void main(String[] args) throws SocketException\n    {\n        // Modify according to your system\n        NetworkInterface nif = NetworkInterface.getByIndex(1);\n        List&lt;InterfaceAddress&gt; list = nif.getInterfaceAddresses();\n\n        for (InterfaceAddress iaddr : list)\n        {\n            // getAddress() method\n            System.out.println(\"getAddress() : \" + iaddr.getAddress());\n\n            // getBroadcast() method\n            System.out.println(\"getBroadcast() : \" + iaddr.getBroadcast());\n\n            // getNetworkPrefixLength() method\n            System.out.println(\"PrefixLength : \" + iaddr.getNetworkPrefixLength());\n\n            // hashCode() method\n            System.out.println(\"Hashcode : \" + iaddr.hashCode());\n\n            // toString() method\n            System.out.println(\"toString() : \" + iaddr.toString());\n        }\n    }\n}\n</code></pre> <p>La clase InetAddress representa una direcci\u00f3n IP. Tiene dos subclases para representar direcciones IPv4 e IPv6: Inet4Adress e Inet6Adress.</p> <p>La clase InetAddress tiene m\u00e9todos est\u00e1ticos que realizan resoluci\u00f3n de nombres. Es decir, dado un nombre, permiten obtener la direcci\u00f3n IP asociada. Tambi\u00e9n tiene m\u00e9todos que realizan resoluci\u00f3n inversa de nombres. Es decir, que permiten obtener un nombre de host a partir de su direcci\u00f3n IP.</p> <p>https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InetAddress.html</p>"},{"location":"ud3/#ejemplo-inetaddress","title":"Ejemplo InetAddress","text":"<pre><code>package direccionamiento;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\nclass InetAddressExample {\n\n    public static void main(String[] args)\n            throws UnknownHostException {\n        // To get and print InetAddress of Local Host\n        InetAddress address1 = InetAddress.getLocalHost();\n        System.out.println(\"InetAddress of Local Host : \"\n                + address1);\n\n        // To get and print InetAddress of Named Host\n        InetAddress address2\n                = InetAddress.getByName(\"45.22.30.39\");\n        System.out.println(\"InetAddress of Named Host : \"\n                + address2);\n\n        // To get and print ALL InetAddresses of Named Host\n        InetAddress address3[]\n                = InetAddress.getAllByName(\"172.19.25.29\");\n        for (int i = 0; i &lt; address3.length; i++) {\n            System.out.println(\n                    \"ALL InetAddresses of Named Host : \"\n                    + address3[i]);\n        }\n\n        // To get and print InetAddresses of\n        // Host with specified IP Address\n        byte IPAddress[] = {125, 0, 0, 1};\n        InetAddress address4\n                = InetAddress.getByAddress(IPAddress);\n        System.out.println(\n                \"InetAddresses of Host with specified IP Address : \"\n                + address4);\n\n        // To get and print InetAddresses of Host\n        // with specified IP Address and hostname\n        byte[] IPAddress2\n                = {105, 22, (byte) 223, (byte) 186};\n        InetAddress address5 = InetAddress.getByAddress(\n                \"gfg.com\", IPAddress2);\n        System.out.println(\n                \"InetAddresses of Host with specified IP Address and hostname : \"\n                + address5);\n    }\n}\n</code></pre>"},{"location":"ud3/#clases-java-para-sockets-de-udp","title":"Clases Java para sockets de UDP","text":"<p>La interfaz Java que da soporte a sockets UDP est\u00e1 constituida por las clases DatagramPacket y DatagramSocket.</p> <p>DatagramSocket es  la clase utilizada para realizar el env\u00edo y la recepci\u00f3n de los datos. A diferencia de los sockets TCP, esta clase no es la encargada de gestionar las direcciones ni de realizar la conexi\u00f3n, s\u00f3lo se encarga de transportar los datos del origen al destino. Lo \u00fanico que se hace es enviar los datos, mediante la creaci\u00f3n de un socket y utilizando los m\u00e9todos de env\u00edo y recepci\u00f3n apropiados. Esta clase proporciona los m\u00e9todos send y receive.</p> <p></p> <p>Por su parte, DatagramPackets es la encargada de incluir la informaci\u00f3n que se quiere enviar recibir y la informaci\u00f3n de direccionamiento, es decir, la direcci\u00f3n a la que se quiere enviar la informaci\u00f3n que contiene. DatagramPacket contiene la informaci\u00f3n relevante. Cuando se desea recibir un datagrama, \u00e9ste deber\u00e1 almacenarse bien en un buffer o un array de bytes. Y cuando preparamos un datagrama para ser enviado, el DatagramPacket no s\u00f3lo debe tener la informaci\u00f3n, sino que adem\u00e1s debe tener la direcci\u00f3n IP y el puerto de destino.</p> <p></p> <p>El protocolo de transporte UDP no es orientado a conexi\u00f3n. Solo permite el env\u00edo de paquetes de datos individuales, llamados datagramas. Estos pueden llegar en orden distinto al orden en que se enviaron, e incluso no llegar.</p> <p>El conjunto de un datagrama de UDP encapsulado en un datagrama de IP contiene, adem\u00e1s de los datos que se env\u00edan del proceso de origen al de destino, la direcci\u00f3n IP y puerto de origen y la direcci\u00f3n IP y puerto de destino. </p> <p></p>"},{"location":"ud3/#cliente-udp","title":"Cliente UDP","text":"<p>La forma general de implementar un cliente ser\u00e1:</p> <ol> <li>El cliente crear\u00e1 un socket para comunicarse con el servidor. Para enviar datagramas necesita conocer su IP y el puerto por el que escucha.</li> <li>Utilizar\u00e1 el m\u00e9todo send() del socket para enviar la petici\u00f3n en forma de datagrama.<ul> <li>La informaci\u00f3n se env\u00eda en un objeto de tipo DatagramPacket.</li> <li>El DatagramPacket almacena el contenido del mensaje en un array de bytes.</li> </ul> </li> <li>Permanece a la espera de recibir respuesta.</li> <li>El cliente recibe la respuesta del servidor mediante el m\u00e9todo receive() del socket.<ul> <li>La informaci\u00f3n se recibe en un objeto de tipo DatagramPacket.</li> <li>El DatagramPacket almacena el contenido del mensaje en un array de bytes.</li> </ul> </li> <li>Cerrar y liberar los recursos.</li> </ol>"},{"location":"ud3/#servidor-udp","title":"Servidor UDP","text":"<ol> <li>El servidor crea un socket asociado a un puerto local para escuchar peticiones de clientes.</li> <li>Permanece a la espera de recibir peticiones.</li> <li>El servidor recibe las peticiones mediante el m\u00e9todo receive() del socket.<ul> <li>La informaci\u00f3n se recibe en un objeto de tipo DatagramPacket.</li> <li>El DatagramPacket almacena el contenido del mensaje en un array de bytes.</li> </ul> </li> <li>En el datagrama recibido va incluido adem\u00e1s del mensaje, el puerto y la IP del cliente emisor de la petici\u00f3n; lo que le permite al servidor conocer la direcci\u00f3n del emisor del datagrama. Utilizando el m\u00e9todo send() del socket puede enviar la respuesta al cliente emisor.</li> <li>El servidor permanece a la espera de recibir m\u00e1s peticiones.</li> <li>Cerrar y liberar los recursos.</li> </ol>"},{"location":"ud3/#clienteservidor-udp","title":"Cliente/Servidor UDP","text":""},{"location":"ud3/#ejemplo-clienteservidor-con-udp","title":"Ejemplo cliente/servidor con UDP","text":"<p>ServidorUDP.java</p> <pre><code>package udp;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class ServidorUDP {\n\n    public static void main(String[] argv) throws Exception {\n    // Buffer para recibir el datagrama\n        byte[] bufer = new byte[1024];\n    // El Socket del servidor se asocia a un puerto para que los clientes\n    // puedan enviar peticiones.\n        DatagramSocket socket = new DatagramSocket(12345);\n    // Se espera la llegada de un DATAGRAMA\n    // Al igual que con TCP, esta llamada a receive es bloqueante\n    // y es la que tiene que marcar la sincronizaci\u00f3n entre lecturas y\n    // escrituras de las app cliente / servidor\n        System.out.println(\"Esperando Datagrama ................\");\n    // Se crea el objeto que almacenar\u00e1 el mensaje enviado por el cliente\n        DatagramPacket datagramaRecibido = new DatagramPacket(bufer, bufer.length);\n    // Se espera el mensaje y se le pasa el datagrama para que lo almacene ah\u00ed\n        socket.receive(datagramaRecibido);\n        String mensajeRecibido = new String(datagramaRecibido.getData());\n    //Informaci\u00f3n recibida\n        System.out.println(\"N\u00famero de Bytes recibidos: \" + datagramaRecibido.getLength());\n        System.out.println(\"Contenido del Paquete : \" + mensajeRecibido.trim());\n        System.out.println(\"Puerto origen del mensaje: \" + datagramaRecibido.getPort());\n        System.out.println(\"IP de origen : \" + datagramaRecibido.getAddress().getHostAddress());\n        System.out.println(\"Puerto destino del mensaje:\" + socket.getLocalPort());\n    // Liberamos los recursos\n        socket.close();\n    }\n}\n</code></pre> <p>ClienteUDP.java</p> <pre><code>package udp;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ClienteUDP {\n\n    public static void main(String[] argv) throws Exception {\n    // IP y puerto al que se env\u00eda el Datagrama\n        InetAddress destino = InetAddress.getLocalHost();\n        int port = 12345;\n    // Buffer para recibir el datagrama\n        byte[] buffer = new byte[1024];\n    // El mensaje a enviar en el Datagrama se convierte a bytes\n        String mensajeEnviado = \"Enviando Saludos !!\";\n        buffer = mensajeEnviado.getBytes(); //codifico String a bytes\n    // Se preparara el DatagramPacket que se va a enviar\n        DatagramPacket datagramaEnviado = new DatagramPacket(buffer, buffer.length, destino, port);\n    // En este caso, especificamos un puerto, aunque podr\u00edamos dejarlo para\n    // que el SO asigne uno libre\n        DatagramSocket socket = new DatagramSocket(34567);\n        System.out.println(\"Host destino : \" + destino.getHostName());\n        System.out.println(\"IP Destino : \" + destino.getHostAddress());\n        System.out.println(\"Puerto local del socket: \" + socket.getLocalPort());\n        System.out.println(\"Puerto al que envio: \" + datagramaEnviado.getPort());\n    // Env\u00edo del Datagrama\n        socket.send(datagramaEnviado);\n    // Cierre y liberaci\u00f3n de recursos\n        socket.close();\n    }\n}\n</code></pre>"},{"location":"ud3/#otro-ejemplo-de-clienteservidor-con-udp","title":"Otro ejemplo de cliente/servidor con UDP","text":"<p>ServidorUDP2.java</p> <pre><code>package udp2;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ServidorUDP2 {\n\n    public static void main(String args[]) throws Exception {\n    //Puerto por el que escucha el servidor: 9876\n        DatagramSocket serverSocket = new DatagramSocket(9876);\n        byte[] recibidos = new byte[1024];\n        byte[] enviados = new byte[1024];\n        String cadena;\n        while (true) {\n            System.out.println(\"Esperando datagrama.....\");\n    //RECIBO DATAGRAMA\n            recibidos = new byte[1024];\n            DatagramPacket paqRecibido = new DatagramPacket(recibidos, recibidos.length);\n            serverSocket.receive(paqRecibido);\n            cadena = new String(paqRecibido.getData());\n    //DIRECCION ORIGEN\n            InetAddress IPOrigen = paqRecibido.getAddress();\n            int puerto = paqRecibido.getPort();\n            System.out.println(\"\\tOrigen: \" + IPOrigen + \":\" + puerto);\n            System.out.println(\"\\tMensaje recibido: \" + cadena.trim());\n    //CONVERTIR CADENA A MAY\u00daSCULA\n            String mayuscula = cadena.trim().toUpperCase();\n            enviados = mayuscula.getBytes();\n    //ENVIO DATAGRAMA AL CLIENTE\n            DatagramPacket paqEnviado = new DatagramPacket(enviados, enviados.length, IPOrigen, puerto);\n            serverSocket.send(paqEnviado);\n    // Condici\u00f3n de finalizaci\u00f3n\n            if (cadena.trim().equals(\"*\")) {\n                break;\n            }\n        }//Fin de while\n        serverSocket.close();\n        System.out.println(\"Socket cerrado...\");\n    }\n}\n</code></pre> <p>ClienteUDP2.java</p> <pre><code>package udp2;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ClienteUDP2 {\n\n    public static void main(String args[]) throws Exception {\n    // FLUJO PARA ENTRADA ESTANDAR\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        DatagramSocket clientSocket = new DatagramSocket();\n        byte[] enviados = new byte[1024];\n        byte[] recibidos = new byte[1024];\n    // DATOS DEL SERVIDOR al que enviar mensaje\n        InetAddress IPServidor = InetAddress.getLocalHost();// localhost\n        int puerto = 9876; // puerto por el que escucha\n    // INTRODUCIR DATOS POR TECLADO\n        System.out.print(\"Introduce mensaje: \");\n        String cadena = in.readLine();\n        enviados = cadena.getBytes();\n    // ENVIANDO DATAGRAMA AL SERVIDOR\n        System.out.println(\"Enviando \" + enviados.length + \" bytes al servidor.\");\n        DatagramPacket envio = new DatagramPacket(enviados, enviados.length, IPServidor, puerto);\n        clientSocket.send(envio);\n    // RECIBIENDO DATAGRAMA DEL SERVIDOR\n        DatagramPacket recibo = new DatagramPacket(recibidos, recibidos.length);\n        System.out.println(\"Esperando datagrama....\");\n        clientSocket.receive(recibo);\n        String mayuscula = new String(recibo.getData());\n    // OBTENIENDO INFORMACI\u00d3N DEL DATAGRAMA\n        InetAddress IPOrigen = recibo.getAddress();\n        int puertoOrigen = recibo.getPort();\n        System.out.println(\"\\tProcedente de: \" + IPOrigen + \":\" + puertoOrigen);\n        System.out.println(\"\\tDatos: \" + mayuscula.trim());\n    //cerrar socket\n        clientSocket.close();\n    }\n}\n</code></pre>"},{"location":"ud3/#multicastsocket","title":"MulticastSocket","text":"<p>La clase MulticastSocket es \u00fatil para enviar paquetes a m\u00faltiples destinos simult\u00e1neamente. Para poder recibir estos paquetes es necesario establecer un grupo multicast, que es un grupo de direcciones IP que comparten el mismo n\u00famero de puerto.</p> <p>Cuando se env\u00eda un mensaje a un grupo de multicast, todos los que pertenezcan a ese grupo recibir\u00e1n el mensaje. La pertenencia al grupo es transparente al emisor, es decir, el emisor no conoce el n\u00famero de miembros del grupo ni sus direcciones IP.</p> <p>Un grupo multicast se especifica mediante una direcci\u00f3n IP de clase D y un n\u00famero de puerto UDP est\u00e1ndar. Las direcciones desde la 224.0.0.0 a la 239.255.255.255 est\u00e1n destinadas para ser direcciones de multicast. La direcci\u00f3n 224.0.0.0 est\u00e1 reservada y no debe ser utilizada.</p> <p></p>"},{"location":"ud3/#ejemplo-de-multicast-con-udp","title":"Ejemplo de Multicast con UDP","text":"<p>MulticastServidor.java</p> <pre><code>package multicast;\n\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\nimport java.util.Scanner;\n\npublic class MulticastServidor {\n\n    public static void main(String args[]) throws Exception {\n        // Enviamos la informaci\u00f3n introducida por teclado hasta que se env\u00ede un *\n        Scanner in = new Scanner(System.in);\n        //Se crea el socket multicast.\n        MulticastSocket ms = new MulticastSocket();\n        // Se escoge un puerto para el server\n        int puerto = 12345;\n        // Se escoge una direcci\u00f3n para el grupo\n        InetAddress grupoMulticast = InetAddress.getByName(\"225.0.0.1\");\n        String cadena = \"\";\n        while (!cadena.trim().equals(\"*\")) {\n            System.out.print(\"Datos a enviar al grupo: \");\n            cadena = in.nextLine();\n            // Enviamos el mensaje a todos los clientes que se hayan unido al grupo\n            DatagramPacket paquete = new DatagramPacket(cadena.getBytes(), cadena.length(), grupoMulticast, puerto);\n            ms.send(paquete);\n        }\n        // Cerramos recursos\n        ms.close();\n        System.out.println(\"Socket cerrado...\");\n    }\n}\n</code></pre> <p>MulticastCliente.java</p> <pre><code>package multicast;\n\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\n\npublic class MulticastCliente {\n\n    public static void main(String args[]) throws Exception {\n        // El puerto debe ser el mismo en todos los clientes, ya que el\n        // Se crea el socket multicast\n        // servidor multicast env\u00eda la informaci\u00f3n a la IP multicast y a un puerto\n        int puerto = 12345;//Puerto multicast\n        MulticastSocket ms = new MulticastSocket(puerto);\n        //Nos unimos al grupo multicast\n        InetAddress grupo = InetAddress.getByName(\"225.0.0.1\");\n        ms.joinGroup(grupo);\n        //ms.joinGroup(mcastaddr, netIf);\n        String msg = \"\";\n        while (!msg.trim().equals(\"*\")) {\n            // El buffer se crea dentro del bucle para que se sobrescriba\n            // con cada nuevo mensaje\n            byte[] buf = new byte[1000];\n            DatagramPacket paquete = new DatagramPacket(buf, buf.length);\n            //Recibe el paquete del servidor multicast\n            ms.receive(paquete);\n            msg = new String(paquete.getData());\n            System.out.println(\"Recibo: \" + msg.trim());\n        }\n        // Abandonamos grupo\n        ms.leaveGroup(grupo);\n        //ms.leaveGroup(mcastaddr, netIf);\n        // Cerramos recursos\n        ms.close();\n        System.out.println(\"Socket cerrado...\");\n    }\n}\n</code></pre>"},{"location":"ud3/#clases-java-para-sockets-tcp","title":"Clases Java para sockets TCP","text":"<p>La interfaz Java que da soporte a sockets TCP est\u00e1 constituida por las clases ServerSocket y Socket.</p> <ul> <li>ServerSocket: es utilizada por un servidor para crear un socket en el puerto en el que escucha las peticiones de conexi\u00f3n de los clientes. Su m\u00e9todo accept toma una petici\u00f3n de conexi\u00f3n de la cola, o si la cola est\u00e1 vac\u00eda, se bloquea hasta que llega una petici\u00f3n. El resultado de ejecutar accept es una instancia de Socket, a trav\u00e9s del cual el servidor tiene acceso a los datos enviados por el cliente.</li> <li>Socket: es utilizada tanto por el cliente como por el servidor. El cliente crea un socket especificando el nombre DNS del host y el puerto del servidor, as\u00ed se crea el socket local y adem\u00e1s se conecta con el servicio. Esta clase proporciona los m\u00e9todos getInputStream y getOutputStream para acceder a los dos streams asociados a un socket (recordemos que son bidireccionales), y devuelve tipos de datos InputStream y OutputStream, respectivamente, a partir de los cuales podemos construir BufferedReader y PrintWriter , respectivamente, para poder procesar los datos de forma m\u00e1s sencilla.</li> </ul>"},{"location":"ud3/#cliente-tcp","title":"Cliente TCP","text":"<p>Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente ser\u00e1:</p> <ol> <li>Crear un objeto de la clase Socket, indicando host y puerto donde corre el servicio.</li> <li>Obtener las referencias al stream de entrada y al de salida al socket.</li> <li>Leer desde y escribir en el stream de acuerdo al protocolo del servicio. Para ello emplear alguna de las facilidades del paquete java.io.</li> <li>Cerrar los streams.</li> <li>Cerrar el socket.</li> </ol> <p>Hay dos formas mayoritarias de enviar y recibir la informaci\u00f3n a trav\u00e9s de los streams que proporciona un socket. A trav\u00e9s de los streams enviamos bytes, que es la forma m\u00e1s b\u00e1sica de generar informaci\u00f3n, bien sea a trav\u00e9s de la red o entre procesos. Como es complicado gestionar a nivel de bytes toda la informaci\u00f3n que queremos enviar o recibir, usamos Decorators o Wrappers para enviar tipos de datos de un nivel de abstracci\u00f3n mayor.</p> <p>Sin embargo, puede haber ocasiones en las que nos interese trabajar con tipos de datos. DataInputStream y DataOutputStream proporcionan m\u00e9todos para leer y escribir Strings y todos los tipos de datos primitivos de Java, incluyendo n\u00fameros y valores booleanos.</p> <p>DataOutputStream codifica esos valores de forma independiente de la m\u00e1quina y los env\u00eda al stream de m\u00e1s bajo nivel para que los gestione como bytes. DataInputStream hace lo contrario.</p> <p></p>"},{"location":"ud3/#servidor-tcp","title":"Servidor TCP","text":"<p>La forma de implementar un servidor ser\u00e1:</p> <ol> <li>Crear un objeto de la clase ServerSocket para escuchar peticiones en el puerto asignado al servicio.</li> <li>Esperar solicitudes de clientes.</li> <li>Cuando se produce una solicitud:<ul> <li>Aceptar la conexi\u00f3n obteniendo un objeto de la clase Socket</li> <li>Obtener las referencias al stream de entrada y al de salida al socket anterior.</li> <li>Leer datos del socket, procesarlos y enviar respuestas al cliente, escribiendo en el stream del socket. Para ello emplear alguna de las funcionalidades del paquete java.io.</li> </ul> </li> <li>Cerrar los streams.</li> <li>Cerrar los sockets.</li> </ol> <p></p>"},{"location":"ud3/#clienteservidor-tcp","title":"Cliente/Servidor TCP","text":"<p>La comunicaci\u00f3n a trav\u00e9s de un socket de comunicaci\u00f3n se realiza en forma de una secuencia de bytes.</p> <p>TCP permite que los datos se reciban en el proceso de destino en el mismo orden en que se env\u00edan desde el proceso de origen. Por ello, en Java se utilizan streams tanto para el env\u00edo como para la recepci\u00f3n de datos a trav\u00e9s de un socket de TCP (OutputStream e InputStream). Se utilizan las clases Socket y ServerSocket.</p> <p></p>"},{"location":"ud3/#ejemplo-clienteservidor-en-tcp","title":"Ejemplo cliente/servidor en TCP","text":"<p>ClienteTCP.java</p> <pre><code>package tcp;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class ClienteTCP {\n\n    public static void main(String[] args) throws IOException {\n        Socket socketCliente = null;\n        BufferedReader entrada = null;\n        PrintWriter salida = null;\n\n        // Creamos un socket en el lado cliente, enlazado con un\n        // servidor que est\u00e1 en la misma m\u00e1quina que el cliente\n        // y que escucha en el puerto 4444\n        try {\n            socketCliente = new Socket(\"localhost\", 4444);\n            // Obtenemos el canal de entrada\n            entrada = new BufferedReader(\n                    new InputStreamReader(socketCliente.getInputStream()));\n            // Obtenemos el canal de salida\n            salida = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\n        } catch (IOException e) {\n            System.err.println(\"No puede establecer canales de E/S para la conexi\u00f3n\");\n            System.exit(-1);\n        }\n        Scanner stdIn = new Scanner(System.in);\n\n        String linea;\n\n        // El programa cliente no analiza los mensajes enviados por el\n        // usuario, simplemente los reenv\u00eda al servidor hasta que este\n        // se despide con \"Adios\"\n        try {\n            while (true) {\n                // Leo la entrada del usuario\n                linea = stdIn.nextLine();\n                // La envia al servidor por el OutputStream\n                salida.println(linea);\n                // Recibe la respuesta del servidor por el InputStream\n                linea = entrada.readLine();\n                // Env\u00eda a la salida est\u00e1ndar la respuesta del servidor\n                System.out.println(\"Respuesta servidor: \" + linea);\n                // Si es \"Adios\" es que finaliza la comunicaci\u00f3n\n                if (linea.equals(\"Adios\")) {\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"IOException: \" + e.getMessage());\n        }\n\n        // Libera recursos\n        salida.close();\n        entrada.close();\n        stdIn.close();\n        socketCliente.close();\n    }\n}\n</code></pre> <p>ServidorTCP.java</p> <pre><code>package tcp;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class ServidorTCP {\n\n    public static final int PORT = 4444;\n\n    public static void main(String[] args) throws IOException {\n        // Establece el puerto en el que escucha peticiones\n        ServerSocket socketServidor = null;\n        try {\n            socketServidor = new ServerSocket(PORT);\n        } catch (IOException e) {\n            System.out.println(\"No puede escuchar en el puerto: \" + PORT);\n            System.exit(-1);\n        }\n\n        Socket socketCliente = null;\n        BufferedReader entrada = null;\n        PrintWriter salida = null;\n\n        System.out.println(\"Escuchando: \" + socketServidor);\n        try {\n            // Se bloquea hasta que recibe alguna petici\u00f3n de un cliente\n            // abriendo un socket para el cliente\n            socketCliente = socketServidor.accept();\n            System.out.println(\"Conexi\u00f3n aceptada: \" + socketCliente);\n            // Establece canal de entrada\n            entrada = new BufferedReader(\n                    new InputStreamReader(socketCliente.getInputStream()));\n            // Establece canal de salida\n            salida = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\n\n            // Hace eco de lo que le proporciona el cliente, hasta que recibe \"Adios\"\n            while (true) {\n                // Recibe la solicitud del cliente por el InputStream\n                String str = entrada.readLine();\n                // Env\u00eda a la salida est\u00e1ndar el mensaje del cliente\n                System.out.println(\"Cliente: \" + str);\n                // Le env\u00eda la respuesta al cliente por el OutputStream                \n                salida.println(str);\n                // Si es \"Adios\" es que finaliza la comunicaci\u00f3n\n                if (str.equals(\"Adios\")) {\n                    break;\n                }\n            }\n\n        } catch (IOException e) {\n            System.out.println(\"IOException: \" + e.getMessage());\n        }\n        salida.close();\n        entrada.close();\n        socketCliente.close();\n        socketServidor.close();\n    }\n\n}\n</code></pre>"},{"location":"ud3/#servidor-multihilo","title":"Servidor multihilo","text":"<p>Si queremos que un servidor pueda atender varias peticiones de forma simult\u00e1nea, debemos usar hilos para dotarlo de esa capacidad.</p> <p>El flujo b\u00e1sico ahora cambiar\u00eda para adaptarse a este formato:</p> <pre><code>while (true) {\nAceptar la conexi\u00f3n obteniendo un objeto de la clase Socket;\nCrear un thread para que se encargue de la comunicaci\u00f3n con ese cliente, es\ndecir, para que gestione el socket obtenido en el accept.;\n}\n</code></pre> <p>El servidor multihilo crea un nuevo hilo que se encarga de las operaciones de E/S con el cliente. Mientras tanto puede esperar la conexi\u00f3n de nuevos clientes con los que volver\u00e1 a hacer lo mismo.</p> <p>El servidor multihilo se ayuda de una clase Worker que hereda de Thread, pudiendo as\u00ed ejecutarse concurrentemente con el hilo principal.</p> <p>Esta clase Worker es la encargada de realizar toda la comunicaci\u00f3n con el cliente y el servidor. Para poder hacerlo, en su constructor recibe el Socket que se crea cuando se recibe la conexi\u00f3n de un cliente ServerSocket.accept().</p> <p></p>"},{"location":"ud3/#ejemplos-servidor-multihilo","title":"Ejemplos servidor multihilo","text":"<p>Worker.java</p> <pre><code>package tcpMultihilo;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class Worker extends Thread {\n\n    private Socket socketCliente;\n    private BufferedReader entrada = null;\n    private PrintWriter salida = null;\n\n    Worker(Socket socketCliente) {\n        this.socketCliente = socketCliente;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // Establece canal de entrada\n            entrada = new BufferedReader(new InputStreamReader(\n                    socketCliente.getInputStream()));\n            // Establece canal de salida\n            salida = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    socketCliente.getOutputStream())), true);\n\n            // Realizamos la comunicaci\u00f3n entre servidor y cliente\n            // Hacemos una recepci\u00f3n de informaci\u00f3n desde el cliente\n            String mensajeRecibido = entrada.readLine();\n            System.out.println(\"&lt;-- Cliente: \" + mensajeRecibido);\n\n            // Hacemos un env\u00edo al cliente\n            String mensajeEnviado = \"Mensaje enviado desde el servidor al cliente\";\n            salida.println(mensajeEnviado);\n            System.out.println(\"--&gt; Cliente: \" + mensajeEnviado);\n        } catch (Exception e) {\n        }\n    }\n\n}\n</code></pre> <p>ServidorMultihilo.java</p> <pre><code>package tcpMultihilo;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class ServidorMultihilo {\n\n    public static final int PORT = 4444;\n\n    public static void main(String[] args) throws IOException {\n        // Establece el puerto en el que escucha peticiones\n        ServerSocket socketServidor = null;\n        try {\n            socketServidor = new ServerSocket(PORT);\n        } catch (IOException e) {\n            System.out.println(\"No puede escuchar en el puerto: \" + PORT);\n            System.exit(-1);\n        }\n\n        Socket socketCliente = null;\n        BufferedReader entrada = null;\n        PrintWriter salida = null;\n\n        System.out.println(\"Escuchando: \" + socketServidor);\n        try {\n            while (true) {\n            // Se bloquea hasta que recibe alguna petici\u00f3n de un cliente\n            // abriendo un socket para el cliente\n            socketCliente = socketServidor.accept();\n            System.out.println(\"Conexi\u00f3n aceptada: \" + socketCliente);\n            // Para seguir aceptando peticiones de otros clientes\n            // se crea un nuevo hilo que se encargar\u00e1 de la comunicaci\u00f3n con el cliente\n            new Worker(socketCliente).start();\n        }\n\n        } catch (IOException e) {\n            System.out.println(\"IOException: \" + e.getMessage());\n        }\n        salida.close();\n        entrada.close();\n        socketCliente.close();\n        socketServidor.close();\n    }\n}\n</code></pre> <p>Ejemplo servidor Eco multihilo</p> <pre><code>package socketsTCP_MultihiloEco;\n\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\n\nclass HiloServidor implements Runnable {\n\n    private final static String COD_TEXTO = \"UTF-8\";\n    private final Socket socketComunicacion;\n\n    HiloServidor(Socket socketComunicacion) {\n        this.socketComunicacion = socketComunicacion;\n    }\n\n    @Override\n    public void run() {\n        try ( InputStream isDeCliente = this.socketComunicacion.getInputStream();  OutputStream osACliente = this.socketComunicacion.getOutputStream();  InputStreamReader isrDeCliente = new InputStreamReader(isDeCliente, COD_TEXTO);  BufferedReader brDeCliente = new BufferedReader(isrDeCliente);  OutputStreamWriter oswACliente = new OutputStreamWriter(osACliente, COD_TEXTO);  BufferedWriter bwACliente = new BufferedWriter(oswACliente)) {\n            String lineaRecibida;\n            while ((lineaRecibida = brDeCliente.readLine()) != null &amp;&amp; lineaRecibida.length() &gt; 0) {\n                bwACliente.write(\"#\" + lineaRecibida + \"#\");\n                bwACliente.newLine();\n                bwACliente.flush();\n            }\n        } catch (IOException ex) {\n            System.out.println(\"Excepci\u00f3n de E/S\");\n            ex.printStackTrace();\n            System.exit(1);\n        } finally {\n            if (this.socketComunicacion != null) {\n                try {\n                    this.socketComunicacion.close();\n                    System.out.println(\"Cliente desconectado.\");\n                } catch (IOException ex) {\n                }\n            }\n        }\n    }\n\n}\n\nclass SocketsTCP_ServidorMultihiloEco {\n\n    public static void main(String[] args) {\n\n        int numPuerto = 4444;\n\n        try ( ServerSocket socketServidor = new ServerSocket(numPuerto)) {\n            System.out.printf(\"Creado socket de servidor en puerto %d. Esperando conexiones de clientes.\\n\", numPuerto);\n\n            while (true) {    // Acepta una conexi\u00f3n de cliente tras otra\n                Socket socketComNuevoCliente = socketServidor.accept();\n                System.out.printf(\"Cliente conectado desde %s:%d.\\n\",\n                        socketComNuevoCliente.getInetAddress().getHostAddress(),\n                        socketComNuevoCliente.getPort());\n\n                Thread hiloSesion = new Thread(new HiloServidor(socketComNuevoCliente));\n                hiloSesion.start();\n            }\n\n        } catch (IOException ex) {\n            System.out.println(\"Excepci\u00f3n de E/S\");\n            ex.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n}\n</code></pre>"},{"location":"ud4/","title":"Unidad 4 - Generaci\u00f3n de servicios en red","text":"<p>Como hemos visto anteriormente, el modelo TCP/IP est\u00e1 compuesto por cuatro (o cinco) capas o niveles. La capa de aplicaci\u00f3n define las aplicaciones de red y los servicios de Internet est\u00e1ndar que puede utilizar un usuario. Estos servicios utilizan la capa de transporte para enviar y recibir datos.</p>"},{"location":"ud4/#protocolos-estandar-de-comunicacion-en-red","title":"Protocolos est\u00e1ndar de comunicaci\u00f3n en red","text":"<p>Existen varios protocolos de capa de aplicaci\u00f3n:</p> <ul> <li>TELNET (Telecommunication Network): Emulaci\u00f3n de terminal. Permite a un usuario acceder a una m\u00e1quina remota y manejarla como si estuviese sentado delante de ella.</li> <li>SMTP (Simple Mail Transfer Protocol): Protocolo simple de transferencia de correo electr\u00f3nico; es probablemente el servicio m\u00e1s popular entre los usuarios de la red. Este est\u00e1ndar especifica el formato exacto de los mensajes que un cliente en una m\u00e1quina debe enviar al servidor en otra. Administra la transmisi\u00f3n de correo electr\u00f3nico a trav\u00e9s de las redes inform\u00e1ticas.</li> <li>FTP (File Transfer Protocol): Protocolo de transferencia de ficheros. Es un servicio confiable orientado a conexi\u00f3n que se utiliza para transferir ficheros de una m\u00e1quina a otra a trav\u00e9s de Internet.</li> <li>HTTP (HyperText Transference Protocol): Protocolo de Transferencia de Hipertexto. Utilizado por los navegadores web para realizar peticiones a los servidores web y para recibir las respuestas de ellos.</li> <li>POP3 (Post Office Protocol, version 3). Protocolo para entrega de correo electr\u00f3nico a un agente de usuario de correo.</li> <li>DNS  (Domain Name System): Sistema de nombres de dominio. Es un sistema que usa servidores distribuidos a lo largo de la red para resolver el nombre de un host IP en una direcci\u00f3n IP.</li> </ul>"},{"location":"ud4/#correo-jakarta-mail","title":"Correo: Jakarta Mail","text":"<p>Jakarta Mail (anteriormente conocido como JavaMail) es una API para enviar y recibir correos electr\u00f3nicos a trav\u00e9s de SMTP, POP3 e IMAP, y es la opci\u00f3n m\u00e1s popular que tambi\u00e9n admite la autenticaci\u00f3n TLS y SSL. Es independiente de la plataforma, del protocolo y se encuentra integrado en la plataforma Jakarta EE.</p> <p>La API de correo de Jakarta tiene una amplia gama de clases e interfaces que se pueden usar para enviar, leer y realizar otras acciones con mensajes de correo electr\u00f3nico, al igual que en una aplicaci\u00f3n de correo est\u00e1ndar. </p> <p>Aunque hay varios paquetes en el proyecto de Jakarta Mail, los m\u00e1s utilizados son jakarta.mail y jakarta.mail.internet. El paquete jakarta.mail proporciona clases que modelan un sistema de correo, y el paquete jakarta.mail.internet proporciona clases que se centran en los sistemas de correo de Internet.</p> <p>https://jakarta.ee/specifications/mail/2.1/jakarta-mail-spec-2.1</p>"},{"location":"ud4/#clases-principales-de-jakarta-mail","title":"Clases principales de Jakarta Mail","text":""},{"location":"ud4/#jakartamailsession","title":"jakarta.mail.Session","text":"<p>La clase Session, que no tiene subclases, es la clase de nivel superior de la API de correo de Jakarta. Es un objeto multiproceso que act\u00faa como f\u00e1brica de conexiones para la API de correo de Jakarta. Adem\u00e1s de recopilar las propiedades y los valores predeterminados de la API de correo, es responsable de los ajustes de configuraci\u00f3n y la autenticaci\u00f3n. </p> <p>Para obtener el objeto Session, puede llamar a cualquiera de los dos m\u00e9todos siguientes:</p> <ul> <li>getDefaultInstance(), que devuelve la sesi\u00f3n predeterminada.</li> <li>getInstance(), que devuelve una nueva sesi\u00f3n.</li> </ul>"},{"location":"ud4/#jakartamailmessage","title":"jakarta.mail.Message","text":"<p>La clase Message es una clase abstracta que modela un mensaje de correo electr\u00f3nico. Sus subclases soportan las implementaciones reales. Por lo general, su subclase MimeMessage (jakarta.mail.internet.MimeMessage) se utiliza para preparar los detalles del mensaje de correo electr\u00f3nico que se enviar\u00e1.</p> M\u00e9todo Descripci\u00f3n setFrom(Address addresses) Se utiliza para establecer el campo de encabezado \"De\" setRecipients(Message.RecipientType type, String addresses) Se utiliza para establecer el tipo de destinatario indicado en las direcciones proporcionadas setSubject(String subject) Se utiliza para establecer el campo de encabezado del asunto del correo electr\u00f3nico setText(String text) Se utiliza para establecer la cadena proporcionada como contenido del correo electr\u00f3nico, utilizando el tipo MIME de \"texto / sin formato\" setContent(Object message, String contentType) Se utiliza para establecer el contenido del correo electr\u00f3nico y se puede utilizar con un tipo MIME que no sea \"text/html\""},{"location":"ud4/#jakartamailaddress","title":"jakarta.mail.Address","text":"<p>La clase Address es una clase abstracta que modela las direcciones (direcciones To y From) en un mensaje de correo electr\u00f3nico; Sus subclases soportan las implementaciones reales. Por lo general, su subclase InternetAddress , que denota una direcci\u00f3n de correo electr\u00f3nico de Internet, es la que m\u00e1s se usa.</p>"},{"location":"ud4/#jakartamailauthenticator","title":"jakarta.mail.Authenticator","text":"<p>La clase Authenticator es una clase abstracta que se utiliza para obtener autenticaci\u00f3n para acceder a los recursos del servidor de correo, a menudo requiriendo la informaci\u00f3n del usuario. Por lo general, su subclase PasswordAuthentication es la que m\u00e1s se usa.</p>"},{"location":"ud4/#jakartamailtransport","title":"jakarta.mail.Transport","text":"<p>La clase Transport es una clase abstracta que utiliza el protocolo SMTP para enviar y transportar mensajes de correo electr\u00f3nico.</p>"},{"location":"ud4/#enviar-correos-en-jakarta-mail","title":"Enviar correos en Jakarta Mail","text":"<p>Estos son los pasos para enviar un email utilizando la API de correo de Jakarta:</p> <ol> <li>Configurar detalles del servidor SMTP utilizando un objeto Java Properties. Se pueden obtener detalles del servidor SMTP del proveedor de servicios de correo electr\u00f3nico.</li> <li>Crear un objeto Session llamando al m\u00e9todo getInstance(). Luego, pasar el nombre de usuario y contrase\u00f1a de la cuenta a PasswordAuthentication. Al crear el objeto de sesi\u00f3n, siempre s debe registrar el Authenticator con la sesi\u00f3n.</li> <li>Una vez creado el objeto Session, el siguiente paso es crear el email que se enviar\u00e1. Para ello, se comienza pasando el objeto de sesi\u00f3n creado al constructor de clase MimeMessage.</li> <li>A continuaci\u00f3n, despu\u00e9s de crear el objeto de mensaje, establecer los campos De, Para y Asunto del email.</li> <li>Utilizar el m\u00e9todo setText() para establecer el contenido del mensaje de correo electr\u00f3nico.</li> <li>Utilizar el objeto Transport para enviar el correo.</li> <li>Agregar excepciones para recuperar los detalles de cualquier posible error al enviar el mensaje.</li> </ol>"},{"location":"ud4/#enviar-mensajes-html","title":"Enviar mensajes HTML","text":"<p>En t\u00e9rminos de usabilidad, el contenido HTML es muy superior al texto sin formato. Por lo tanto, la mayor\u00eda de las veces enviamos emails en formato HTML. Java Mail API admite el env\u00edo de correos electr\u00f3nicos en formato HTML. Para enviar un correo electr\u00f3nico con contenido HTML, debemos reemplazar el m\u00e9todo message.setText() con el siguiente c\u00f3digo.</p> <pre><code>message.setContent(\"Just discovered that Jakarta Mail is fun and easy to use\", \"text/html\");\n</code></pre> <p>Usaremos el m\u00e9todo setContent() para establecer el contenido y especificar \"text/html\" en el segundo argumento, lo que indica que el mensaje tiene formato HTML.</p>"},{"location":"ud4/#enviar-correos-electronicos-con-archivos-adjuntos","title":"Enviar correos electr\u00f3nicos con archivos adjuntos","text":"<p>Adem\u00e1s de los pasos mencionados anteriormente, estos son los diferentes pasos involucrados en el uso de la API de correo de Jakarta para enviar archivos adjuntos de correo electr\u00f3nico:</p> <ol> <li>Creamos una instancia del objeto MimeMultipart que se utilizar\u00e1 como envoltorio o wrapper para las distintas partes MimeBodyPart. Un MultiPart act\u00faa como un contenedor que guarda varias partes individuales, y viene con m\u00e9todos para obtener y configurar sus diversas subpartes.</li> <li>Luego, establecemos la primera parte del objeto Multipart pas\u00e1ndole el mensaje real.</li> <li>A continuaci\u00f3n, establecemos la segunda y las siguientes parte del objeto Multipart agregando los datos adjuntos.</li> <li>Incluimos el objeto Multipart en el mensaje a enviar.</li> <li>Enviamos el mensaje.</li> </ol> <p></p>"},{"location":"ud4/#enviar-correos-electronicos-html-con-imagenes","title":"Enviar correos electr\u00f3nicos HTML con im\u00e1genes","text":"<p>Para agregar una imagen a su correo electr\u00f3nico HTML en Jakarta Mail, se pueden elegir cualquiera de las tres opciones comunes:</p> <ul> <li>Insertando im\u00e1genes CID. Para ello debemos crear un mensaje MIME multipart/related.</li> <li>Insertando im\u00e1genes en l\u00ednea o codificaci\u00f3n Base64. Para la inserci\u00f3n en l\u00ednea o la codificaci\u00f3n Base64, se debe incluir los datos de imagen codificados en el cuerpo HTML de forma similar a esta:</li> </ul> <pre><code>&lt;img src=\"data:image/jpeg;base64,base64-encoded-data-here\" /&gt;\n</code></pre> <ul> <li>Enlazando im\u00e1genes. Tenemos im\u00e1genes vinculadas que son esencialmente im\u00e1genes alojadas en alg\u00fan servidor externo al que luego crea un enlace. Podemos hacerlo usando la etiqueta img en el cuerpo HTML de la siguiente manera.</li> </ul> <pre><code>&lt;img src=\"/wp-content/uploads/2018/11/blog/-illustration-email-embedding-images.png\" alt=\"img\" /&gt;\n</code></pre>"},{"location":"ud4/#lectura-de-correos-electronicos-en-jakarta-mail","title":"Lectura de correos electr\u00f3nicos en Jakarta Mail","text":"<p>El API de correo de Jakarta tambi\u00e9n proporciona soporte para leer correos electr\u00f3nicos. Para leer correos electr\u00f3nicos, debe usar la clase javax.mail.Store. La clase Store es una clase abstracta que modela un almac\u00e9n de mensajes y su protocolo de acceso, y es una subclase de las clases POP3Store e IMAPStore. Leer correos electr\u00f3nicos almacenados en un servidor IMAP consta de los siguientes pasos:</p> <ul> <li>Creaci\u00f3n de la sesi\u00f3n IMAP (Session), indicando el protocolo, el nombre del host, el puerto, si usa SSL y el servidor de autenticaci\u00f3n asociado.</li> <li>Configuraci\u00f3n y obtenci\u00f3n del almac\u00e9n (Store).</li> <li>Obtenci\u00f3n de la conexi\u00f3n a trav\u00e9s del almac\u00e9n, indicando el identificador de la cuenta y la contrase\u00f1a.</li> <li>Obtenci\u00f3n de la carpeta a leer.</li> <li>Apertura de la carpeta.</li> <li>Obtenci\u00f3n de los mensajes.</li> <li>Procesamiento de mensajes.</li> <li>Cierre de la carpeta y del almac\u00e9n.</li> <li>Cierre de la sesi\u00f3n y de la conexi\u00f3n.</li> </ul>"},{"location":"ud4/#ejemplo-de-uso-de-jakarta-mail-para-el-envio-y-lectura-de-correos-electronicos","title":"Ejemplo de uso de Jakarta Mail para el env\u00edo y lectura de correos electr\u00f3nicos","text":"<p>EnviarCorreo.java</p> <pre><code>import jakarta.mail.Message;\nimport jakarta.mail.MessagingException;\nimport jakarta.mail.Multipart;\nimport jakarta.mail.PasswordAuthentication;\nimport jakarta.mail.Session;\nimport jakarta.mail.Transport;\nimport jakarta.mail.internet.AddressException;\nimport jakarta.mail.internet.InternetAddress;\nimport jakarta.mail.internet.MimeBodyPart;\nimport jakarta.mail.internet.MimeMessage;\nimport jakarta.mail.internet.MimeMultipart;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\npublic class EnviarCorreo {\n\n    public static void main(String[] args) throws AddressException, MessagingException, IOException {\n\n        final Properties prop = new Properties();\n        prop.put(\"mail.smtp.username\", \"username@gmail.com\");\n        prop.put(\"mail.smtp.password\", \"contrase\u00f1a generada en la configuraci\u00f3n de gmail\");\n        prop.put(\"mail.smtp.host\", \"smtp.gmail.com\");\n        prop.put(\"mail.smtp.port\", \"587\");\n        prop.put(\"mail.smtp.auth\", \"true\");\n        prop.put(\"mail.smtp.starttls.enable\", \"true\"); // TLS\n        prop.put(\"mail.debug\", \"true\");\n\n// Create the Session with the user credentials\n        Session mailSession = Session.getInstance(prop, new jakarta.mail.Authenticator() {\n            @Override\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(prop.getProperty(\"mail.smtp.username\"),\n                        prop.getProperty(\"mail.smtp.password\"));\n            }\n        });\n        // Prepare the MimeMessage\n        Message message = new MimeMessage(mailSession);\n// Set From and subject email properties\n        message.setFrom(new InternetAddress(\"username@gmail.com\"));\n        message.setSubject(\"Sending Mail with pure Jakarta Mail API \");\n\n// Set to, cc &amp; bcc recipients        \n        InternetAddress[] toEmailAddresses\n                = InternetAddress.parse(\"username@gmail.com\");\n        InternetAddress[] ccEmailAddresses\n                = InternetAddress.parse(\"correo1@gmail.com\");\n        InternetAddress[] bccEmailAddresses\n                = InternetAddress.parse(\"correo2@gmail.com\");\n\n        message.setRecipients(Message.RecipientType.TO, toEmailAddresses);\n        message.setRecipients(Message.RecipientType.CC, ccEmailAddresses);\n        message.setRecipients(Message.RecipientType.BCC, bccEmailAddresses);\n\n//Mail body with plain Text\n /* message.setText(\"Hello User,\"\n                + \"\\n\\n If you read this, means mail sent with Java Mail API is successful\");*/\n\n//Mail body with HTML\n        /* message.setContent(\"Just discovered that Jakarta Mail is fun and easy to use\",\n                \"text/html\");*/\n\n//Mail with attached files\n/*\n    // create an instance of multipart object\n        Multipart multipart = new MimeMultipart();\n\n    // create the 1st message body part\n        MimeBodyPart messageBodyPart = new MimeBodyPart();\n    // Add a plain message (HTML can also be added with setContent)\n        messageBodyPart.setText(\"Please find the attachment sent using Jakarta Mail\");\n    // Add the BodyPart to the Multipart object\n        multipart.addBodyPart(messageBodyPart);\n\n    // 2nd. bodyPart with an attached file\n        messageBodyPart = new MimeBodyPart();\n        String filename = \"File.pdf\";\n        messageBodyPart.attachFile(filename);\n    // Add the BodyPart to the Multipart object\n        multipart.addBodyPart(messageBodyPart);\n\n    // Add the multipart object to the message\n        message.setContent(multipart);\n         */\n\n//Mail with images\n\n//An HTML code with a link referenced image\n        Multipart multipart = new MimeMultipart(\"related\");\n        MimeBodyPart htmlPart = new MimeBodyPart();\n//add reference to your image to the HTML body &lt;img src=\"cid:some-image-cid\" alt=\"img\" /&gt;\n        String messageBody = \"&lt;p&gt;&lt;/p&gt;&lt;img src=\\\"https://projects.eclipse.org/sites/default/files/36201228_22.png\\\" alt=\\\"img\\\" /&gt;&lt;/p&gt;\";\n        htmlPart.setText(messageBody, \"utf-8\", \"html\");\n// Add the BodyPart to the Multipart object\n        multipart.addBodyPart(htmlPart);\n// Add the multipart object to the message\n        message.setContent(multipart);\n\n\n// Send the configured message in the session\n        Transport.send(message);\n    }\n}\n</code></pre> <p>LeerCorreo.java</p> <pre><code>import jakarta.mail.Folder;\nimport jakarta.mail.Message;\nimport jakarta.mail.MessagingException;\nimport jakarta.mail.NoSuchProviderException;\nimport jakarta.mail.PasswordAuthentication;\nimport jakarta.mail.Session;\nimport jakarta.mail.Store;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class Leercorreo {\n\n    public static void main(String[] args) throws NoSuchProviderException,\n            MessagingException, IOException {\n\n        final Properties prop = new Properties();\n        prop.put(\"mail.imap.username\", \"username@gmail.com\");\n        prop.put(\"mail.imap.password\", \"contrase\u00f1a generada en la configuraci\u00f3n de gmail\");\n        prop.put(\"mail.imap.host\", \"imap.gmail.com\");\n        prop.put(\"mail.imap.port\", \"993\");\n        prop.put(\"mail.imap.ssl.enable\", \"true\");\n        prop.put(\"mail.imap.auth\", \"true\");\n       // prop.put(\"mail.debug\", \"true\");\n\n        // Create the Session with the user credentials\n        Session mailSession = Session.getInstance(prop, new jakarta.mail.Authenticator() {\n            @Override\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(prop.getProperty(\"mail.imap.username\"),\n                        prop.getProperty(\"mail.imap.password\"));\n            }\n        });\n\n        // Get the Store object and connect to the current host using the specified username and password.\n        Store store = mailSession.getStore(\"imap\");\n        store.connect(prop.getProperty(\"mail.imap.host\"),\n                prop.getProperty(\"mail.imap.username\"),\n                prop.getProperty(\"mail.imap.password\"));\n\n        // Get the folder and open it\n        Folder folder = store.getFolder(\"INBOX\");\n        folder.open(Folder.READ_ONLY);\n\n        // Get the messages\n        Message[] messages = folder.getMessages();\n\n        // Process the messages\n        for (int i = 0; i &lt; messages.length; i++) {\n            Message message = messages[i];\n            System.out.println(\"Message \" + (i + 1));\n            System.out.println(\"From: \" + message.getFrom()[0]);\n            System.out.println(\"Subject: \" + message.getSubject());\n            System.out.println(\"Sent Date: \" + message.getSentDate());\n            System.out.println(\"Text: \" + message.getContent().toString());\n        }\n\n        // Close the folder and store objects\n        folder.close(false);\n        store.close();\n\n    }\n\n}\n</code></pre>"},{"location":"ud4/#ftp-apache-commons-net","title":"FTP: Apache Commons Net","text":"<p>La librer\u00eda Apache Commons Net implementa el lado de muchos protocolos b\u00e1sicos de Internet.</p> <p>El prop\u00f3sito de la biblioteca es proporcionar acceso a protocolos fundamentales, no abstracciones de alto nivel. Por lo tanto, algunos de los dise\u00f1os violan los principios de dise\u00f1o orientado a objetos.</p> <p>Nuestra filosof\u00eda es hacer que la funcionalidad global de un protocolo sea accesible (por ejemplo, TFTP env\u00eda archivo y recibe archivo) cuando sea posible, pero tambi\u00e9n proporcionar acceso a los protocolos fundamentales cuando corresponda para que el programador pueda construir sus propias implementaciones personalizadas.</p> <p>En Java, de forma nativa, es posible realizar transferencias de archivos utilizando este protocolo, pero es extremadamente dif\u00edcil hacerlo. La librer\u00eda Apache Commons Net proporciona clases y utilidades para realizar cualquier operaci\u00f3n sobre un servidor FTP o FTPS desde un cliente Java.</p> <p>Esta librer\u00eda se puede descargar desde la p\u00e1gina web de apache.org a trav\u00e9s del siguiente enlace: </p> <p>https://commons.apache.org/proper/commons-net/</p>"},{"location":"ud4/#conexion-y-autenticacion","title":"Conexi\u00f3n y autenticaci\u00f3n","text":"<p>Los pasos para conectarnos a un servidor FTP utilizando la librer\u00eda Apache Commons Net ser\u00edan:</p> <ol> <li>Crear una instancia de la clase FTPClient y llamar al m\u00e9todo connect, pasando como par\u00e1metros el servidor y el puerto al que queremos conectarnos.</li> <li>A continuaci\u00f3n, tendremos que comprobar que la conexi\u00f3n se ha establecido correctamente, para ello debemos llamar al m\u00e9todo getReplyCode y comprobar que el valor devuelto por este m\u00e9todo es positivo.</li> <li>Por \u00faltimo, tendremos que llamar al m\u00e9todo login, pasando como par\u00e1metros el usuario y la contrase\u00f1a con la que queremos iniciar sesi\u00f3n.</li> </ol>"},{"location":"ud4/#cambio-de-directorios","title":"Cambio de directorios","text":"<p>Para mostrar el directorio de trabajo actual, podemos utilizar el m\u00e9todo printWorkingDirectory y para mostrar el contenido del directorio de trabajo actual, podemos utilizar el m\u00e9todo listFiles o el m\u00e9todo listNames.</p> <pre><code>// Obtener el directorio de trabajo remoto actual\nString workingDirectory = ftp.printWorkingDirectory();\n\n// Mostrar el contenido del directorio de trabajo remoto actual\nfor (String name : ftp.listNames()) {\n    System.out.println(name);\n}\n\n// Cambiar el directorio de trabajo remoto actual\nftp.changeWorkingDirectory(fileName)\n</code></pre> <p>Para mostrar el directorio de trabajo local actual, tenemos que gestionarlo con la clase File y sus m\u00e9todos.</p> <pre><code>// Obtener el directorio de trabajo local actual\nString workingDirectory = System.getProperty(\"user.dir\");\n\n// Mostrar el contenido del directorio de trabajo local actual\nFile file = new File(workingDirectory);\nfor (String name : file.list()) {\n    System.out.println(name);\n}\n\n// Cambiar el directorio de trabajo local actual\nSystem.setProperty(\"user.dir\", fileName);\n</code></pre>"},{"location":"ud4/#enviar-y-descargar-archivos-al-servidor","title":"Enviar y descargar archivos al servidor","text":"<p>En FTP los archivos se pueden cargar de dos formas diferentes:</p> <p>Env\u00edo:</p> <ul> <li>Modo ASCII: el archivo se carga como texto, con las terminaciones de l\u00ednea convertidas al est\u00e1ndar de red.</li> <li>Modo binario: el archivo se carga tal, sin ninguna conversi\u00f3n.</li> </ul> <p>Descarga:</p> <ul> <li>Modo ASCII: el archivo se descarga como texto, con las terminaciones de l\u00ednea convertidas al est\u00e1ndar local</li> <li>Modo binario: el archivo se descarga tal cual, sin ninguna conversi\u00f3n.</li> </ul> <pre><code>public boolean sendTextFile(String fileName) throws FileNotFoundException, IOException {\n    ftp.setFileType(FTP.ASCII_FILE_TYPE);\n    File file = new File(getLocalWorkingDirectory() + \"/\" + fileName);\n    String fileRemote = fileName;\n\n    InputStream input = new FileInputStream(file);\n    boolean upload = ftp.storeFile(fileRemote, input);\n\n    input.close();\n\n    return upload;\n}\n</code></pre> <pre><code>public boolean getTextFile(String fileName) throws IOException {\n    ftp.setFileType(FTP.ASCII_FILE_TYPE);\n\n    // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library)\n    // that returns the path to the local file we want to download\n    File file = new File(getLocalWorkingDirectory() + \"/\" + fileName);\n\n    // The file name in the server can be different from the local file name\n    String fileRemote = fileName;\n\n    OutputStream output = new FileOutputStream(file);\n    boolean download = ftp.retrieveFile(fileRemote, output);\n\n    output.close();\n\n    return download;\n}\n</code></pre> <pre><code>public boolean sendBinaryFile(String fileName) throws IOException {\n    ftp.setFileType(FTP.BINARY_FILE_TYPE);\n    File file = new File(getLocalWorkingDirectory() + \"/\" + fileName);\n    String fileRemote = fileName;\n    InputStream input = new FileInputStream(file);\n    OutputStream output = ftp.storeFileStream(fileRemote);\n    byte[] bytesIn = new byte[4096];\n    int read = 0;\n\n    while ((read = input.read(bytesIn)) != -1) {\n        output.write(bytesIn, 0, read);\n    }\n\n    input.close();\n    output.close();\n    boolean upload = ftp.completePendingCommand();\n\n    return upload;\n}\n</code></pre> <pre><code>public boolean getBinaryFile(String fileName) throws IOException {\n    ftp.setFileType(FTP.BINARY_FILE_TYPE);\n\n    // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library)\n    // that returns the path to the local file we want to download\n\n    File file = new File(getLocalWorkingDirectory() + \"/\" + fileName);\n\n    // The file name in the server can be different from the local file name\n    String fileRemote = fileName;\n    OutputStream output = new FileOutputStream(file);\n    InputStream input = ftp.retrieveFileStream(fileRemote);\n    byte[] bytesIn = new byte[4096];\n    int read = 0;\n\n    while ((read = input.read(bytesIn)) != -1) {\n        output.write(bytesIn, 0, read);\n    }\n\n    boolean download = ftp.completePendingCommand();\n\n    input.close();\n    output.close();\n\n    return download;\n}\n</code></pre>"},{"location":"ud4/#otras-acciones","title":"Otras acciones","text":""},{"location":"ud4/#mostrar-informacion-de-los-archivos-y-propiedades-de-los-archivos","title":"Mostrar informaci\u00f3n de los archivos y propiedades de los archivos","text":"<pre><code>public void showFileInfo(String fileName) throws IOException {\n    FTPFile[] files = ftp.listFiles(fileName);\n\n    for (FTPFile file : files) {\n        System.out.println(file.getName());\n        System.out.println(file.getTimestamp().getTime());\n        System.out.println(file.getSize());\n\n        if (f.getType() == FTPFile.FILE_TYPE) {\n            tipo = \"File\";\n        }\n\n        if (f.getType() == FTPFile.DIRECTORY_TYPE) {tipo = \"Folder\";}\n    }\n}   \n</code></pre>"},{"location":"ud4/#anadir-y-eleminar-directores-ftp-remotos","title":"A\u00f1adir y eleminar directores FTP remotos","text":"<pre><code>public void addRemoteDirectory(String directory) throws IOException {\n    ftp.makeDirectory(directory);\n}\n\npublic void removeRemoteDirectory(String directory) throws IOException {\n    ftp.removeDirectory(directory);\n}\n</code></pre>"},{"location":"ud4/#crear-y-eliminar-archivos-ftp-remotos","title":"Crear y eliminar archivos FTP remotos","text":"<pre><code>public void addRemoteFile(String fileName) throws IOException {\n    ftp.storeFile(fileName, new ByteArrayInputStream(new byte[0]));\n}\n\npublic void removeRemoteFile(String fileName) throws IOException {\n    ftp.deleteFile(fileName);\n}\n</code></pre>"},{"location":"ud4/#ejemplo-de-cliente-de-ftp","title":"Ejemplo de cliente de FTP","text":"<p>clienteFTPB\u00e1sico.java</p> <pre><code>import javax.swing.*;\nimport javax.swing.event.*;\nimport org.apache.commons.net.PrintCommandListener;\nimport org.apache.commons.net.ftp.*;\nimport java.io.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class clienteFTPBasico extends JFrame {\n    private static final long serialVersionUID = 1L;\n\n    //campos de cabecera parte superior\n    static JTextField cab = new JTextField();\n    static JTextField cab2 = new JTextField();\n    static JTextField cab3 = new JTextField();\n\n    //campos de mensajes parte inferior\n    private static JTextField campo = new JTextField();\n    private static JTextField campo2 = new JTextField();\n\n    //botones\n    JButton botonCargar = new JButton(\"Subir fichero\");\n    JButton botonDescargar = new JButton(\"Descargar fichero\");\n    JButton botonBorrar = new JButton(\"Eliminar fichero\");\n    JButton botonCreaDir = new JButton(\"Crear carpeta\");\n    JButton botonDelDir = new JButton(\"Eliminar carpeta\");  \n    JButton botonSalir = new JButton(\"Salir\");\n\n    //lista para los datos del directorio\n    static JList listaDirec = new JList();\n\n    //contenedor\n    private final Container c = getContentPane();\n\n    //Datos del servidor FTP\n    static FTPClient cliente = new FTPClient();//cliente FTP\n    String servidor = \"localhost\";\n    String user = \"usuario1\";\n    String pasw = \"usu1\";\n    boolean login;\n    static String direcInicial = \"/\";\n\n    //para saber directorio y fichero seleccionado\n    static String direcSelec = direcInicial;\n    static String ficheroSelec =\"\";\n\n    // constructor\n    public clienteFTPBasico() throws IOException {\n        super(\"CLIENTE B\u00c1SICO FTP\");        \n        System.out.println(\"Conectandose a \" + servidor);\n\n        cliente.addProtocolCommandListener(new PrintCommandListener (new PrintWriter (System.out) )); \n        cliente.connect(servidor);\n        cliente.enterLocalPassiveMode();\n        login = cliente.login(user, pasw);\n\n        cliente.changeWorkingDirectory(direcInicial);       \n\n        FTPFile[] files = cliente.listFiles();      \n        //Construyendo arbol de directorios, espere un momento  \n        llenarLista(files, direcInicial);\n\n        campo.setBounds(new Rectangle(3, 485, 485, 30));\n        campo.setForeground(Color.blue);\n        campo.setFont(new Font(\"Verdana\", Font.BOLD, 12));\n        campo.setText(\"&lt;&lt;   ARBOL DE DIRECTORIOS CONSTRUIDO    &gt;&gt;\");\n        campo2.setBounds(new Rectangle(3, 515, 485, 30));\n        campo2.setForeground(Color.blue);\n        campo2.setFont(new Font(\"Verdana\", Font.BOLD, 12));\n        campo2.setText(\" \");\n\n        cab.setBounds(new Rectangle(5, 5, 200, 30));        \n        cab.setBorder(null);\n        cab.setForeground(Color.blue);\n        cab.setFont(new Font(\"Arial\", Font.BOLD, 14));              \n        cab.setText(\"Servidor FTP: \"+servidor);\n\n        cab2.setBounds(new Rectangle(350, 5, 140, 30));\n        cab2.setBorder(null);\n        cab2.setFont(new Font(\"Arial\", Font.BOLD, 14));\n        cab2.setForeground(Color.blue);\n        cab2.setText(\"Usuario: \"+user);\n\n        cab3.setBounds(new Rectangle(5, 34, 140, 30));\n        cab3.setBorder(null);\n        cab3.setFont(new Font(\"Arial\", Font.BOLD, 14));\n        cab3.setForeground(Color.blue);\n        cab3.setText(\"DIRECTORIO RAIZ: \"+direcInicial);     \n\n        botonCargar.setBounds(new Rectangle(350, 100, 140, 30));\n        botonDescargar.setBounds(new Rectangle(350, 150, 140, 30));\n        botonBorrar.setBounds(new Rectangle(350, 200, 140, 30));        \n        botonCreaDir.setBounds(new Rectangle(350, 250, 140, 30));\n        botonDelDir.setBounds(new Rectangle(350, 300, 140, 30));\n        botonSalir.setBounds(new Rectangle(350, 350, 140, 30));\n\n        //PREPARACION DE LA LISTA\n        listaDirec.setSelectionMode(ListSelectionModel.SINGLE_SELECTION );//SINGLE_INTERVAL_SELECTION);\n        JScrollPane barraDesplazamiento = new JScrollPane(listaDirec);\n        barraDesplazamiento.setPreferredSize(new Dimension(335, 420));\n        barraDesplazamiento.setBounds(new Rectangle(5, 65, 335, 420));\n        c.add(barraDesplazamiento);\n        c.setLayout(null);      \n\n        c.add(campo); campo.setEditable(false);\n        c.add(campo2); campo2.setEditable(false);\n        c.add(botonCargar); c.add(botonDescargar);  c.add(botonBorrar);\n        c.add(botonSalir);c.add(botonCreaDir);c.add(botonDelDir);\n        c.add(cab);c.add(cab2);c.add(cab3);\n        cab.setEditable(false);cab2.setEditable(false);cab3.setEditable(false);\n\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setSize(510, 600);\n        setVisible(true);\n\n        //--clic en un elemento de la lista\n        listaDirec.addListSelectionListener(new ListSelectionListener() {   \n              public void valueChanged(ListSelectionEvent lse) {\n                if (lse.getValueIsAdjusting()) {\n\n                  ficheroSelec=\"\";\n\n                  //elemento seleccionado de la lista\n                  String fic = listaDirec.getSelectedValue().toString();\n\n                  if (listaDirec.getSelectedIndex() == 0) {\n                      //Se hace clic en el primer elemento del JList\n                      if (!fic.equals(direcInicial)) {  \n                          //si no estamos en el dictorio inicial, hay que \n                          //subir al directorio padre\n                      try {\n                        cliente.changeToParentDirectory();\n                        direcSelec = cliente.printWorkingDirectory();                   \n                        cliente.changeWorkingDirectory(direcSelec);\n                        FTPFile[] ff2 = cliente.listFiles();\n                        campo.setText(\"\");\n                              //se llena la lista con fich. del directorio padre\n                        llenarLista(ff2, direcSelec);\n                        } catch (IOException e) {e.printStackTrace();}\n                      }\n                  }\n                  //No se hace clic en el primer elemento del JList\n                  //Puede ser un fichero o un directorio\n                  else {\n                        if (fic.substring(0, 6).equals(\"(DIR) \")) {\n                        //SE TRATA DE UN DIRECTORIO\n                        try {       \n                          fic = fic.substring(6);       \n                          String direcSelec2 = \"\";\n                          if (direcSelec.equals(\"/\"))\n                            direcSelec2 = direcSelec + fic;\n                          else\n                            direcSelec2=direcSelec + \"/\" + fic;\n                          FTPFile[] ff2 = null; \n                                cliente.changeWorkingDirectory(direcSelec2);\n                          ff2 = cliente.listFiles();\n                          campo.setText(\"DIRECTORIO:  \"+ fic + \", \" \n                                                      + ff2.length + \" elementos\");\n                          direcSelec = direcSelec2;                           llenarLista(ff2, direcSelec);\n                        } catch (IOException e2) {e2.printStackTrace();}\n                          } else {\n                           // SE TRATA DE UN FICHERO \n                           ficheroSelec = direcSelec;\n                             if (direcSelec.equals(\"/\"))\n                             ficheroSelec +=  fic;\n                           else\n                             ficheroSelec += \"/\" + fic;\n                           campo.setText(\"FICHERO seleccionado:\" + \n                                                               ficheroSelec);\n                                 ficheroSelec=fic;\n                          }//fin else\n                   }//else de fichero o directorio\n                 campo2.setText(\"DIRECTORIO ACTUAL: \" + direcSelec);\n                }//fin if inicial               \n              }\n            });// fin lista\n\n\n        // --al hacer clic en el bot\ufffdn Salir\n        botonSalir.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    cliente.disconnect();                   \n                } catch (IOException e1) {                  \n                    e1.printStackTrace();\n                }\n                System.exit(0);\n            }\n        });\n\n        //CREAR CARPETA\n        botonCreaDir.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                String nombreCarpeta = JOptionPane.showInputDialog(null,\n                   \"Introduce el nombre del directorio\",\n                   \"carpeta\");  \n                if (!(nombreCarpeta==null)) {\n                    String directorio=direcSelec;\n                    if (!direcSelec.equals(\"/\"))\n                        directorio =directorio +\"/\";\n                    directorio+=nombreCarpeta.trim() ;\n\n                    try {\n                        if (cliente.makeDirectory(directorio)) {\n                            String m= nombreCarpeta.trim()  + \" =&gt; Se ha creado correctamente ...\";\n                            JOptionPane.showMessageDialog(null, m);\n                            campo.setText(m);\n                            cliente.changeWorkingDirectory(direcSelec);\n                            FTPFile[] ff2 = cliente.listFiles();\n                            llenarLista(ff2, direcSelec);                       \n\n                        } else\n                            JOptionPane.showMessageDialog(null, nombreCarpeta.trim()\n                                    + \" =&gt; No se ha podido crear ...\");\n\n                    } catch (IOException e1) {                      \n                        e1.printStackTrace();\n                    }\n                }\n            }\n        });//..botonCreaDir\n        //\n        botonDelDir.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                String nombreCarpeta = JOptionPane.showInputDialog(null,\n                           \"Introduce el nombre del directorio a eliminar\",\n                           \"carpeta\");  \n                        if (!(nombreCarpeta==null)) {\n                            String directorio=direcSelec;\n                            if (!direcSelec.equals(\"/\"))\n                                directorio =directorio +\"/\";\n                            directorio+=nombreCarpeta.trim() ;\n\n                            try {\n                                if (cliente.removeDirectory(directorio)) {\n                                    String m= nombreCarpeta.trim()  + \" =&gt; Se ha eliminado correctamente ...\";\n                                    JOptionPane.showMessageDialog(null, m);\n                                    campo.setText(m);\n                                    cliente.changeWorkingDirectory(direcSelec);\n                                    FTPFile[] ff2 = cliente.listFiles();\n                                    llenarLista(ff2, direcSelec);                       \n\n                                } else\n                                    JOptionPane.showMessageDialog(null, nombreCarpeta.trim()\n                                            + \" =&gt; No se ha podido eliminar ...\");\n\n                            } catch (IOException e1) {                      \n                                e1.printStackTrace();\n                            }\n                        }\n            }\n        });//..botonDelDir\n\n        // --al hacer clic en el bot\ufffdn Subir\n        botonCargar.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                JFileChooser f = new JFileChooser();                \n                f.setFileSelectionMode(JFileChooser.FILES_ONLY);\n                f.setDialogTitle(\"Selecciona el Fichero a SUBIR AL SERVIDOR FTP\");\n                int returnVal = f.showDialog(f, \"Cargar\");\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = f.getSelectedFile();\n                    String archivo = file.getAbsolutePath();\n                    String nombreArchivo = file.getName();                  \n                    try {\n                        SubirFichero(archivo, nombreArchivo);\n                    } catch (IOException e1) {\n                        e1.printStackTrace();\n                    }\n                }\n            }\n        });// Fin boon subir\n\n        // --al hacer clic en el bot\ufffdn Descargar\n        botonDescargar.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                String directorio=direcSelec;\n                if (!direcSelec.equals(\"/\"))\n                    directorio =directorio +\"/\";\n                if(!ficheroSelec.equals(\"\"))\n                {\n                    DescargarFichero(directorio + ficheroSelec ,ficheroSelec);\n                }\n            }\n        });// Fin boton descargar\n\n        botonBorrar.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                //System.out.println(\"borrar\");\n                String directorio=direcSelec;\n                if (!direcSelec.equals(\"/\"))\n                    directorio =directorio +\"/\";\n                if(!ficheroSelec.equals(\"\"))                \n                    BorrarFichero(directorio + ficheroSelec ,ficheroSelec);\n\n            }\n        });//boton borrar\n    }// ..FIN CONSTRUCTOR\n\n    // -----------------------------------------------------------------------------\n\n    private static void llenarLista(FTPFile[] files, String direc2) {\n        if (files == null)  return;\n        DefaultListModel modeloLista = new DefaultListModel();\n\n        listaDirec.setForeground(Color.blue);\n        Font fuente = new Font(\"Courier\", Font.PLAIN, 12);\n        listaDirec.setFont(fuente);     \n        listaDirec.removeAll();\n\n        try {\n            cliente.changeWorkingDirectory(direc2);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        direcSelec = direc2;\n        modeloLista.addElement(direc2);\n        for (int i = 0; i &lt; files.length; i++) {\n            if (!(files[i].getName()).equals(\".\")\n                    &amp;&amp; !(files[i].getName()).equals(\"..\")) {\n                String f = files[i].getName();              \n                if (files[i].isDirectory()) \n                    f = \"(DIR) \" + f;               \n                modeloLista.addElement(f);              \n            }//if\n        }// fin for\n        try {   \n            listaDirec.setModel(modeloLista);       \n        } catch (NullPointerException n) {\n            //Al llegar al \ufffdltimo aparece excepcion\n            ;System.out.println(\"linea 334 - llega al ultimo\");\n        }\n    }//Fin llenarLista\n\n    private void DescargarFichero(String NombreCompleto, String nombreFichero) {\n\n        String archivoyCarpetaDestino = \"\";\n        String carpetaDestino = \"\";\n        JFileChooser f = new JFileChooser();\n        f.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);\n        f.setDialogTitle(\"Selecciona el Directorio donde DESCARGAR el fichero\");\n\n        int returnVal = f.showDialog(null, \"Descargar\");\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File file = f.getSelectedFile();\n\n            carpetaDestino = (file.getAbsolutePath()).toString();\n            //System.out.println(\"carpeta destino \" + carpetaDestino);\n            archivoyCarpetaDestino = carpetaDestino + File.separator\n                    + nombreFichero;\n\n\n            try {\n                cliente.setFileType(FTP.BINARY_FILE_TYPE);\n                BufferedOutputStream out = null;\n                out = new BufferedOutputStream(new FileOutputStream(\n                        archivoyCarpetaDestino));\n\n\n                if (cliente.retrieveFile(NombreCompleto, out)) \n                    JOptionPane.showMessageDialog(null, nombreFichero\n                            + \" =&gt; Se ha descargado correctamente ...\");\n                 else\n                    JOptionPane.showMessageDialog(null, nombreFichero\n                            + \" =&gt; No se ha podido descargar ...\");\n\n                out.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n        }\n    }// ..DescargarFichero\n\n    private void BorrarFichero(String NombreCompleto, String nombreFichero) {\n        //pide confirmacion\n        int seleccion = JOptionPane.showConfirmDialog(null,\n                \"\ufffdDesea eliminar el fichero seleccionado?\");\n        if(seleccion==JOptionPane.OK_OPTION) {\n            try {                                                \n                if (cliente.deleteFile (NombreCompleto)) {\n                    String m= nombreFichero + \" =&gt; Eliminado correctamente... \";\n                    JOptionPane.showMessageDialog(null, m);\n                    campo.setText(m);\n                    cliente.changeWorkingDirectory(direcSelec);\n                    FTPFile[] ff2 = cliente.listFiles();\n                    llenarLista(ff2, direcSelec);   \n                } else\n                    JOptionPane.showMessageDialog(null, nombreFichero\n                            + \" =&gt; No se ha podido eliminar ...\");\n\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n        }       \n    }// ..BorrarFichero\n    // -------------------------------------------------------------------------\n    private  boolean SubirFichero(String archivo, String nombreArchivo)\n            throws IOException {\n\n        System.out.println(\"Archivo : \" +archivo);\n\n        cliente.setFileType(FTP.BINARY_FILE_TYPE);\n        BufferedInputStream in = new BufferedInputStream(new FileInputStream(\n                archivo));\n        boolean ok = false;\n        // System.out.println(\"Directorio =&gt; \" +direcSelec);\n        cliente.changeWorkingDirectory(direcSelec);\n        if (cliente.storeFile(nombreArchivo, in)) {\n            String s = \"  \" + nombreArchivo + \" =&gt; Subido correctamente... \";\n            campo.setText(s);\n            campo2.setText(\"Se va a actualizar el \ufffdrbol de directorios...\");\n            JOptionPane.showMessageDialog(null, s);\n            FTPFile[] ff2 = cliente.listFiles();\n            llenarLista(ff2, direcSelec);               \n            ok = true;\n        } else\n            campo.setText(\"No se ha podido subir... \" + nombreArchivo);\n\n        return ok;\n    }// SubirFichero\n\n    // main---------------------------------------------------------------------\n    public static void main(String[] args) throws IOException {\n        new clienteFTPBasico();\n    }// ..FIN main\n\n}// .fin clase\n</code></pre>"},{"location":"ud5/","title":"Unidad 5 - T\u00e9cnicas de programaci\u00f3n seguras","text":""},{"location":"ud5/#seguridad-digital","title":"Seguridad digital","text":"<p>Los aspectos fundamentales de la seguridad en las comunicaciones digitales son los siguientes:</p> <ul> <li>Integridad: Permite asegurar que los datos que recibe un receptor son id\u00e9nticos a los que ha enviado el emisor, es decir, no se ha modificado en ning\u00fan punto intermedio en el canal, que como sabemos, es un canal compartido y por tanto, inseguro. Las modificaciones pueden ser causadas por fallos en la transmisi\u00f3n a trav\u00e9s del canal o bien por una acci\u00f3n intencionada de un tercero.</li> <li>Confidencialidad: Nos asegura que los datos transmitidos son inteligibles s\u00f3lo para el receptor del mensaje. Por las caracter\u00edsticas del medio no podemos evitar que el mensaje llegue a otros destinatarios, pero lo que s\u00ed podemos evitar es que estos puedan ver el contenido original del mensaje. Esto se consigue cifrando el mensaje.</li> <li>Autenticaci\u00f3n: Permite asegurar al receptor de un mensaje que el emisor del mensaje es quien dice ser y no cualquier otro. Esto se consigue con los certificados y la firma digital.</li> <li>No repudio:  Es una consecuencia de la caracter\u00edstica anterior, ya que un receptor puede demostrar que el mensaje fue enviado por un emisor de forma inequ\u00edvoca.</li> </ul>"},{"location":"ud5/#seguridad-en-el-entorno-java","title":"Seguridad en el entorno Java","text":"<p>Desde el punto de vista de la seguridad, el conjunto de clases de seguridad distribuidas con el SDK de Java SE pueden dividirse en dos subconjuntos:</p> <ul> <li>Clases relacionadas con el control de acceso y la gesti\u00f3n de permisos.</li> <li>Clases relacionadas con la criptograf\u00eda.</li> </ul> <p>Java incluye APIs de acceso a funciones criptogr\u00e1ficas de prop\u00f3sito general, conocidas como la Arquitectura Criptogr\u00e1fica de Java o Java Cryptography Architecture (JCA) y la Extension Criptogr\u00e1fica de Java o Java Cryptography Extension (JCE).</p> <p>El JCA est\u00e1 formado por las clases b\u00e1sicas relacionadas con criptograf\u00eda distribuidas con el JDK y el soporte para la encriptaci\u00f3n lo proporciona el paquete de extensi\u00f3n JCE. Java tambi\u00e9n incluye un conjunto de paquetes para la comunicaci\u00f3n segura en Internet, conocidos como la Extensi\u00f3n de Sockets Seguros de Java o Java Secure Socket Extension (JSSE).</p> <p>Por \u00faltimo Java incluye una interfaz que permite a las aplicaciones Java acceder a servicios de control de autenticaci\u00f3n y acceso, el Servicio de Autentificaci\u00f3n y Autorizaci\u00f3n de Java o Java Authentication and Authorization Service (JAAS).</p> <p>Java tiene una Arquitectura de Proveedores, que permite que coexistan multiples implementaciones de algoritmos criptogr\u00e1ficos (es decir multiples implementaciones del JCE). La plataforma Java 2 extiende substancialmente la JCA, entre otras cosas se ha mejorado la infraestructura de gesti\u00f3n de certificados para soportar los certificados X.509 V3.</p> <p>Para comprender el funcionamiento del JCA tenemos que definir algunos t\u00e9rminos b\u00e1sicos:</p> <ul> <li> <p>Engine:  En el contexto del JCA utilizamos el t\u00e9rmino motor (engine) para referirnos a una representaci\u00f3n abstracta de un servicio criptogr\u00e1fico que no tiene una implementaci\u00f3n concreta. Un servicio criptogr\u00e1fico siempre est\u00e1 asociado con un algoritmo o tipo de algoritmo y puede tener alguna de las siguientes funciones:</p> <ul> <li>Proporcionar operaciones criptogr\u00e1ficas (como las empleadas en el firmado y el resumen de mensajes)- Generar o proporcionar el material criptogr\u00e1fico (claves o par\u00e1metros) necesario para realizar las operaciones.</li> <li>Generar objetos (almacenes de claves o certificados) que agrupen claves criptogr\u00e1ficas de modo seguro.</li> </ul> </li> </ul> <p>En el JDK el JCA se definen las siguientes clases Engine:</p> Clase JCA Funci\u00f3n java.security.MessageDigest Calculo de resumen de mensajes (hash) java.security.Signature Firma de datos y verificaci\u00f3n firmas java.security.KeyPairGenerator Generar pares de claves (p\u00fablica y privada) para un algoritmo java.security.KeyFactory Convertir claves de formato criptogr\u00e1fico, especificaciones de claves y viceversa java.security.certificate.CertificateFactory Crear certificados de clave p\u00fablica y listas de revocaci\u00f3n(CRLs) java.security.KeyStore Crear y gestionar un almac\u00e9n de claves (keystore) java.security.AlgorithmParameters Gestionar los par\u00e1metros de un algoritmo, incluyendo codificaci\u00f3n y descodificaci\u00f3n java.security.AlgorithmParameterGenerator Generar un conjunto de par\u00e1metros para un algoritmo java.security.SecureRandom Generar n\u00fameros aleatorios o pseudo aleatorios <ul> <li>Algoritmo: Un algoritmo es una implementaci\u00f3n de un motor. Por ejemplo, el algoritmo MD5 es una implementaci\u00f3n del motor de algoritmos de resumen de mensajes. La implementaci\u00f3n interna puede variar dependiendo del c\u00f3digo que proporcione la clase MD5.</li> <li>Proveedor: Un proveedor es el encargado de proporcionar la implementaci\u00f3n de uno o varios algoritmos al programador (es decir, darle acceso a una implementaci\u00f3n interna concreta de los algoritmos). La JCA define el concepto de proveedor mediante la clase abstracta Provider del paquete java.security. El constructor de una clase proveedor ajusta los valores de varias propiedades que necesita el API de seguridad de Java para localizar los algoritmos u otras facilidades implementadas por el proveedor. La clase Provider tiene m\u00e9todos para acceder al nombre del proveedor, el n\u00famero de versi\u00f3n y otras informaciones sobre las implementaciones de los algoritmos para la generaci\u00f3n, conversi\u00f3n y gesti\u00f3n de claves y la generaci\u00f3n de firmas y res\u00famenes.</li> <li> <p>Funciones hash: Un Message digest o resumen de mensaje, m\u00e1s conocidos como funciones hash, es una marca digital de un bloque de datos. Existe un gran n\u00famero de algoritmos dise\u00f1ados para procesar esto res\u00famenes, los dos m\u00e1s conocidos son SHA-1 y MD5. De un resumen cabe destacar las siguientes caracter\u00edsticas:</p> <ul> <li>Para el mismo algoritmo, el resumen siempre tiene el mismo tama\u00f1o, independientemente del tama\u00f1o de los datos que se haya usado para generarlo.</li> <li>Es imposible recuperar la informaci\u00f3n original a partir de un resumen.</li> <li>El resumen no debe desvelar nada sobre los datos que se utilizaron para generarlo.</li> <li>Es computacionalmente inviable encontrar dos mensajes que tengan el mismo valor de resumen. Matem\u00e1ticamente es altamente improbable, pero no imposible.</li> <li>Un peque\u00f1o cambio en los datos resumidos genera un resumen completamente diferente.</li> <li>Los res\u00famenes se usan para generar identificadores \u00fanicos y confiables.</li> </ul> </li> <li> <p>MessageDigest: La clase MessageDigest permite a las aplicaciones implementar algoritmos de resumen criptogr\u00e1ficamente seguros como SHA- 256 o SHA-512 Para generar un hash con JCA se procede de la siguiente forma:</p> <ol> <li>Se crea un objeto de la clase MesageDigest con el m\u00e9todo est\u00e1tico getInstance() de la misma clase, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.</li> <li>Se a\u00f1aden datos con el m\u00e9todo update(). Se puede a\u00f1adir un byte o un array de bytes. Este m\u00e9todo se puede invocar varias veces para ir a\u00f1adiendo nuevos datos.</li> <li>Se obtiene el valor de hash con el m\u00e9todo digest().</li> <li>Si se quisiera calcular un nuevo hash, se invocar\u00eda el m\u00e9todo reset() para volver a empezar el proceso.</li> </ol> </li> </ul>"},{"location":"ud5/#criptografia-simetrica","title":"Criptograf\u00eda sim\u00e9trica","text":"<p>Tenemos un conjunto de algoritmos denominados de clave sim\u00e9trica (tambi\u00e9n conocidos como de clave secreta) en los que, mediante la aplicaci\u00f3n de una clave conocida tanto por el emisor como por el receptor, la informaci\u00f3n se encripta o cifra de forma que s\u00f3lo pueda ser desencriptada o descifrada utilizando el mismo algoritmo y la misma clave.</p> <p>Entre los algoritmos de cifrado sim\u00e9trico m\u00e1s utilizados se encuentran:</p> <ul> <li>DES</li> <li>3DES o Tiple DES</li> <li>RC5</li> <li>AES</li> <li>Blowfish</li> <li>IDEA</li> </ul> <p></p>"},{"location":"ud5/#cipher","title":"Cipher","text":"<p>Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:</p> <ol> <li>Se crea un objeto de la clase SecretKey a partir de un KeyGenerator obtenido con el m\u00e9todo est\u00e1tico getInstance(), especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.</li> <li>As\u00ed podemos utilizar una clave prefijada o incluso una clave aleatoria de tipo OTP (One Time Password) ya que cada vez que ejecutemos el programa la clave ser\u00e1 diferente.</li> <li>Se crea un objeto de tipo Cipher indicando qu\u00e9 algoritmo vamos a usar. Y despu\u00e9s, con el m\u00e9todo init() se indica qu\u00e9 vamos a hacer (cifrar/descifrar) y con qu\u00e9 clave.</li> <li>Se a\u00f1aden datos con el m\u00e9todo update(). Se puede a\u00f1adir un byte o un array de bytes. Este m\u00e9todo se puede invocar varias veces para ir a\u00f1adiendo nuevos datos.</li> <li>Se obtiene el valor cifrado con el m\u00e9todo doFinal().</li> <li>Si se quisiera descifrar, s\u00f3lo hay que volver a invocar al m\u00e9todo init() indicando en este caso que queremos descifrar.</li> </ol>"},{"location":"ud5/#clases-para-cifrado-y-descifrado-simetrico","title":"Clases para cifrado y descifrado sim\u00e9trico","text":"<p>Existen dos clases stream que permiten cifrar y descifrar directamente. Pertenecen al paquete java.crypto pero por lo dem\u00e1s funcionan exactamente igual que las clases Stream del paquete java.io, de las que adem\u00e1s son clases descendientes y tienen constructores que permiten crear streams encriptados sobre un InputStream y un OutputStream.</p> Clase Ejemplo CipherInputStream CipherInputStream (InputStream is, Cipher c) CipherOutputStream CipherOutputStream (OutputStream os, Cipher c) <p>Por lo tanto, cuando tenemos que leer o escribir informaci\u00f3n, podemos a\u00f1adir un envoltorio m\u00e1s al wrapper que utilizamos habitualmente y esto nos permite que tanto las lecturas como las escrituras se hagan cifradas, usando el algoritmo y la clave definidos para el objeto Cipher. El uso m\u00e1s com\u00fan es para leer o escribir en archivos en los que, de igual forma, cambiando el wrapper nos permite leer o escribir la informaci\u00f3n de forma cifrada/descifrada.</p>"},{"location":"ud5/#ejemplo-de-criptografia-simetrica","title":"Ejemplo de criptograf\u00eda sim\u00e9trica","text":"<p>StreamCrypto.java</p> <pre><code>package encriptacion_simetrica;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class StreamCrypto {\n\n    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException {\n        File file;\n        String filePath = \"a.txt\";\n        file = new File(filePath);\n//Se define el objeto Cipher (Algoritmo/modo/relleno)\n        Cipher c = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); //DESede\n// Configuramos el modo de CIFRADO\n        byte[] valorClave = \"12345678123456781234567812345678\".getBytes();\n// CIFRADO DEL STREAM (fichero a.txt)\n\n        c.init(Cipher.ENCRYPT_MODE,\n                new SecretKeySpec(valorClave, \"AES\"));\n        try ( OutputStream outputStream = new BufferedOutputStream(\n                new CipherOutputStream(new FileOutputStream(file), c))) {\n            for (int i = 0; i &lt; 10; i++) {\n                outputStream.write(new String(\"Hello World\\n\").getBytes());\n            }\n        }\n// DESCIFRADO DEL STREAM (fichero a.txt)\n\n        c.init(Cipher.DECRYPT_MODE,\n                new SecretKeySpec(valorClave, \"AES\"));\n        try ( InputStream inputStream = new BufferedInputStream(\n                new CipherInputStream(new FileInputStream(file), c))) {\n            System.out.println(\"Contenido del fichero (descifrado):\\n\" + new String(inputStream.readAllBytes()));\n        }\n    }\n}\n</code></pre> <p>SecretKeyEncrypt.java</p> <pre><code>package encriptacion_simetrica;\n\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.InvalidKeySpecException;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class SecretKeyEncrypt {\n\n    public static void main(String[] args) {\n        SecretKey claveSecreta = null;\n        try {\n//Generamos clave secreta\n// Podemos crear una nueva clave\n            claveSecreta = getNewKey();\n// O bien usar una clave guardada en alg\u00fan almac\u00e9n, fichero, etc.\n            claveSecreta = getKeyFromData();\n            System.out.println(\"Clave usada: \" + claveSecreta.getFormat());\n//Se define el objeto Cipher (Algoritmo/modo/relleno)\n            Cipher c = Cipher.getInstance(\"DESede\"); // AES/ECB/PKCS5Padding\n// Configuramos el modo de CIFRADO\n            c.init(Cipher.ENCRYPT_MODE, claveSecreta);\n// Aqu\u00ed leemos la informaci\u00f3n que queremos cifrar\n// Puede ser una cadena o leerla de un archivo\n            byte[] textoPlano = \"Texto que queremos cifrar para la prueba\".getBytes();\n// Si queremos ir cifrando poco a poco, vamos haciendo llamadas\n// al m\u00e9todo update\n// c.update(textoPlano);\n// Se realiza el proceso final de cifrado de la informaci\u00f3n\n            byte[] textoCifrado = c.doFinal(textoPlano);\n            System.out.println(\"Texto cifrado con clave secreta (raw):\\n\" + new String(textoCifrado));\n            System.out.println(\"Texto cifrado con clave secreta (hex):\\n\" + toHexadecimal(textoCifrado));\n// El proceso de descifrado es equivalente\n// Cambiamos el modo de ENCRYPT a DECRYPT\n// Usamos la misma clave\n// Pasamos el texto cifrado para obtener el original\n            c.init(Cipher.DECRYPT_MODE, claveSecreta);\n            byte[] textoOriginal = c.doFinal(textoCifrado);\n//Leemos bloques de bytes del fichero y lo vamos escribiendo ya cifrado en el fichero de salida\n            System.out.println(\"Texto descifrado:\\n\" + new String(textoOriginal));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    static SecretKey getNewKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\n        KeyGenerator kg = KeyGenerator.getInstance(\"DESede\");\n        kg.init(112);\n        SecretKey clave = kg.generateKey();\n        return clave;\n    }\n\n    static SecretKey getNewRandomKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\n// Clave obtenida usando un generador de n\u00famero aleatorios seguro\n        KeyGenerator genClaves = KeyGenerator.getInstance(\"DESede\");\n// Utilizamos un algoritmo de generaci\u00f3n de aleatorios\n        SecureRandom srand = SecureRandom.getInstance(\"SHA1PRNG\");\n        genClaves.init(srand);\n        SecretKey clave = genClaves.generateKey();\n        System.out.println(\"Formato de clave: \" + clave.getFormat());\n        /*\nSecretKeyFactory keySpecFactory = SecretKeyFactory.getInstance(\"DESede\");\nDESedeKeySpec keySpec = (DESedeKeySpec) keySpecFactory.getKeySpec(clave, DESedeKeySpec.class);\nbyte[] valorClave = keySpec.getKey();\n         */\n        return clave;\n    }\n\n    static SecretKey getKeyFromData() throws InvalidKeySpecException, NoSuchAlgorithmException {\n// La clave se puede obtener desde un fichero o cualquier otra fuente\n        byte valorClave[] = \"12345678123456781234567812345678\".getBytes();\n        SecretKeySpec keySpec = new SecretKeySpec(valorClave, \"DESede\");\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DESede\");\n        SecretKey clave = keyFactory.generateSecret(keySpec);\n        return clave;\n    }\n\n    static Key getKeyFromData2() throws InvalidKeySpecException, NoSuchAlgorithmException {\n// La clave se puede obtener desde un fichero o cualquier otra fuente\n        byte valorClave[] = \"12345678123456781234567812345678\".getBytes();\n        Key clave = new SecretKeySpec(valorClave, \"AES\");\n        return clave;\n    }\n\n    static String toHexadecimal(byte[] hash) {\n        String hex = \"\";\n        for (int i = 0; i &lt; hash.length; i++) {\n            String h = Integer.toHexString(hash[i] &amp; 0xFF);\n            if (h.length() == 1) {\n                hex += \"0\";\n            }\n            hex += h;\n        }\n        return hex.toUpperCase();\n    }\n}\n</code></pre>"},{"location":"ud5/#criptografia-asimetrica","title":"Criptograf\u00eda asim\u00e9trica","text":"<p>La criptograf\u00eda asim\u00e9trica o criptograf\u00eda de clave p\u00fablica supuso una aut\u00e9ntica revoluci\u00f3n en su momento. Permit\u00eda el intercambio seguro de informaci\u00f3n (confidencialidad, autenticaci\u00f3n y no repudio) entre interlocutores que no compart\u00edan ning\u00fan secreto.</p> <p>Se cre\u00f3 en los a\u00f1os 70 a partir del trabajo de Diffie y Hellman por una parte y de Rivest, Shamir y Adleman por otra. Se basa en la existencia de un par de claves, una p\u00fablica y otra privada, entre las cuales existe una relaci\u00f3n matem\u00e1tica, de manera que es muy dif\u00edcil obtener la clave privada a partir de la p\u00fablica. Sin embargo, es muy sencillo obtener la clave p\u00fablica a partir de la privada. </p> <p>A diferencia del cifrado sim\u00e9trico, en el cifrado asim\u00e9trico se usan funciones diferentes para cifrar y descifrar los mensajes.</p> <ul> <li>Para encriptaci\u00f3n se usa la clave p\u00fablica. Cualquiera puede tener acceso a la clave p\u00fablica, mediante la cual, usando la funci\u00f3n de cifrado, se encripta la informaci\u00f3n dirigida a un destinatario concreto (el propietario de la clave privada asociada).</li> <li>Para desencriptaci\u00f3n se usa la clave privada, que debe mantenerse a buen recaudo ya que s\u00f3lo con esa clave y la funci\u00f3n de descifrado se puede desencriptar un mensaje cifrado con la clave p\u00fablica correspondiente.</li> </ul> <p>Entre los algoritmos de cifrado asim\u00e9trico m\u00e1s utilizados se encuentran:</p> <ul> <li>Rivest Shamir Adleman (RSA). Basado en la factorizaci\u00f3n de n\u00fameros primos grandes.</li> <li>Digital Signature Standard (DSS), que incorpora Digital Signature Algorithm (DSA).</li> <li>Elliptical Curve Cryptography (ECC). Est\u00e1 basado en las matem\u00e1ticas de las curvas el\u00edpticas.</li> <li>The Diffie-Hellman exchange method.</li> <li>TLS/SSL protocol.</li> </ul> <p></p>"},{"location":"ud5/#ejemplo-de-criptografia-asimetrica","title":"Ejemplo de criptograf\u00eda asim\u00e9trica","text":"<p>RsaKeyPairEncrypt.java</p> <pre><code>package encriptacion_asimetrica;\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.System.Logger;\nimport java.lang.System.Logger.Level;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic class RsaKeyPairEncrypt {\n\n    private static final int tamanoClaveAsimetrica = 1024;\n    private static final String algoritmoClaveAsimetrica = \"RSA\";\n    private static final String ficheroClavePublica = \"claves/clavepublica.der\";\n    private static final String ficheroClavePrivada = \"claves/claveprivada.pkcs8\";\n\n    public static void main(String[] args) throws InvalidKeyException, IllegalBlockSizeException, InvalidKeySpecException {\n        try {\n//////////////////////////////////////////////////\n// CIFRADO\n//////////////////////////////////////////////////\n// Leemos la clave p\u00fablica de un archivo\n            PublicKey clavePublica = leerClavePublica(ficheroClavePublica);\n// Preparamos la informaci\u00f3n que queremos cifrar\n            String textoEnClaro = \"Quiero cifrar este mensaje de prueba\";\n            byte[] mensajeEnClaro = textoEnClaro.getBytes(\"UTF-8\");\n// Realizamos el proceso de cifrado con clave p\u00fablica\n// Los pasos son exactamente los mismos que con el cifrado sim\u00e9trico\n            Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\n            cifrado.init(Cipher.ENCRYPT_MODE, clavePublica);\n            byte[] mensajeCifrado = cifrado.doFinal(mensajeEnClaro);\n// Visualizamos el mensaje cifrado en modo texto\n            MostrarMensajeBase64(mensajeCifrado);\n//////////////////////////////////////////////////\n// DESCIFRADO\n//////////////////////////////////////////////////\n// Leemos la clave privada de un archivo\n            PrivateKey clavePrivada = leerClavePrivada(ficheroClavePrivada);\n// Realizamos el proceso de descifrado con clave privada\n// Los pasos son exactamente los mismos que con el cifrado sim\u00e9trico\n// Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\n            cifrado.init(Cipher.DECRYPT_MODE, clavePrivada);\n            byte[] mensajeDescifrado = cifrado.doFinal(mensajeCifrado);\n// Visualizamos el mensaje descifrado\n            System.out.println(\"Texto descifrado:\\n\" + new String(mensajeDescifrado, \"UTF-8\"));\n        } catch (UnsupportedEncodingException ex) {\n            System.out.println(\"Codificaci\u00f3n de caracteres UTF-8 no soportada\");\n        } catch (NoSuchAlgorithmException ex) {\n            System.err.println(\"No se ha encontrado la implementaci\u00f3n del algoritmo \" + algoritmoClaveAsimetrica );\n} catch (NoSuchPaddingException ex) {\n            System.err.println(\"El relleno especificado para el algoritmo no est\u00e1 permitido\");\n        } catch (InvalidKeyException ex) {\n            System.err.println(\"Especificaci\u00f3n de clave no v\u00e1lida\");\n        } catch (IllegalBlockSizeException ex) {\n            System.err.println(\"Tama\u00f1o de bloque no v\u00e1lido\");\n        } catch (BadPaddingException ex) {\n            System.err.println(\"Excepci\u00f3n con el relleno usado por el algoritmo\");\n        }\n    }\n\n    private static PublicKey leerClavePublica(String ficheroClave) throws InvalidKeySpecException {\n        byte[] clavePublicaEncoded;\n// Leemos la informaci\u00f3n del archivo\n        try ( FileInputStream publicKeyFile = new FileInputStream(ficheroClave)) {\n            clavePublicaEncoded = publicKeyFile.readAllBytes();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"No se ha encontrado el archivo \" + ficheroClave + \" con la clave p\u00fablica.\");\n            return null;\n        } catch (IOException ex) {\n            System.out.println(\"Se ha producido un error de E/S accediendo al archivo \" + ficheroClave + \" de la clave \");\nreturn null;\n        }\n// Generamos la clave a partir del array de bytes le\u00eddos\n        KeyFactory keyFactory;\n        try {\n            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\n            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublicaEncoded);\n            PublicKey clavePublica = keyFactory.generatePublic(codificacionClavePublica);\n// Devolvemos la clave p\u00fablica generada\n            return clavePublica;\n        } catch (NoSuchAlgorithmException ex) {\n            System.err.println(\"No se ha encontrado la implementaci\u00f3n del algoritmo \" + algoritmoClaveAsimetrica );\nreturn null;\n        } catch (InvalidKeySpecException ex) {\n\n            return null;\n        }\n    }\n\n    private static PrivateKey leerClavePrivada(String ficheroClave) {\n        byte[] clavePrivadaEncoded;\n// Leemos la informaci\u00f3n del archivo\n        try ( FileInputStream privateKeyFile = new FileInputStream(ficheroClave)) {\n            clavePrivadaEncoded = privateKeyFile.readAllBytes();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"No se ha encontrado el archivo \" + ficheroClave + \" con la clave privada.\");\n            return null;\n        } catch (IOException ex) {\n            System.out.println(\"Se ha producido un error de E/S accediendo al archivo \" + ficheroClave + \" de la clave\");\nreturn null;\n        }\n// Generamos la clave a partir del array de bytes le\u00eddos\n        KeyFactory keyFactory;\n        try {\n            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\n            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivadaEncoded);\n            PrivateKey clavePrivada = keyFactory.generatePrivate(codificacionClavePrivada);\n// Devolvemos la clave p\u00fablica generada\n            return clavePrivada;\n        } catch (NoSuchAlgorithmException ex) {\n            System.err.println(\"No se ha encontrado la implementaci\u00f3n del algoritmo \" + algoritmoClaveAsimetrica);\nreturn null;\n        } catch (InvalidKeySpecException ex) {\n\n            return null;\n        }\n    }\n\n    private static void MostrarMensajeBase64(byte[] mensajeCifrado) {\n        System.out.println(\"Mensaje cifrado visualizado como texto en Base64:\");\n        System.out.println(Base64.getEncoder().encodeToString(mensajeCifrado).replaceAll(\"(.{76})\", \"$1\\n\"));\n    }\n}\n</code></pre> <p>GenerateRsaKeyPair.java</p> <pre><code>package encriptacion_asimetrica;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class GenerateRsaKeyPair {\n\n    private static final int tamanoClaveAsimetrica = 1024;\n    private static final String algoritmoClaveAsimetrica = \"RSA\";\n    private static final String ficheroClavePublica = \"claves/clavepublica.der\";\n    private static final String ficheroClavePrivada = \"claves/claveprivada.pkcs8\";\n\n    public static void main(String[] args) {\n        try {\n// Elijo un algoritmo de generaci\u00f3n de n\u00fameros aleatorios de los denominados\n// altamente seguros para generar el par de claves\n            SecureRandom algoritmoSeguro = SecureRandom.getInstanceStrong();\n// Preparo el generados de claves para usar el algortimo RSA\n            KeyPairGenerator genParClaves = KeyPairGenerator.getInstance(algoritmoClaveAsimetrica);\n            genParClaves.initialize(tamanoClaveAsimetrica, algoritmoSeguro);\n// Creo el par de claves y lo guardo en objetos\n            KeyPair parClaves = genParClaves.generateKeyPair();\n            PublicKey clavePublica = parClaves.getPublic();\n            PrivateKey clavePrivada = parClaves.getPrivate();\n// Guardamos la clave p\u00fablica en un archivo y la visualizamos\n// La clave se guarda con codificaci\u00f3n DER y en formato X.509\n            guardaClavePublicaX509(clavePublica);\n// Guardamos la clave privada en un archivo y la visualizamos\n// La clave se guarda con codificaci\u00f3n DER y en formato PKCS#8\n            guardaClavePrivadaPKCS8(clavePrivada);\n        } catch (NoSuchAlgorithmException ex) {\n            System.err.println(\"No se ha encontrado la implementaci\u00f3n del algortimo en ning\u00fan Provider\");\n        }\n    }\n\n    private static void guardaClavePublicaX509(PublicKey clavePublica) {\n        try ( FileOutputStream publicKeyFile = new FileOutputStream(ficheroClavePublica)) {\n            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublica.getEncoded(), algoritmoClaveAsimetrica);\n            publicKeyFile.write(clavePublica.getEncoded());\n// Visualizamos la clave por consola\n            MostrarClaveBase64(codificacionClavePublica.getEncoded(),\n                    codificacionClavePublica.getFormat(), ficheroClavePublica);\n        } catch (IOException ex) {\n            System.out.println(\"Error almacenando la clave p\u00fablica en \" + ficheroClavePublica);\n        }\n    }\n\n    private static void guardaClavePrivadaPKCS8(PrivateKey clavePrivada) {\n        try ( FileOutputStream privateKeyFile = new FileOutputStream(ficheroClavePrivada)) {\n            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivada.getEncoded(), algoritmoClaveAsimetrica);\n            privateKeyFile.write(clavePrivada.getEncoded());\n// Visualizamos la clave por consola\n            MostrarClaveBase64(codificacionClavePrivada.getEncoded(),\n                    codificacionClavePrivada.getFormat(), ficheroClavePrivada);\n        } catch (IOException ex) {\n            System.out.println(\"Error almacenando la clave privada en \" + ficheroClavePrivada);\n        }\n    }\n\n    private static void MostrarClaveBase64(byte[] clave, String formatoClave, String ficheroClave) {\n        System.out.println(\"Clave guardada en formato \" + formatoClave\n                + \" en fichero \" + ficheroClave);\n        System.out.println(Base64.getEncoder().encodeToString(clave).replaceAll(\"(.{76})\", \"$1\\n\"));\n    }\n}\n</code></pre>"},{"location":"ud5/#firma-digital","title":"Firma digital","text":"<p>Con la firma digital para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:</p> <p></p> <p>El proceso b\u00e1sico que se sigue para la firma electr\u00f3nica es el siguiente:</p> <ol> <li>El usuario dispone de un documento electr\u00f3nico (una hoja de c\u00e1lculo, un pdf, una imagen, incluso un formulario en una p\u00e1gina web) y de un certificado (clave p\u00fablica y clave privada) que le pertenece y le identifica.</li> <li>La aplicaci\u00f3n o dispositivo digital utilizados para la firma realiza un resumen del documento. El resumen de un documento de gran tama\u00f1o puede llegar a ser tan solo de unas l\u00edneas. Este resumen es \u00fanico y cualquier modificaci\u00f3n del documento implica tambi\u00e9n una modificaci\u00f3n del resumen.</li> <li>La aplicaci\u00f3n utiliza la clave privada para codificar el resumen.</li> <li>La aplicaci\u00f3n crea otro documento electr\u00f3nico que contiene ese resumen codificado. Este nuevo documento es la firma electr\u00f3nica. El resultado de todo este proceso es un documento electr\u00f3nico obtenido a partir del documento original y de las claves del firmante. La firma electr\u00f3nica, por tanto, es el mismo documento electr\u00f3nico resultante.</li> </ol> <p></p> <ul> <li>Integridad: Como estamos comparando funciones de resumen de un documento, se puede detectar de forma muy sencilla si el documento ha sufrido alguna modificaci\u00f3n respecto al momento en el que se firm\u00f3, garantizando de esta forma la integridad de la informaci\u00f3n firmada.</li> <li>Autenticaci\u00f3n y no repudio: Por las caracter\u00edsticas de los algoritmos de cifrado se puede determinar, a partir del resumen cifrado con la clave privada, mediante el uso de la clave p\u00fablica, que el mensaje recibido lo gener\u00f3 el propietario de la clave privada. Con esta caracter\u00edstica se puede probar y demostrar que el mensaje lo firm\u00f3 el emisor y no cualquier otra persona, garantizando por un lado la autor\u00eda y por otro evitando que el emisor niegue haber generado esa informaci\u00f3n.</li> </ul>"},{"location":"ud5/#certificados-digitales","title":"Certificados digitales","text":"<p>Un certificado digital es un documento electr\u00f3nico expedido por una Autoridad de Certificaci\u00f3n e identifica a una persona (f\u00edsica o jur\u00eddica) con un par de claves.Tiene como misi\u00f3n validar y certificar que una firma electr\u00f3nica se corresponde con una persona o entidad concreta.</p> <p>Contiene la informaci\u00f3n necesaria para firmar electr\u00f3nicamente e identificar a su propietario con sus datos: nombre, NIF, algoritmo y claves de firma, fecha de expiraci\u00f3n y organismo que lo expide.</p> <p>La Autoridad de Certificaci\u00f3n da fe de que la firma electr\u00f3nica se corresponde con un usuario concreto. Esa es la raz\u00f3n por la que los certificados est\u00e1n firmados, a su vez, por la Autoridad de Certificaci\u00f3n.</p>"},{"location":"ud5/#claves-digitales","title":"Claves digitales","text":"<p>En un certificado, las claves digitales son los elementos esenciales para la firma e identificaci\u00f3n del firmante. Existen dos claves, la clave privada y clave p\u00fablica, y trabajan de forma complementaria. Lo que cifra o codifica una clave s\u00f3lo lo puede descifrar o decodificar la otra.</p> <p>La diferencia entre ellas es que la clave privada est\u00e1 pensada para que nunca salga del certificado y est\u00e9 siempre bajo el control del firmante. En cambio, la clave p\u00fablica se puede repartir o enviar a otros usuarios.</p> <p>En ocasiones, se habla de Certificado Privado para referirse al certificado que contiene la clave privada y la p\u00fablica y del Certificado P\u00fablico para referirse al certificado que s\u00f3lo contiene la clave p\u00fablica.</p>"},{"location":"ud5/#infraestructura-de-clave-publica-pki","title":"Infraestructura de clave p\u00fablica (PKI)","text":"<p>Una infraestructura de clave p\u00fablica (PKI) es una combinaci\u00f3n de hardware, software, procedimientos de seguridad y marco legal que, en su conjunto, permite la ejecuci\u00f3n con garant\u00edas de operaciones criptogr\u00e1ficas, cumpliendo los requisitos de integridad, confidencialidad, autenticaci\u00f3n y no repudio.</p> <p>Una PKI permite establecer y gestionar asociaciones entre claves p\u00fablicas e identidades de personas y organizaciones. La cuesti\u00f3n entonces es determinar si un certificado es v\u00e1lido o de confianza, o lo que es lo mismo, si representa a la persona u organizaci\u00f3n que aparece como titular y propietario del certificado. Para dar por v\u00e1lido un certificado digital su firma digital debe ser v\u00e1lida y su emisor debe ser un emisor de confianza. Por lo tanto, ahora queda determinar qu\u00e9 emisores son de confianza.</p>"},{"location":"ud5/#autoridades-de-certificacion","title":"Autoridades de certificaci\u00f3n","text":"<p>Los certificados deben estar firmados por una AC por dos motivos:</p> <ol> <li>Garantizar su integridad, de forma que cualquier intento de modificaci\u00f3n del certificado lo invalide.</li> <li>Identificar al creador del certificado digital. Todo el sistema est\u00e1 basado en una relaci\u00f3n de confianza, en la que la AC que ha firmado el certificado es un emisor de confianza, normalmente instituciones p\u00fablicas o privadas de reconocido prestigio.</li> </ol> <p>En nuestro sistema podemos ver y modificar qu\u00e9 entidades de certificaci\u00f3n consideramos como seguras, es decir, que los certificados que \u00e9stas hayan firmado los tomaremos como v\u00e1lidos. En Windows, si ejecutamos certmgr.msc podemos acceder a la configuraci\u00f3n de certificados del sistema. En OSX lo podemos hacer con la aplicaci\u00f3n Llavero.</p> <p>Para nuestra navegaci\u00f3n, la informaci\u00f3n de qu\u00e9 certificados considera el navegador como seguros, depende de en qu\u00e9 AC confiemos (por defecto en la instalaci\u00f3n vienen configurados los m\u00e1s comunes).</p>"},{"location":"ud5/#generacion-de-par-de-claves","title":"Generaci\u00f3n de par de claves","text":"<p>La generaci\u00f3n y gesti\u00f3n de pares de claves implica dos aspectos fundamentales. Por un lado, tenemos la creaci\u00f3n de las claves. Las claves las podemos haber descargado, generado con alguna de las utilidades disponibles para ellos o bien, como veremos a continuaci\u00f3n, se pueden generar desde una aplicaci\u00f3n, igual que hacemos con las claves sim\u00e9tricas. </p> <p>Por otro lado, tenemos la gesti\u00f3n del almacenamiento de las claves. Las claves no dejan de ser archivos, que podemos tratar como archivos especiales, pero que usualmente se almacenan en repositorios especiales, denominados keyrings a los que puede acceder una aplicaci\u00f3n y desde los que gestionamos las relaciones de confianza.</p> <p>El JCA nos proporciona clases generadoras de claves. Estas clases se apoyan en buenos algoritmos de generaci\u00f3n de n\u00fameros aleatorios para satisfacer unos requisitos m\u00ednimos de seguridad. La clase SecureRandom genera n\u00famero aleatorios empleando alguno de los algoritmos disponibles y se puede utilizar un objeto de tipo SecureRandom para que los utilicen las clases generadoras de claves, tanto sim\u00e9tricas como asim\u00e9tricas.</p> <p>Hay varios tipos de ficheros que se utilizan para guardar certificados digitales siguiendo el est\u00e1ndar X.509. Generalmente un certificado no contiene s\u00f3lo la clave, sino que tiene informaci\u00f3n adicional.</p> <p>Existen dos posibles codificaciones para almacenar certificados X.509:</p> <ul> <li>der: Es una codificaci\u00f3n binaria.</li> <li>dem: Es una codificaci\u00f3n en formato texto guardado en Base64 y tienen un encabezado y pie que delimita el contenido del certificado. </li> </ul> <p>Adem\u00e1s de la codificaci\u00f3n, tenemos formatos de fichero est\u00e1ndar para guardar los certificados usando una de las codificaciones anteriores:</p> <ul> <li>cer, crt, der: Contienen certificados X.509 est\u00e1ndares codificados como der.</li> <li>p12: Realmente hace referencia a toda una familia de est\u00e1ndares asociados al algoritmo RSA y definen el formato de almacenamiento de distintos tipos de claves, los PKCS#n (PKCS#8, PKCS#12, etc). Pueden contener, adem\u00e1s de los datos del certificado, una clave privada. Si contiene la clave privada, \u00e9sta estar\u00e1 protegida por una contrase\u00f1a que ser\u00e1 necesaria para acceder a la clave privada.</li> </ul> <p>Usando las clases del JCA, estos son los pasos que debemos seguir para generar un par de claves desde c\u00f3digo:</p> <ol> <li>El primer paso para obtener un par de claves es obtener un objeto keyPairGenerator para el algoritmo que queramos utilizar.</li> <li>A continuaci\u00f3n se inicializa el generador del par de claves llamando a alguna de las versiones del m\u00e9todo initialize. En nuestro caso indicaremos el tama\u00f1o de clave para el algoritmo seleccionado y un generador de n\u00fameros aleatorios.</li> <li>El \u00faltimo paso es generar el par de claves y guardarlas en los objetos PrivateKey y PublicKey respectivamente.</li> <li>A partir de ese momento ya se pueden usar las claves para cifrar, descifrar e incluso para firmar. Sin embargo, si queremos reutilizar estas claves, lo que tendremos que hacer ser\u00e1 guardarlas en sendos archivos.</li> </ol>"},{"location":"ud5/#comunicaciones-seguras-con-java","title":"Comunicaciones seguras con Java","text":""},{"location":"ud5/#protocolo-ssl-y-jsse","title":"Protocolo SSL y JSSE","text":"<p>SSL es el protocolo habitualmente usado para encriptar la comunicaci\u00f3n cliente-servidor. Casi todo el tr\u00e1fico de la red puede encriptarse con SSL: POP, IMAP, telnet, FTP, etc, pero es especialmente interesante para dotar de seguridad al protocolo HTTP, es decir como base del HTTPS.</p> <p>La implementaci\u00f3n de SSL es una extensi\u00f3n de los sockets que permite establecer un canal (stream) de comunicaci\u00f3n. Dicha comunicaci\u00f3n se inicia con un handshake durante el cual, el cliente y el servidor construyen una session-key (clave sim\u00e9trica encriptada con par de claves asim\u00e9tricas) compartida para verificar su identidad mutua.</p> <p>JSSE (Java Secure Socket Extension) es un conjunto de paquetes que permiten el desarrollo de aplicaciones seguras en Internet. Proporciona un marco y una implementaci\u00f3n para Java de los protocolos SSL y TSL e incluye funcionalidad de:</p> <ul> <li>Encriptaci\u00f3n de datos.</li> <li>Autenticaci\u00f3n de servidores.</li> <li>Integridad de mensajes.</li> <li>Autenticaci\u00f3n de clientes.</li> </ul> <p>Con JSSE, los programadores pueden ofrecer intercambio seguro de datos entre un cliente y un servidor que ejecuta un protocolo de aplicaci\u00f3n, tales como HTTP, Telnet o FTP, a trav\u00e9s de TCP/IP. Las clases de JSSE se encuentran en los paquetes javax.net y javax.net.ssl.</p> <p>Las clases SSLSocket y SSLServerSocket representan sockets seguros y son derivadas de las ya conocidas Socket y ServerSocket respectivamente. JSSE tiene dos clases SSLServerSocketFactory y SSLSocketFactory para la creaci\u00f3n de sockets seguros. No tienen constructor, se obtienen a trav\u00e9s del m\u00e9todo est\u00e1tico getDefault(). </p> <p>Para obtener un socket servidor seguro o SSLServerSocket:</p> <pre><code>SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\nSSLServerSocket servidorSSL = (SSLServerSocket) sfact.createServerSocket(puerto);\n</code></pre> <p>El m\u00e9todo createServerSocket(int puerto) devuelve un socket de servidor enlazado al puerto especificado. Para crear un SSLSocket:</p> <pre><code>SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\nSSLSocket Cliente = (SSLSocket) sfact.createSocket(Host, puerto);\n</code></pre> <p>El m\u00e9todo createSocket(String host, int puerto) crea un socket y lo conecta con el host y el puerto especificados.</p>"},{"location":"ud5/#keytool-certificados-confianza-y-almacenes-de-claves","title":"Keytool: certificados, confianza y almacenes de claves","text":"<p>Cuando dos sockets SSL, uno cliente y otro servidor, intentan establecer conexi\u00f3n, tienen que \"presentarse\" el uno al otro y comprobar que el otro es de confianza. Si todo va bien y uno conf\u00eda en el otro, la conexi\u00f3n se establece, en caso contrario, no se establece.</p> <p>Para establecer esa confianza se debe crear un certificado en el servidor y a\u00f1adirlo a los certificados de confianza del cliente:</p> <ul> <li>El servidor debe tener su propio certificado. Si no lo tenemos, se puede generar primero una pareja de claves con la herramienta keytool, que viene incluida en el JDK de Java. La herramienta guardar\u00e1 la pareja de claves en un almac\u00e9n (el cual tiene su propia clave).</li> <li>Despu\u00e9s generaremos un certificado a partir de esa pareja.</li> <li>El c\u00f3digo del servidor necesitar\u00e1 indicar el fichero donde se almacenan las claves y la clave para acceder a ese almac\u00e9n.</li> <li>El cliente necesitar\u00e1 indicar que conf\u00eda en el certificado del servidor. Dicho certificado del servidor puede estar guardado (por ejemplo) en el almac\u00e9n de claves del cliente.</li> </ul>"},{"location":"ud5/#servidor-y-cliente-ssl","title":"Servidor y cliente SSL","text":"<p>La inicializaci\u00f3n del ServerSocket es diferente a como cuando lo hac\u00edamos en la unidad 3 con las conexiones cliente-servidor. A partir de que se llama al m\u00e9todo accept y, en este caso se obtiene una instancia de tipo SSLSocket, el resto del c\u00f3digo es igual que con la clase Socket.</p> <pre><code>SSLSocket clienteConectado = null;\nSSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\nSSLServerSocket servidorSSL = (SSLServerSocket) sfact.createServerSocket(puerto);\nclienteConectado = (SSLSocket) servidorSSL.accept();\n</code></pre> <p>En el cliente el proceso es el mismo, tras la llamada al m\u00e9todo createSocket, obtenemos una instancia de SSLSocket que utilizamos igual que si fuese un Socket.</p> <pre><code>SSLSocket clienteSSL = null;\nSystem.setProperty(\"javax.net.ssl.trustStore\", \"CertificadosConfianzaCliente\");\nSystem.setProperty(\"javax.net.ssl.trustStorePassword\", \"87654321\");\nSSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\nclienteSSL = (SSLSocket) sfact.createSocket(host, puerto);\n</code></pre> <p>Si ejecutamos el cliente y el servidor directamente, obtendremos el siguiente error:</p> <pre><code>Programa Cliente iniciado....\nException in thread \"main\" javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\n</code></pre> <p>Para ejecutar el programa servidor es necesario indicar el certificado que se utilizar\u00e1. Lo podemos indicar a la hora de ejecutar el programa, a\u00f1adiendo a la l\u00ednea de comandos.</p> <pre><code>java -Djavax.net.ssl.keyStore=ClavesServidor -Djavax.net.ssl.keyStorePassword=12345678\n</code></pre> <p>y en el programa cliente es necesario indicar la ubicaci\u00f3n de los certificados de confianza:</p> <pre><code>java -Djavax.net.ssl.trustStore=CertificadosConfianzaCliente -Djavax.net.ssl.trustStorePassword=87654321\n</code></pre> <p>o bien, en las opciones de ejecuci\u00f3n del IDE</p> <p>FALTA IMAGEN DE CONFIGURACION DE INTELLIJ -&gt; Run -&gt; Edit configuration -&gt; Modify option -&gt; add VM option</p> <p>Una vez hechos los cambios, bien en las opciones de la JVM o bien en el c\u00f3digo de las aplicaciones, la salida que obtendremos ser\u00e1 esta:</p> <pre><code>Esperando al cliente 1\nRecibiendo del CLIENTE: 1\nSaludos al SERVIDOR DESDE EL CLIENTE\nEsperando al cliente 2\nRecibiendo del CLIENTE: 2\nSaludos al SERVIDOR DESDE EL CLIENTE\nEsperando al cliente 3\nPrograma Cliente iniciado....\nRecibiendo del SERVIDOR:\nSaludos al cliente del servidor\n</code></pre>"},{"location":"ud5/#ejemplo-clienteservidor-con-ssl","title":"Ejemplo cliente/servidor con SSL","text":"<p>SSLClient.java</p> <pre><code>package cliente_servidor_SSL;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.cert.CertificateParsingException;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.SSLPeerUnverifiedException;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class SSLClient {\n\n    public static void main(String[] arg) throws IOException {\n        SSLSocket clienteSSL = null;\n        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\n        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\n// Las propiedades se pueden especificar mediante c\u00f3digo, o bien mediante\n// argumentos de la JVM en la llamada a la aplicaci\u00f3n\n// System.setProperty(\"javax.net.ssl.trustStore\", System.getProperty(\"user.dir\") + \"/CertificadosConfianzaClien\n        System.setProperty(\"javax.net.ssl.trustStore\", \"CertificadosConfianzaCliente\");\n        System.setProperty(\"javax.net.ssl.trustStorePassword\", \"87654321\");\n// Inicializaci\u00f3n del ServerSocket SSL\n        int puerto = 6000;\n        String host = \"localhost\";\n        System.out.println(\"Programa Cliente iniciado....\");\n        SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        clienteSSL = (SSLSocket) sfact.createSocket(host, puerto);\n// Trabajamos do DataInputStream y DataOutputStream para simplificar\n// el c\u00f3digo del ejemplo\n        flujoSalida = new DataOutputStream(clienteSSL.getOutputStream());\n        flujoEntrada = new DataInputStream(clienteSSL.getInputStream());\n// Env\u00edo un saludo al servidor\n        flujoSalida.writeUTF(\"Saludos al SERVIDOR DESDE EL CLIENTE\");\n// El Servidor responde con un mensaje\n        System.out.println(\"Recibiendo del SERVIDOR: \\n\\t\" + flujoEntrada.readUTF());\n// CERRAR STREAMS Y SOCKETS\n        flujoEntrada.close();\n        flujoSalida.close();\n        clienteSSL.close();\n    }\n\n    void mostrarInformacionSesionSSL(SSLSocket cliente) throws SSLPeerUnverifiedException, CertificateParsingException {\n//------------------------------------------------------------------------------\n//Ejemplo de la m\u00faltiple informaci\u00f3n sobre la sesi\u00f3n SSL\n// que se puede obtener a partir\n        SSLSession session = ((SSLSocket) cliente).getSession();\n        System.out.println(\"Host: \" + session.getPeerHost());\n        System.out.println(\"Cifrado: \" + session.getCipherSuite());\n        System.out.println(\"Protocolo: \" + session.getProtocol());\n        System.out.println(\"IDentificador:\" + new BigInteger(session.getId()));\n        System.out.println(\"Creaci\u00f3n de la sesi\u00f3n: \" + session.getCreationTime());\n        X509Certificate certificate = (X509Certificate) session.getPeerCertificates()[0];\n        System.out.println(\"Propietario: \" + certificate.getSubjectAlternativeNames());\n        System.out.println(\"Algoritmo: \" + certificate.getSigAlgName());\n        System.out.println(\"Tipo: \" + certificate.getType());\n        System.out.println(\"Emisor: \" + certificate.getIssuerAlternativeNames());\n        System.out.println(\"N\u00famero Serie: \" + certificate.getSerialNumber());\n//-----------------------------------------------------------------------------\n    }\n\n}\n</code></pre> <p>SSLServer.java</p> <pre><code>package cliente_servidor_SSL;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport javax.net.ssl.SSLServerSocket;\nimport javax.net.ssl.SSLServerSocketFactory;\nimport javax.net.ssl.SSLSocket;\n\npublic class SSLServer {\n\n    public static void main(String[] arg) throws IOException {\n        SSLSocket clienteConectado = null;\n        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\n        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\n\n// Las propiedades se pueden especificar mediante c\u00f3digo, o bien mediante\n// argumentos de la JVM en la llamada a la aplicaci\u00f3n\n// System.setProperty(\"javax.net.ssl.keyStore\", System.getProperty(\"user.dir\") + \"\\\\ClavesServidor\");\n// System.setProperty(\"javax.net.ssl.keyStorePassword\", \"12345678\");\n// Inicializaci\u00f3n del ServerSocket SSL\n        int puerto = 6000;\n        SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n        SSLServerSocket servidorSSL = (SSLServerSocket) sfact.createServerSocket(puerto);\n        for (int i = 1; i &lt; 5; i++) {\n            System.out.println(\"Esperando al cliente \" + i);\n// Se espera la conexi\u00f3n de un cliente con accept\n            clienteConectado = (SSLSocket) servidorSSL.accept();\n// Trabajamos do DataInputStream y DataOutputStream para simplificar\n// el c\u00f3digo del ejemplo\n            flujoEntrada = new DataInputStream(clienteConectado.getInputStream());\n            flujoSalida = new DataOutputStream(clienteConectado.getOutputStream());\n// El cliente env\u00eda un mensaje\n            System.out.println(\"Recibiendo del CLIENTE: \" + i + \" \\n\\t\" + flujoEntrada.readUTF());\n// El Servidor responde con un saludo\n            flujoSalida.writeUTF(\"Saludos al cliente del servidor\");\n        }\n// CERRAR STREAMS Y SOCKETS\n        flujoEntrada.close();\n        flujoSalida.close();\n        clienteConectado.close();\n        servidorSSL.close();\n    }\n\n}\n</code></pre>"}]}